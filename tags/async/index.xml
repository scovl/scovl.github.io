<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Async on scovl</title>
    <link>https://scovl.github.io/tags/async/</link>
    <description>Recent content in Async on scovl</description>
    <generator>Hugo</generator>
    <language>pt</language>
    <copyright>Vitor Lobo</copyright>
    <lastBuildDate>Wed, 23 Jul 2025 12:00:00 +0000</lastBuildDate>
    <atom:link href="https://scovl.github.io/tags/async/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Compreendendo a concorrência em Rust</title>
      <link>https://scovl.github.io/2025/07/23/rustconc/</link>
      <pubDate>Wed, 23 Jul 2025 12:00:00 +0000</pubDate>
      <guid>https://scovl.github.io/2025/07/23/rustconc/</guid>
      <description>&lt;p&gt;O Rust costuma ser apresentado como &lt;strong&gt;a linguagem que impede aqueles bugs de memória cabeludos&lt;/strong&gt; antes mesmo do seu código rodar. Mas essa história não para no &lt;strong&gt;&lt;a href=&#34;https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html#the-borrow-checker&#34;&gt;borrow checker&lt;/a&gt;&lt;/strong&gt;: ela se estende à concorrência. O pessoal da comunidade fala em &lt;strong&gt;fearless concurrenc&lt;/strong&gt; — “concorrência sem medo”. Mas o que isso significa realmente? Como explicar isso para alguém que vem de outras linguagens? Em resumo, Rust transforma muitos erros de concorrência em erros de compilação em vez de runtime, graças ao seu sistema de &lt;em&gt;ownership&lt;/em&gt; e tipos. Esse aspecto é o que chamamos de &lt;strong&gt;concorrência sem medo&lt;/strong&gt;, onde escrever código concorrente não precisa ser uma roleta-russa de bugs sutis.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
