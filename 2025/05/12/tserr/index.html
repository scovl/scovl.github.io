<!DOCTYPE html>
<html lang="pt">
<head>
    <title>Tratamento Funcional de Erros em TypeScript | scovl</title>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Usando fp-ts para gerenciar erros de forma robusta e tipada">


<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        mermaid.initialize({
            startOnLoad: true,
            theme: 'light',
            align: 'center'
        });
    });
</script>
 
</head>
<body>
    
    
    <header class="header">
    <div class="container">
        <div class="header-content">
            <a href="https://scovl.github.io/" class="site-title">scovl</a>
            
            <nav>
                <ul class="nav-menu">
                    
                    
                    <li>
                        <a href="/page/about/" class="nav-link ">
                            About
                        </a>
                    </li>
                    
                    <li>
                        <a href="/page/contact/" class="nav-link ">
                            Contact
                        </a>
                    </li>
                    
                </ul>
            </nav>
        </div>
    </div>
</header> 
    
    
    
    <main>
        <div class="container">
            
<article class="post">
    <header class="post-header">
        <h1 class="post-title">Tratamento Funcional de Erros em TypeScript</h1>
        <div class="post-meta">
            
            <time datetime="2025-05-12T18:31:45-03:00">
                Mon, May 12, 2025
            </time>
            
            
            
            <span class="post-author">por Vitor Lobo Ramos</span>
            
            
            
            <div class="post-tags">
                
                <a href="/tags/javascript/" class="tag">javascript</a>
                
                <a href="/tags/typescript/" class="tag">typescript</a>
                
                <a href="/tags/fp-ts/" class="tag">fp-ts</a>
                
                <a href="/tags/programa%C3%A7%C3%A3o-funcional/" class="tag">programação funcional</a>
                
                <a href="/tags/tratamento-de-erros/" class="tag">tratamento de erros</a>
                
                <a href="/tags/desenvolvimento/" class="tag">desenvolvimento</a>
                
            </div>
            
            
            
            <div class="reading-time">
                Estimated reading time: 29 min
            </div>
            
            
            
            <div class="post-description">
                Usando fp-ts para gerenciar erros de forma robusta e tipada
            </div>
            
        </div>
    </header>
    
    <div class="post-content">
        <p>Neste artigo, vamos explorar uma abordagem mais estruturada para o tratamento de erros em TypeScript usando conceitos de programação funcional. A biblioteca <a href="https://gcanti.github.io/fp-ts/">fp-ts</a> (Functional Programming em TypeScript) oferece ferramentas que permitem lidar com falhas de forma explícita e type-safe, melhorando a robustez e legibilidade do código. Existem também outras bibliotecas com abordagens semelhantes ou complementares no ecossistema TypeScript:</p>
<ul>
<li><a href="https://github.com/purify-ts/purify-ts"><strong>Purify-ts</strong></a>: Uma alternativa mais leve ao fp-ts, focada em tipos como Maybe e Either</li>
<li><a href="https://github.com/microsoft/neverthrow"><strong>Neverthrow</strong></a>: Biblioteca especializada em tratamento de erros com Result/Either</li>
<li><a href="https://github.com/Effect-TS/effect"><strong>Effect</strong></a>: Uma biblioteca mais recente que expande os conceitos do fp-ts com foco em STM (Software Transactional Memory), concorrência e gerenciamento de recursos</li>
<li><a href="https://github.com/zio/zio-ts"><strong>Zio-ts</strong></a>: Inspirada na biblioteca ZIO de Scala, oferecendo abstrações para IO, concorrência e recursos</li>
</ul>
<p>Cada uma dessas bibliotecas tem seus pontos fortes, mas o <a href="https://gcanti.github.io/fp-ts/">fp-ts</a> se destaca pela sua maturidade, documentação abrangente e ecossistema rico de bibliotecas complementares. Neste artigo, focaremos no fp-ts e em como ele aborda o tratamento de erros de forma funcional.</p>
<blockquote>
<p><strong>Nota sobre versões:</strong> Este artigo utiliza a sintaxe do fp-ts 3.x (lançada em abril de 2025), que introduziu mudanças significativas na API, incluindo <code>fold</code> → <code>match</code>, <code>mapLeft</code> → <code>mapError</code>, e outros renomeamentos para maior clareza. Se você estiver usando fp-ts 2.x, consulte a <a href="https://gcanti.github.io/fp-ts/guides/migration-v3.html">documentação de migração</a> para detalhes sobre as mudanças.</p></blockquote>
<h2 id="sumário">Sumário</h2>
<ul>
<li><a href="/2025/05/12/tserr/#o-dilema-do-tratamento-de-erros-convencional">O dilema do tratamento de erros convencional</a></li>
<li><a href="/2025/05/12/tserr/#erros-como-cidad%c3%a3os-de-primeira-classe">Erros como cidadãos de primeira classe</a></li>
<li><a href="/2025/05/12/tserr/#propriedades-avan%c3%a7adas-do-either">Propriedades avançadas do Either</a></li>
<li><a href="/2025/05/12/tserr/#usando-match-para-extrair-valores-de-either">Usando <code>match</code> para extrair valores de <code>Either</code></a></li>
<li><a href="/2025/05/12/tserr/#taskeither-computa%c3%a7%c3%a3o-ass%c3%adncrona-com-tratamento-expl%c3%adcito-de-erros">TaskEither: Computação Assíncrona com Tratamento Explícito de Erros</a></li>
<li><a href="/2025/05/12/tserr/#compondo-m%c3%baltiplas-requisi%c3%a7%c3%b5es-ass%c3%adncronas">Compondo múltiplas requisições assíncronas</a></li>
<li><a href="/2025/05/12/tserr/#refer%c3%aancias">Referências</a></li>
</ul>
<hr>
<h2 id="o-dilema-do-tratamento-de-erros-convencional">O Dilema do Tratamento de Erros Convencional</h2>
<p>No ecossistema JavaScript/TypeScript, historicamente, recorremos a duas abordagens principais para lidar com erros, cada uma com suas armadilhas. A forma mais comum de sinalizar e capturar erros é através de exceções, usando <code>throw</code> e <code>try/catch</code>. Porém, essa abordagem tem alguns problemas:</p>


  <pre><code class="language-typescript">function dividirLegado(a: number, b: number): number {
  if (b === 0) {
    throw new Error(&#34;Divisão por zero não é permitida!&#34;);
  }
  return a / b;
}

try {
  const resultado = dividirLegado(10, 0);
  console.log(&#34;Resultado:&#34;, resultado);
} catch (error: any) { // Note o &#39;any&#39;, um ponto fraco comum
  console.error(&#34;Ops, algo deu errado:&#34;, error.message);
  // Saída: &#34;Ops, algo deu errado: Divisão por zero não é permitida!&#34;
}</code></pre>
 <blockquote>
<p><strong>Nota:</strong> O uso de <code>any</code> para o tipo do erro é uma prática comum, mas não é a melhor opção. Em um sistema mais complexo, isso pode levar a erros de tipo que são difíceis de detectar.</p></blockquote>
<p>O uso de exceções apresenta sérios problemas de design: a assinatura da função <code>dividirLegado</code> não revela ao compilador a possibilidade de exceções, criando um contrato implícito onde o chamador precisa adivinhar a necessidade de um <code>try/catch</code>. Além disso, o <code>throw</code> interrompe abruptamente o fluxo de execução, dificultando o rastreamento e comprometendo a pureza funcional, enquanto a facilidade de esquecer blocos <code>try/catch</code> pode resultar em erros não capturados que derrubam aplicações inteiras. Uma alternativa comum é retornar valores especiais como <code>null</code>, <code>undefined</code> ou objetos de erro para sinalizar falhas, embora essa abordagem também apresente suas próprias limitações. Por exemplo:</p>


  <pre><code class="language-typescript">interface ResultadoDivisao {
  valor?: number;
  erro?: string;
}

function dividirComObjeto(a: number, b: number): ResultadoDivisao {
  if (b === 0) {
    return { erro: &#34;Divisão por zero!&#34; };
  }
  return { valor: a / b };
}

const resultadoObj = dividirComObjeto(10, 0);
if (resultadoObj.erro) {
  console.error(&#34;Falha:&#34;, resultadoObj.erro);
} else {
  console.log(&#34;Sucesso:&#34;, resultadoObj.valor);
}

// Ou com null:
function dividirComNull(a: number, b: number): number | null {
    if (b === 0) return null;
    return a / b;
}
const resultadoNull = dividirComNull(10, 0);
if (resultadoNull === null) console.error(&#34;Divisão por zero!&#34;);</code></pre>
 <p>Essa abordagem infelizmente também apresenta problemas significativos de usabilidade e segurança. O código se torna verboso e menos legível devido às constantes verificações manuais como <code>if (resultado.erro)</code> ou <code>if (resultado === null)</code>, enquanto a perda de contexto é inevitável, especialmente com valores <code>null</code> que não informam o motivo da falha - mesmo objetos de erro exigem disciplina manual consistente. Além disso, há um risco constante de erros silenciosos no sistema, pois esquecer de verificar o <code>null</code> ou a propriedade <code>erro</code> pode facilmente resultar em erros do tipo <code>TypeError: Cannot read property '...' of null</code> em partes subsequentes do código, comprometendo a robustez da aplicação como um todo.</p>
<hr>
<h2 id="erros-como-cidadãos-de-primeira-classe">Erros Como Cidadãos de Primeira Classe</h2>
<p>A Programação Funcional (FP) encara os erros de uma maneira fundamentalmente diferente: <strong>erros são simplesmente valores</strong>. Em vez de lançar exceções que quebram o fluxo, as funções retornam tipos de dados explícitos que representam tanto o sucesso quanto a falha. <code>fp-ts</code> nos fornece estruturas de dados poderosas para isso, como <code>Option</code> e <code>Either</code>. Antes de <code>Either</code>, vamos entender <code>Option</code>. Ele é usado para representar um valor que pode ou não estar presente. Pense nele como um substituto type-safe para <code>null</code> ou <code>undefined</code>.</p>
<ul>
<li><strong><code>Some&lt;A&gt;</code></strong>: Contém um valor do tipo <code>A</code>.</li>
<li><strong><code>None</code></strong>: Representa a ausência de um valor.</li>
</ul>
<p>O código abaixo mostra como usar <code>Option</code> para lidar com a ausência de valor. Vejamos:</p>


  <pre><code class="language-typescript">import * as O from &#39;fp-ts/Option&#39;;
import { pipe } from &#39;fp-ts/function&#39;;

interface User {
  id: number;
  name: string;
}
const users: User[] = [{ id: 1, name: &#34;Alice&#34; }, { id: 2, name: &#34;Bob&#34; }];

function findUserById(id: number): O.Option&lt;User&gt; {
  const user = users.find(u =&gt; u.id === id);
  return user ? O.some(user) : O.none; // Explicita a possibilidade de não encontrar
}

// Usando Option
const user1 = findUserById(1); // Some({ id: 1, name: &#34;Alice&#34; })
const user3 = findUserById(3); // None

pipe(
  user1,
  O.map(user =&gt; user.name.toUpperCase()), // Só executa se for Some
  O.match(
    () =&gt; console.log(&#34;Usuário não encontrado.&#34;), // Caso None
    (name) =&gt; console.log(&#34;Nome em maiúsculas:&#34;, name) // Caso Some
  )
); // Saída: Nome em maiúsculas: ALICE

pipe(
  user3,
  O.map(user =&gt; user.name.toUpperCase()),
  O.match(
    () =&gt; console.log(&#34;Usuário não encontrado.&#34;),
    (name) =&gt; console.log(&#34;Nome em maiúsculas:&#34;, name)
  )
); // Saída: Usuário não encontrado.</code></pre>
 <p>Note que <code>Option</code> é perfeito para casos onde a ausência não é necessariamente um &ldquo;erro&rdquo;, mas um estado esperado. Ele nos permite modelar de forma elegante situações como buscas que podem não retornar resultados, valores opcionais em formulários, ou acessos a propriedades que podem não existir.</p>
<p>Ao usar <code>Option</code>, tornamos explícito no sistema de tipos que um valor pode estar ausente, forçando o desenvolvedor a lidar com ambos os casos. Isso elimina erros comuns como referências nulas inesperadas e torna o código mais robusto, previsível e auto-documentado, sem a necessidade de verificações defensivas espalhadas pelo código.</p>
<blockquote>
<p><strong>Nota:</strong> O uso de <code>Option</code> é uma abordagem mais moderna e elegante para lidar com valores que podem estar ausentes. Ele é preferível ao uso de <code>null</code> ou <code>undefined</code> em muitos casos, pois fornece um tipo mais explícito e seguro para representar a ausência de valor.</p></blockquote>
<p>Para ilustrar ainda mais a utilidade de <code>Option</code>, especialmente em cenários do mundo real, vamos considerar uma operação assíncrona, como buscar dados de uma API. Muitas vezes, uma API pode não encontrar o recurso solicitado, e <code>Option</code> é uma excelente forma de modelar essa possibilidade sem recorrer a <code>null</code> ou exceções para um &ldquo;não encontrado&rdquo; esperado. Imagine que estamos buscando uma notícia por ID:</p>


  <pre><code class="language-typescript">interface Noticia {
  id: number;
  titulo: string;
  conteudo: string;
}

const buscarNoticia = async (id: number): Promise&lt;O.Option&lt;Noticia&gt;&gt; =&gt; {
  const noticia = await fetch(`https://api.exemplo.com/noticias/${id}`);
  if (noticia.status === 404) {
    return O.none;
  }
  return O.some(await noticia.json());
}

const noticia = await buscarNoticia(1);
pipe(
  noticia,
  O.match(
    () =&gt; console.log(&#34;Notícia não encontrada&#34;),
    (noticia) =&gt; console.log(noticia.titulo)
  )
);</code></pre>
 <p>Neste exemplo, <code>buscarNoticia</code> retorna um <code>Option&lt;Noticia&gt;</code>, que pode ser <code>Some</code> (com a notícia encontrada) ou <code>None</code> (quando a notícia não é encontrada). Isso torna o código mais claro e seguro, pois não precisamos verificar o status da resposta ou lidar com <code>null</code>/<code>undefined</code>.</p>
<h2 id="sucesso-explícito-ou-falha-detalhada">Sucesso Explícito ou Falha Detalhada</h2>
<p>Já o <code>Either</code> é o tipo protagonista no paradigma funcional quando precisamos modelar operações que podem falhar, oferecendo uma estrutura elegante que não apenas sinaliza o erro, mas também fornece detalhes específicos sobre a falha. Diferente de exceções tradicionais que interrompem o fluxo de execução, <code>Either</code> encapsula tanto o sucesso quanto o erro como valores de primeira classe, permitindo composição e transformação de operações falíveis de forma segura e previsível. Basicamente, <code>Either</code> é uma união de dois tipos: <code>Right</code> e <code>Left</code>:</p>
<ul>
<li><strong><code>Right&lt;A&gt;</code></strong>: Representa um resultado de sucesso, contendo um valor do tipo <code>A</code>. (Pense &ldquo;Right&rdquo; como &ldquo;correto&rdquo;).</li>
<li><strong><code>Left&lt;E&gt;</code></strong>: Representa uma falha, contendo um erro do tipo <code>E</code>. (Pense &ldquo;Left&rdquo; como o que sobrou, o erro).</li>
</ul>
<p>Para ficar mais claro, veja o gráfico abaixo:</p>


  
    
  
  <div class="mermaid">graph TD
    A[Sucesso] --&gt; B[Right&lt;A&gt;]
    C[Falha] --&gt; D[Left&lt;E&gt;]</div>
 <p>Esta estrutura nos permite representar de forma explícita tanto o caminho feliz quanto o caminho de erro em nossas operações, sem recorrer a exceções ou valores nulos. O tipo <code>Either</code> força o programador a considerar ambos os casos, tornando o código mais robusto e previsível. Vamos ver um exemplo prático em código:</p>


  <pre><code class="language-typescript">import * as E from &#34;fp-ts/Either&#34;;
import { pipe } from &#34;fp-ts/function&#34;; // pipe é essencial!

// Nosso divisor, agora funcional e type-safe!
function dividir(a: number, b: number): E.Either&lt;string, number&gt; {
  if (b === 0) {
    return E.left(&#34;Divisão por zero!&#34;); // Falha explícita com uma mensagem
  }
  return E.right(a / b); // Sucesso explícito com o valor
}

const resultado1 = dividir(10, 2); // Right(5)
const resultado2 = dividir(10, 0); // Left(&#34;Divisão por zero!&#34;)

console.log(resultado1);
console.log(resultado2);</code></pre>
 <p>O tipo de retorno <code>E.Either&lt;string, number&gt;</code> diz claramente: &ldquo;esta função retorna um número em caso de sucesso, OU uma string de erro em caso de falha.&rdquo; O compilador TypeScript agora <em>sabe</em> dos possíveis resultados. Nunca acessamos diretamente <code>Left</code> ou <code>Right</code> (ou <code>Some</code>/<code>None</code>). Em vez disso, usamos funções de alta ordem que operam sobre esses &ldquo;containers&rdquo;. A função <code>pipe</code> de <code>fp-ts/function</code> é crucial aqui para compor essas operações de forma legível.</p>
<p>A função <code>pipe(valorInicial, fn1, fn2, fn3)</code> é equivalente a <code>fn3(fn2(fn1(valorInicial)))</code>, simplificando a composição de funções. Ela recebe um valor inicial e o encaminha através de uma sequência de transformações, criando um fluxo de dados da esquerda para a direita que é intuitivo e fácil de acompanhar, melhorando significativamente a legibilidade do código em comparação com as chamadas aninhadas tradicionais. Veja o gráfico abaixo:</p>


  
  <div class="mermaid">graph LR
    A[valorInicial] --&gt; B[fn1]
    B --&gt; C[fn2]
    C --&gt; D[fn3]
    
    subgraph &#34;pipe(valorInicial, fn1, fn2, fn3)&#34;
    A
    B
    C
    D
    end
    
    style A fill:#f9f9f9,stroke:#666
    style D fill:#d5f5e3,stroke:#2ecc71,stroke-width:2px</div>
 <p>O diagrama acima mostra como funciona a função <code>pipe</code> de uma forma simples. Em vez de escrever código aninhado como <code>fn3(fn2(fn1(valorInicial)))</code>, que é difícil de ler, usamos <code>pipe(valorInicial, fn1, fn2, fn3)</code>, que é como ler uma receita: primeiro faça isso, depois aquilo&hellip;por exemplo:</p>


  <pre><code class="language-typescript">// Sem pipe (difícil de ler):
const resultado = multiplicarPorDois(somarCinco(converterParaNumero(&#34;10&#34;)));

// Com pipe (fácil de seguir):
const resultado = pipe(
  &#34;10&#34;,               // Valor inicial
  converterParaNumero, // Primeira transformação
  somarCinco,         // Segunda transformação
  multiplicarPorDois  // Terceira transformação
);</code></pre>
 <p>Pense no <code>pipe</code> como uma linha de montagem: o valor inicial entra por um lado, passa por várias estações de trabalho (funções), e sai transformado do outro lado!</p>
<h2 id="propriedades-avançadas-do-either">Propriedades Avançadas do Either</h2>
<p>O <code>Either</code> vai muito além de ser apenas um container para sucesso ou erro - ele é um conceito fundamental da programação funcional que implementa padrões poderosos que nos permitem compor operações de forma elegante e segura. Na programação funcional, o <code>Either</code> é classificado como um tipo algebráico que implementa interfaces importantes como <a href="https://en.wikipedia.org/wiki/Functor">Functor</a> e <a href="https://en.wikipedia.org/wiki/Monad_%28category_theory%29">Monad</a>. Vamos entender o que isso significa na prática e como isso nos ajuda a escrever código mais robusto:</p>
<ol>
<li><strong>Functor</strong>: O <code>Either</code> é um functor porque implementa a operação <code>map</code>, que permite transformar o valor dentro de um <code>Right</code> sem alterar a estrutura do container. Se for um <code>Left</code>, o erro é simplesmente propagado sem alteração.</li>
</ol>


  <pre><code class="language-typescript">// map transforma apenas o lado Right
const resultado = pipe(
  dividir(10, 2), // Right(5)
  E.map(valor =&gt; valor * 2) // Right(10)
);

// Se for Left, map não faz nada
const resultadoErro = pipe(
  dividir(10, 0), // Left(&#34;Divisão por zero!&#34;)
  E.map(valor =&gt; valor * 2) // Continua Left(&#34;Divisão por zero!&#34;)
);</code></pre>
 <ol start="2">
<li><strong>Monad</strong>: O <code>Either</code> também é uma monad porque implementa a operação <code>chain</code> (também chamada de <code>flatMap</code> ou <code>bind</code> em outras linguagens). Isso permite compor operações que também podem falhar, evitando o aninhamento de <code>E.Either&lt;E, E.Either&lt;E, A&gt;&gt;</code>.</li>
</ol>


  <pre><code class="language-typescript">// Outra função que pode falhar
const raizQuadrada = (n: number): E.Either&lt;string, number&gt; =&gt;
n &lt; 0 ? E.left(&#34;Não existe raiz de número negativo&#34;) : E.right(Math.sqrt(n));

// Usando chain para compor operações falíveis
const calcularRaizDaDivisao = (a: number, b: number) =&gt; pipe(
  dividir(a, b),        // E.Either&lt;string, number&gt;
E.chain(raizQuadrada) // E.Either&lt;string, number&gt;
);

console.log(calcularRaizDaDivisao(16, 4));  // Right(2)
console.log(calcularRaizDaDivisao(16, 0));  // Left(&#34;Divisão por zero!&#34;)
console.log(calcularRaizDaDivisao(-16, 4)); // Left(&#34;Não existe raiz de número negativo&#34;)</code></pre>
 <p>Estas propriedades tornam o <code>Either</code> extremamente poderoso para composição de operações, permitindo criar fluxos complexos de tratamento de erros de forma elegante e type-safe. O <code>map</code> nos permite transformar valores de sucesso, enquanto o <code>chain</code> nos permite sequenciar operações que podem falhar, com propagação automática de erros.</p>
<h2 id="usando-match-para-extrair-valores-de-either">Usando <code>match</code> para Extrair Valores de <code>Either</code></h2>
<p>Agora que entendemos o conceito de <code>pipe</code>, vamos explorar a função <code>match</code>, que é fundamental para extrair valores de um <code>Either</code>. Esta função permite definir duas funções: uma para o caso <code>Left</code> (erro) e outra para o caso <code>Right</code> (sucesso), funcionando essencialmente como um <code>if/else</code> especializado para o tipo <code>Either</code>. Com <code>match</code>, podemos transformar nosso <code>Either</code> em qualquer outro tipo, garantindo que ambos os casos sejam tratados explicitamente.</p>
<p>O <code>match</code> é uma forma de &ldquo;pattern matching&rdquo; funcional - um conceito poderoso de linguagens funcionais que permite lidar com diferentes &ldquo;casos&rdquo; ou &ldquo;formas&rdquo; que um valor pode ter. No caso do <code>Either</code>, temos dois padrões possíveis: <code>Left</code> e <code>Right</code>. O pattern matching nos força a tratar todos os casos possíveis de forma explícita, eliminando a possibilidade de esquecermos algum caminho. Isso é especialmente valioso em TypeScript, onde o sistema de tipos garanta que não podemos acessar o valor interno de um <code>Either</code> sem primeiro &ldquo;desempacotá-lo&rdquo; usando <code>match</code> ou funções similares. Agora que você já entendeu o conceito de <code>pipe</code>, vamos ver como usar <code>match</code> para extrair valores de um <code>Either</code> acompanhando o gráfico abaixo:</p>


  
  <div class="mermaid">graph LR
    A[Either&lt;E, A&gt;] --&gt; B{É Right?}
    B --&gt;|Sim| C[Right&lt;A&gt;]
    B --&gt;|Não| D[Left&lt;E&gt;]
    C --&gt; E[fnSucesso: A → B]
    D --&gt; F[fnErro: E → B]
    E --&gt; G[Resultado Final: B]
    F --&gt; G

    subgraph &#34;pipe &#43; match&#34;
    A
    B
    C
    D
    E
    F
    G
    end

    style A fill:#f9f9f9,stroke:#666
    style C fill:#d5f5e3,stroke:#2ecc71
    style D fill:#ffdddd,stroke:#e74c3c
    style G fill:#d6eaf8,stroke:#3498db,stroke-width:2px</div>
 <p>O processo começa com uma entrada <code>E.Either&lt;E, A&gt;</code>, que representa um valor que pode ser um sucesso (<code>Right&lt;A&gt;</code>) ou um erro (<code>Left&lt;E&gt;</code>). Quando aplicamos a função <code>match</code>, ela toma uma decisão baseada no tipo do <code>Either</code>: se for um <code>Right</code>, aplica a função de sucesso (<code>fnSucesso</code>) ao valor interno, transformando <code>A</code> em <code>B</code>; se for um <code>Left</code>, aplica a função de erro (<code>fnErro</code>) ao erro interno, transformando <code>E</code> também em <code>B</code>. O resultado final deste processo é sempre um valor do tipo <code>B</code>, independentemente do caminho seguido. Esta é a beleza do <code>match</code>: ele unifica os dois caminhos possíveis (sucesso e erro) em um único tipo de saída, permitindo que o código subsequente trabalhe com um valor concreto sem precisar verificar constantemente se estamos lidando com um sucesso ou um erro. Vamos ver um exemplo prático em código:</p>


  <pre><code class="language-typescript">import * as E from &#34;fp-ts/Either&#34;;
import { pipe } from &#34;fp-ts/function&#34;;

// Função que pode falhar
const divide = (a: number, b: number): E.Either&lt;string, number&gt; =&gt;
  b === 0 ? E.left(&#34;Divisão por zero!&#34;) : E.right(a / b);

// Tratamento com match
const result = pipe(
  divide(10, 0),
  E.match(
    (error) =&gt; `Erro: ${error}`, // fnErro
    (value) =&gt; `Resultado: ${value}` // fnSucesso
  )
);

console.log(result); // &#34;Erro: Divisão por zero!&#34;</code></pre>
 <p>O método <code>match</code> é particularmente útil quando você precisa <strong>transformar</strong> o resultado final de uma operação em um formato específico, como preparar dados para exibição na interface do usuário ou formatar mensagens para logging. Esta função é essencial para unificar os caminhos de sucesso e erro em um único tipo de retorno. Além disso, <code>match</code> serve como uma excelente maneira de <strong>encerrar</strong> uma cadeia de operações com um valor concreto, permitindo que você conclua o processamento de um <code>Either</code> e obtenha um resultado final que não é mais um tipo monádico.</p>
<h2 id="usando-map-para-transformar-o-valor-de-sucesso">Usando <code>map</code> para Transformar o Valor de Sucesso</h2>
<p>Enquanto <code>match</code> nos permite encerrar uma cadeia de operações unificando os caminhos de sucesso e erro, muitas vezes precisamos apenas transformar o valor de sucesso sem alterar o fluxo de tratamento de erros. É aqui que o operador <code>map</code> se torna valioso. Esta função aplica uma transformação apenas ao valor contido em um <code>Right</code>, deixando qualquer <code>Left</code> intacto e propagando o erro original sem modificação. O gráfico abaixo mostra como funciona o <code>map</code> em um <code>Either</code>:</p>


  
  <div class="mermaid">graph LR
    A[&#34;parseNumber(&#39;42&#39;)&#34;] --&gt; B[Right&lt;42&gt;]
    B --&gt; C[map: n → n * 2]
    C --&gt; D[Right&lt;84&gt;]
    D --&gt; E[fold: exibe resultado]
    
    A2[&#34;parseNumber(&#39;abc&#39;)&#34;] --&gt; B2[Left&lt;&#39;Erro&#39;&gt;]
    B2 --&gt; C2[map: ignorado]
    C2 --&gt; D2[Left&lt;&#39;Erro&#39;&gt;]
    D2 --&gt; E2[fold: exibe erro]

    subgraph &#34;Exemplo Completo&#34;
    A --&gt; E
    A2 --&gt; E2
    end

    style D fill:#d5f5e3,stroke:#2ecc71
    style D2 fill:#ffdddd,stroke:#e74c3c</div>
 <p>Vamos entender o diagrama acima: ele ilustra como o operador <code>map</code> funciona com o tipo <code>Either</code>. No caminho superior, quando <code>parseNumber('42')</code> retorna um <code>Right&lt;42&gt;</code> (sucesso), o <code>map</code> aplica a função de transformação (multiplicação por 2), resultando em <code>Right&lt;84&gt;</code>. No caminho inferior, quando <code>parseNumber('abc')</code> retorna um <code>Left&lt;'Erro'&gt;</code> (falha), o <code>map</code> ignora completamente a função de transformação, propagando o erro original sem modificação. Este comportamento é fundamental para a programação funcional, pois permite transformar valores de sucesso enquanto preserva automaticamente os erros, criando um fluxo de dados seguro e previsível. Vejamos um exemplo prático de como usar <code>map</code> com <code>Either</code>:</p>


  <pre><code class="language-typescript">const resultadoDobrado = pipe(
  dividir(20, 2),         // Right(10)
  E.map(valor =&gt; valor * 2) // Aplica valor * 2 somente se for Right
); // resultadoDobrado é Right(20)

const falhaDobrada = pipe(
  dividir(20, 0),         // Left(&#34;Divisão por zero!&#34;)
  E.map(valor =&gt; valor * 2) // Não é executado
); // falhaDobrada é Left(&#34;Divisão por zero!&#34;)</code></pre>
 <h2 id="usando-chain-para-encadear-operações-falíveis">Usando <code>chain</code> para Encadear Operações Falíveis</h2>
<p>Enquanto <code>map</code> é perfeito para transformações simples de valores de sucesso, ele não é suficiente quando a própria transformação pode falhar. É aqui que <code>chain</code> se torna essencial. Esta função permite compor operações sequenciais onde cada etapa depende do resultado bem-sucedido da anterior e pode, por si só, produzir um erro. Diferente do <code>map</code>, que sempre envolve o resultado da transformação em um novo <code>Right</code>, o <code>chain</code> espera que a função de transformação já retorne um <code>Either</code>, evitando o aninhamento desnecessário de estruturas.</p>
<p>Na prática, <code>chain</code> é fundamental para construir fluxos de validação e processamento robustos. Por exemplo, ao processar dados de usuário, podemos encadear várias validações (verificar formato de email, checar comprimento de senha, validar idade) onde cada etapa só é executada se a anterior for bem-sucedida. Se qualquer validação falhar, o erro é propagado automaticamente até o final da cadeia, eliminando a necessidade de verificações condicionais repetitivas e tornando o código mais declarativo e menos propenso a erros. Vejamos um exemplo prático de como usar <code>chain</code> com <code>Either</code> no gráfico abaixo:</p>


  
  <div class="mermaid">graph TD
    A[Either&lt;E, A&gt;] --&gt; B{É Right?}
    B --&gt;|Sim| C[Right&lt;A&gt;]
    B --&gt;|Não| D[Left&lt;E&gt;]
    C --&gt; E[chain: A → Either&lt;E, B&gt;]
    D --&gt; F[Left&lt;E&gt;]
    E --&gt; G{É Right?}
    G --&gt;|Sim| H[Right&lt;B&gt;]
    G --&gt;|Não| I[Left&lt;E&gt;]
    H --&gt; J[map: B → C]
    I --&gt; K[Left&lt;E&gt;]
    J --&gt; L[Right&lt;C&gt;]
    K --&gt; M[Left&lt;E&gt;]
        L --&gt; N[match: C → D]
    M --&gt; N[match: E → D]
    
    subgraph &#34;pipe &#43; chain &#43; map &#43; match&#34;
    A
    B
    C
    D
    E
    F
    G
    H
    I
    J
    K
    L
    M
    N
    end

    style A fill:#f9f9f9,stroke:#666
    style C fill:#d5f5e3,stroke:#2ecc71
    style D fill:#ffdddd,stroke:#e74c3c
    style H fill:#d5f5e3,stroke:#2ecc71
    style I fill:#ffdddd,stroke:#e74c3c
    style L fill:#d5f5e3,stroke:#2ecc71
    style M fill:#ffdddd,stroke:#e74c3c
    style N fill:#d6eaf8,stroke:#3498db,stroke-width:2px</div>
 <p>O diagrama acima ilustra o fluxo de processamento usando a combinação de operadores <code>pipe</code>, <code>chain</code>, <code>map</code> e <code>match</code> com o tipo <code>Either</code>. Ele demonstra como um valor inicial <code>E.Either&lt;E, A&gt;</code> é processado através de uma série de transformações condicionais. Se o valor for um <code>Right&lt;A&gt;</code>, ele passa pela função <code>chain</code> que pode produzir um novo <code>E.Either&lt;E, B&gt;</code>. Se esse resultado for um <code>Right&lt;B&gt;</code>, ele é transformado pela função <code>map</code> em um <code>Right&lt;C&gt;</code>. Em qualquer ponto onde um <code>Left&lt;E&gt;</code> é encontrado, o fluxo de transformações é curto-circuitado, propagando o erro até o final.</p>
<p>Finalmente, a função <code>match</code> é aplicada para extrair o valor final, seja ele um sucesso (<code>C</code>) ou um erro (<code>E</code>), convertendo-os para um tipo comum <code>D</code>. Este padrão de composição permite criar pipelines de processamento robustos onde os erros são tratados de forma elegante e explícita. Vamos ver um exemplo prático de como usar <code>chain</code> com <code>Either</code> no código abaixo:</p>


  <pre><code class="language-typescript">// Função que valida se um número é positivo
const garantirPositivo = (n: number): E.Either&lt;string, number&gt; =&gt;
  n &gt; 0 ? E.right(n) : E.left(&#34;Número deve ser positivo!&#34;);

// Função que calcula a raiz quadrada (apenas para positivos)
const raizQuadradaSegura = (n: number): E.Either&lt;string, number&gt; =&gt;
  n &lt; 0 ? E.left(&#34;Não é possível calcular raiz de número negativo!&#34;) : E.right(Math.sqrt(n));

// Cenário 1: Sucesso em tudo
const computacaoSucesso = pipe(
  dividir(32, 2),           // Right(16)
  E.chain(garantirPositivo),  // Right(16) -&gt; garantirPositivo(16) -&gt; Right(16)
  E.chain(raizQuadradaSegura) // Right(16) -&gt; raizQuadradaSegura(16) -&gt; Right(4)
);
console.log(pipe(computacaoSucesso, E.match(e =&gt; e, v =&gt; v.toString()))); // &#34;4&#34;

// Cenário 2: Falha na divisão
const computacaoFalhaDivisao = pipe(
  dividir(32, 0),           // Left(&#34;Divisão por zero!&#34;)
  E.chain(garantirPositivo),  // Ignorado, propaga Left(&#34;Divisão por zero!&#34;)
  E.chain(raizQuadradaSegura) // Ignorado, propaga Left(&#34;Divisão por zero!&#34;)
);
console.log(pipe(computacaoFalhaDivisao, E.match(e =&gt; e, v =&gt; v.toString()))); // &#34;Divisão por zero!&#34;

// Cenário 3: Falha na validação de positivo
const computacaoFalhaPositivo = pipe(
  E.right(-10),               // Começamos com um Right(-10) para este exemplo
  E.chain(garantirPositivo),  // Right(-10) -&gt; garantirPositivo(-10) -&gt; Left(&#34;Número deve ser positivo!&#34;)
  E.chain(raizQuadradaSegura) // Ignorado, propaga Left(&#34;Número deve ser positivo!&#34;)
);
console.log(pipe(computacaoFalhaPositivo, E.match(e =&gt; e, v =&gt; v.toString()))); // &#34;Número deve ser positivo!&#34;</code></pre>
 <p>Note como o primeiro <code>Left</code> encontrado interrompe a cadeia e é propagado até o final.</p>
<hr>
<h2 id="usando-taskeithere-a-o-poder-de-either-no-mundo-assíncrono">Usando <code>TaskEither&lt;E, A&gt;</code>: O Poder de <code>Either</code> no Mundo Assíncrono</h2>
<p>E quando nossas operações são assíncronas, como chamadas de API ou interações com banco de dados? Para entender o <code>TaskEither&lt;E, A&gt;</code>, vamos construir o conceito passo a passo:</p>
<ol>
<li>
<p>Uma <code>Promise&lt;A&gt;</code> no JavaScript representa uma operação assíncrona que eventualmente produzirá um valor do tipo <code>A</code> ou será rejeitada com um erro.</p>
</li>
<li>
<p>Na biblioteca fp-ts, o tipo <code>Task&lt;A&gt;</code> é essencialmente uma função que retorna uma <code>Promise&lt;A&gt;</code>, mas com uma abordagem mais funcional. É definido como <code>() =&gt; Promise&lt;A&gt;</code>.</p>
</li>
<li>
<p>O <code>TaskEither&lt;E, A&gt;</code> combina o conceito de <code>Task</code> com <code>Either</code>. Formalmente, é um <code>Task&lt;Either&lt;E, A&gt;&gt;</code>, ou seja, uma função que retorna uma promessa que resolverá para um <code>Either&lt;E, A&gt;</code>.</p>
</li>
</ol>
<p>Isso nos dá o melhor dos dois mundos: a capacidade de lidar com operações assíncronas (como o <code>Promise</code>) e um tratamento de erros explícito e tipado (como o <code>Either</code>). Na prática, o <code>TaskEither</code> é perfeito para operações que demoram para completar e podem falhar, como buscar dados de um servidor ou ler um arquivo. Em vez de usar <code>try/catch</code> espalhados pelo código ou verificar erros manualmente, você encadeia operações de forma elegante e o TypeScript garanta que você não esqueça de tratar os erros.</p>
<p>A grande vantagem é que, diferente de uma <code>Promise</code> comum que mistura o fluxo de sucesso e erro em callbacks separados (<code>.then()</code> e <code>.catch()</code>), o <code>TaskEither</code> mantém ambos os caminhos dentro do mesmo tipo, permitindo composição mais segura e previsível de operações assíncronas que podem falhar. Vamos ver um exemplo prático de como usar <code>TaskEither</code> no código abaixo:</p>


  <pre><code class="language-typescript">import * as TE from &#34;fp-ts/TaskEither&#34;;
// &#39;pipe&#39; já foi importado de &#39;fp-ts/function&#39;

interface UserData {
  id: number;
  name: string;
  email: string;
}

// Erro customizado para nossa API
class NetworkError extends Error {
  constructor(message: string, public status?: number) {
    super(message);
    this.name = &#34;NetworkError&#34;;
  }
}

const fetchUser = (userId: number): TE.TaskEither&lt;NetworkError, UserData&gt; =&gt;
  TE.tryCatch&lt;NetworkError, UserData&gt;(
    // A função que retorna uma Promise (o &#34;try&#34; do tryCatch)
    async () =&gt; {
      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
      if (!response.ok) {
        // Lançamos um erro customizado para ser capturado pelo &#39;onRejected&#39;
        throw new NetworkError(`Falha na requisição: ${response.statusText}`, response.status);
      }
      return response.json() as Promise&lt;UserData&gt;; // Garantimos o tipo
    },
    // A função que converte o erro/rejeição da Promise em um Left&lt;E&gt;
    (motivoDesconhecido: unknown): NetworkError =&gt; {
      if (motivoDesconhecido instanceof NetworkError) {
        return motivoDesconhecido;
      }
      // Para outros tipos de erros (ex: falha de rede antes da resposta HTTP)
      return new NetworkError(String(motivoDesconhecido));
    }
  );

// Como usar:
async function exibirNomeUsuario(id: number): Promise&lt;void&gt; {
  const programa = pipe(
    fetchUser(id), // Retorna TaskEither&lt;NetworkError, UserData&gt;
    TE.map(user =&gt; `Nome do usuário: ${user.name}`), // Transforma o sucesso
    TE.matchE(
      // Função para o caso de falha (Left)
      (erro) =&gt; async () =&gt; console.error(`Erro ao buscar usuário: ${erro.message}${erro.status ? ` (Status: ${erro.status})` : &#39;&#39;}`),
      // Função para o caso de sucesso (Right)
      (nomeFormatado) =&gt; async () =&gt; console.log(nomeFormatado)
    )
  );
  // Para executar o TaskEither e obter o resultado (ou efeito colateral), chamamos a função retornada por matchE:
  await programa();
}

// Pattern alternativo: TE.mapError para logging de erros no pipeline
const programaComLog = pipe(
  fetchUser(id),
  TE.mapError((erro) =&gt; {
    console.error(`Falha na operação: ${erro.message}`);
    // Aqui você pode adicionar logging estruturado, métricas, etc.
    return erro; // Retorna o erro para continuar o pipeline
  }),
  TE.matchE(
    (erro) =&gt; async () =&gt; console.error(`Erro final: ${erro.message}`),
    (user) =&gt; async () =&gt; console.log(`Sucesso: ${user.name}`)
  )
);

// Testando:
// exibirNomeUsuario(1); // Deve imprimir &#34;Nome do usuário: Leanne Graham&#34; (ou similar)
// exibirNomeUsuario(999); // Deve imprimir o erro de &#34;Falha na requisição: Not Found (Status: 404)&#34;</code></pre>
 <p>O <code>tryCatch</code> é um construtor muito útil para envolver código baseado em Promises que pode rejeitar. Ele transforma o modelo tradicional de tratamento de erros com <code>try/catch</code> em uma estrutura funcional, encapsulando tanto o caminho feliz quanto o de erro em um único tipo de dados <code>TaskEither</code>. Isso permite que o código cliente trabalhe com um valor que representa explicitamente a possibilidade de falha, em vez de depender de exceções implícitas.</p>
<p>A principal vantagem desse construtor é a separação clara entre a lógica de negócio e o tratamento de erros. Ao usar <code>tryCatch</code>, você define duas funções: uma que executa a operação principal (retornando uma Promise) e outra que converte qualquer erro em um tipo específico. Isso torna o código mais previsível e facilita o rastreamento de todos os possíveis caminhos de erro através do sistema de tipos.</p>
<p>Além disso, <code>tryCatch</code> se integra perfeitamente com outras funções do ecossistema fp-ts, permitindo compor operações assíncronas que podem falhar de maneira elegante e segura. Em vez de aninhamentos complexos de try/catch ou promessas encadeadas com .catch(), você pode usar operadores como pipe, map e chain para expressar fluxos de dados complexos de forma declarativa, mantendo o tratamento de erros consistente em toda a aplicação.</p>
<p>A tabela abaixo compara as diferentes estratégias de tratamento de erros em TypeScript, destacando os pontos fortes e fracos de cada uma:</p>
<table>
  <thead>
      <tr>
          <th>Abordagem</th>
          <th>Prós</th>
          <th>Contras</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>try/catch com exceções</strong></td>
          <td>• Sintaxe familiar e padrão da linguagem<br>• Separação visual entre código normal e tratamento de erro<br>• Captura erros em qualquer nível da pilha de chamadas</td>
          <td>• Contrato implícito (assinatura da função não indica possibilidade de erro)<br>• Interrompe abruptamente o fluxo de execução<br>• Fácil esquecer de usar try/catch<br>• Difícil composição de funções que podem lançar exceções<br>• Tipagem de erros geralmente fraca (any)</td>
      </tr>
      <tr>
          <td><strong>Retorno de null/undefined</strong></td>
          <td>• Simplicidade de implementação<br>• Não interrompe o fluxo de execução</td>
          <td>• Perda completa de contexto do erro<br>• Verificações constantes de null/undefined<br>• Fácil esquecer verificações, causando erros em runtime<br>• Não escala bem para operações compostas</td>
      </tr>
      <tr>
          <td><strong>Objetos de resultado/erro</strong></td>
          <td>• Contrato explícito<br>• Preserva algum contexto de erro<br>• Não interrompe o fluxo de execução</td>
          <td>• Código verboso com muitas verificações manuais<br>• Disciplina manual para manter consistência<br>• Composição de operações torna-se complexa<br>• Tipagem pode ser ambígua (propriedades opcionais)</td>
      </tr>
      <tr>
          <td><strong>Either/TaskEither</strong></td>
          <td>• Contrato totalmente explícito via sistema de tipos<br>• Composição elegante de operações<br>• Tratamento de erro obrigatório (impossível &ldquo;esquecer&rdquo;)<br>• Preservação completa do contexto de erro<br>• Fluxo de execução previsível<br>• Facilita testes unitários</td>
          <td>• Curva de aprendizado inicial<br>• Requer familiaridade com conceitos funcionais<br>• Verbosidade em casos simples<br>• Dependência de biblioteca externa (fp-ts)</td>
      </tr>
  </tbody>
</table>
<p>A abordagem com <code>Either</code> e <code>TaskEither</code> oferece o melhor equilíbrio entre segurança de tipos, composição e manutenibilidade para sistemas complexos, embora exija um investimento inicial em aprendizado dos conceitos de programação funcional.</p>
<h3 id="taskeither-computação-assíncrona-com-tratamento-explícito-de-erros">TaskEither: Computação Assíncrona com Tratamento Explícito de Erros</h3>
<p>Um aspecto fundamental a ser compreendido sobre <code>TaskEither</code> é que ele representa uma <em>descrição</em> de uma computação assíncrona que pode falhar, não a execução imediata dessa computação. Quando você cria um <code>TaskEither</code>, está apenas definindo o que deve acontecer, sem executar nenhum código assíncrono naquele momento. Esta é uma característica poderosa da programação funcional: a separação entre a definição de uma computação e sua execução.</p>
<p>Formalmente, um <code>TaskEither&lt;E, A&gt;</code> é definido como <code>() =&gt; Promise&lt;E.Either&lt;E, A&gt;&gt;</code> - uma função que retorna uma Promise que resolverá para um <code>E.Either&lt;E, A&gt;</code>. Esta definição torna explícito que <code>TaskEither</code> é lazy: a computação só é executada quando a função é chamada.</p>
<p>Esta separação oferece benefícios significativos. Primeiro, permite compor operações complexas de forma declarativa, construindo um pipeline de transformações antes de qualquer execução. Segundo, facilita o teste unitário, já que você pode inspecionar e manipular a descrição da computação sem disparar efeitos colaterais. Terceiro, proporciona otimizações como <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation (avaliação preguiçosa)</a>, onde computações são executadas apenas quando realmente necessárias.</p>
<p>A execução real só ocorre no que chamamos de &ldquo;fim do mundo&rdquo; - o momento em que você efetivamente precisa do resultado ou do efeito colateral. Isso acontece em duas etapas: primeiro, quando usamos <code>matchE</code> (ou outros combinadores finais como <code>getOrElseEW</code>) para &ldquo;consumir&rdquo; o <code>TaskEither</code> e transformá-lo em uma <code>Task</code> (que é essencialmente uma função <code>() =&gt; Promise&lt;A&gt;</code>); e depois, quando chamamos <code>await programa()</code> para executar essa <code>Task</code> e obter o resultado final. Este modelo de execução adiada dá ao desenvolvedor controle preciso sobre quando e como os efeitos ocorrem, tornando o código mais previsível e facilitando o raciocínio sobre o fluxo de dados, especialmente em aplicações complexas com múltiplas operações assíncronas interdependentes.</p>
<h2 id="taskoption-quando-a-ausência-é-esperada">TaskOption: Quando a Ausência é Esperada</h2>
<p>Além do <code>TaskEither</code>, o fp-ts oferece <code>TaskOption</code> para cenários onde a ausência de valor é um resultado esperado em operações assíncronas. Diferente do <code>TaskEither</code>, que modela falhas como erros, o <code>TaskOption</code> é ideal quando &ldquo;não encontrado&rdquo; é um estado válido da aplicação.</p>


  <pre><code class="language-typescript">import * as TO from &#39;fp-ts/TaskOption&#39;;

// Buscar usuário que pode não existir
const buscarUsuarioOpcional = (id: number): TO.TaskOption&lt;UserData&gt; =&gt;
  TO.tryCatch(async () =&gt; {
    const response = await fetch(`/api/users/${id}`);
    if (response.status === 404) {
      return TO.none; // Usuário não encontrado - estado válido
    }
    if (!response.ok) {
      throw new Error(`Erro de rede: ${response.status}`);
    }
    return TO.some(await response.json());
  }, (e: unknown) =&gt; new Error(String(e)));

// Uso: a ausência é tratada como um caso normal
const programa = pipe(
  buscarUsuarioOpcional(123),
  TO.match(
    () =&gt; console.log(&#34;Usuário não encontrado&#34;), // Caso normal
    (user) =&gt; console.log(`Usuário: ${user.name}`)
  )
);</code></pre>
 <p>Use <code>TaskOption</code> quando a ausência de valor é um resultado esperado (como buscas que podem não retornar resultados), e <code>TaskEither</code> quando a ausência representa uma falha real da operação.</p>
<h2 id="interoperabilidade-com-promises">Interoperabilidade com Promises</h2>
<p>O fp-ts 3.x oferece funções especializadas para interoperar com código baseado em Promises existente. Em vez de usar <code>tryCatch</code> manualmente para envolver funções que já retornam <code>Promise</code>, prefira <code>tryCatchK</code> ou <code>fromPromise</code>:</p>


  <pre><code class="language-typescript">import * as TE from &#39;fp-ts/TaskEither&#39;;

// ❌ Evite: tryCatch manual para funções que já retornam Promise
const fetchUserManual = (id: number): TE.TaskEither&lt;Error, UserData&gt; =&gt;
  TE.tryCatch(
    () =&gt; fetchUserPromise(id), // Função que já retorna Promise&lt;UserData&gt;
    (e) =&gt; new Error(String(e))
  );

// ✅ Prefira: tryCatchK para funções que já retornam Promise
const fetchUserK = (id: number): TE.TaskEither&lt;Error, UserData&gt; =&gt;
  TE.tryCatchK(
    fetchUserPromise, // Passa a função diretamente
    (e: unknown) =&gt; new Error(String(e))
  )(id);

// ✅ Ou use fromPromise para conversão direta
const fetchUserFromPromise = (id: number): TE.TaskEither&lt;Error, UserData&gt; =&gt;
  TE.fromPromise(
    fetchUserPromise(id),
    (e: unknown) =&gt; new Error(String(e))
  );</code></pre>
 <p>Estas funções são mais idiomáticas e type-safe, especialmente quando você está integrando bibliotecas existentes que já trabalham com Promises.</p>
<blockquote>
<p><strong>Nota:</strong> A abordagem lazy evaluation é uma técnica que adia a execução de uma computação até que seu resultado seja realmente necessário. Em outras palavras, a computação não é executada imediatamente, mas apenas quando realmente precisamos do resultado. Isso pode ser benéfico em situações onde a computação é cara (em termos de tempo ou recursos) e não é necessária imediatamente.</p></blockquote>
<p>Um dos benefícios mais profundos de <code>Either</code> e <code>TaskEither</code> é como eles tornam os efeitos colaterais explícitos no sistema de tipos. Em programação funcional, um &ldquo;efeito colateral&rdquo; é qualquer interação com o mundo externo: leitura/escrita de arquivos, chamadas de rede, acesso a banco de dados, ou qualquer operação que possa falhar por razões fora do controle do programa.</p>
<p>Tradicionalmente, esses efeitos são &ldquo;invisíveis&rdquo; na assinatura das funções em TypeScript/JavaScript. Uma função que faz uma chamada HTTP não indica isso em seu tipo de retorno, e as exceções que podem ocorrer não são capturadas pelo sistema de tipos. Isso cria um &ldquo;vazamento&rdquo; onde efeitos potencialmente perigosos escapam da análise estática.</p>
<h2 id="compondo-múltiplas-requisições-assíncronas">Compondo Múltiplas Requisições Assíncronas</h2>
<p>O <code>fp-ts</code> brilha na composição. Se precisarmos de dados de múltiplas fontes, podemos encadear operações de forma elegante e segura, como demonstrado nos exemplos acima. Por fim, a biblioteca fp-ts oferece uma abordagem robusta para lidar com erros em TypeScript, transformando o tratamento de exceções tradicional em um fluxo de dados previsível e tipado.</p>
<p>Ao adotar esses padrões funcionais, conseguimos criar código mais confiável, testável e manutenível, onde os erros são tratados como cidadãos de primeira classe em vez de casos excepcionais. Essa mudança de paradigma não apenas melhora a qualidade do código, mas também proporciona uma experiência de desenvolvimento mais agradável, onde a composição de operações complexas se torna natural e o sistema de tipos trabalha a nosso favor para garantir que todos os casos de erro sejam devidamente considerados.</p>
<p>Vamos ver um exemplo prático de como usar <code>TaskEither</code> para buscar um post e depois seus comentários:</p>


  <pre><code class="language-typescript">import * as TE from &#39;fp-ts/TaskEither&#39;;
import * as A from &#39;fp-ts/Array&#39;;
// pipe já importado de &#39;fp-ts/function&#39;

// Suponha que fetchPost retorne TaskEither&lt;NetworkError, PostData&gt;
// e fetchComments retorne TaskEither&lt;NetworkError, CommentData[]&gt; para um postId

// Exemplo fictício:
interface PostData { id: number; title: string; userId: number; }
interface CommentData { id: number; body: string; postId: number; }

const fetchPost = (postId: number): TE.TaskEither&lt;NetworkError, PostData&gt; =&gt;
  TE.tryCatch(
    async () =&gt; {
      const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`);
      if (!res.ok) throw new NetworkError(`Post não encontrado: ${res.status}`, res.status);
      return res.json();
    },
    (r: unknown): NetworkError =&gt; new NetworkError(String(r))
  );

const fetchCommentsForPost = (postId: number): TE.TaskEither&lt;NetworkError, CommentData[]&gt; =&gt;
  TE.tryCatch(
    async () =&gt; {
      const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${postId}/comments`);
      if (!res.ok) throw new NetworkError(`Comentários não encontrados: ${res.status}`, res.status);
      return res.json();
    },
    (r: unknown): NetworkError =&gt; new NetworkError(String(r))
  );


// Objetivo: buscar um post e depois seus comentários
const getPostWithComments = (postId: number): TE.TaskEither&lt;NetworkError, { post: PostData; comments: CommentData[] }&gt; =&gt;
  pipe(
    fetchPost(postId), // TaskEither&lt;NetworkError, PostData&gt;
    TE.chain(post =&gt; // Se fetchPost deu certo, &#39;post&#39; é PostData
      pipe(
        fetchCommentsForPost(post.id), // TaskEither&lt;NetworkError, CommentData[]&gt;
        TE.map(comments =&gt; ({ post, comments })) // Se fetchComments deu certo, combina os resultados
      )
    )
  );

// Para buscar vários posts e seus comentários em paralelo (cuidado com limites de API):
const getUserIds = [1, 2, 3]; // IDs de posts, por exemplo

// Criamos um array de TaskEithers, cada um buscando um usuário
const fetchAllUsersPrograms: Array&lt;TE.TaskEither&lt;NetworkError, UserData&gt;&gt; = getUserIds.map(fetchUser);

// TE.sequenceArray transforma Array&lt;TaskEither&lt;E, A&gt;&gt; em TaskEither&lt;E, Array&lt;A&gt;&gt;
// Ele executa todas as Tasks em paralelo. Se qualquer uma falhar, o resultado é o primeiro Left.
// ⚠️ Importante: sequenceArray só funciona com tipos homogêneos (todos retornam o mesmo tipo A).
// Se os tipos de retorno diferem, use sequenceT ou mapeie para uma união A | B.
// Nota: Em fp-ts 3.x, sequenceArray pode requerer import específico
const allUsersProgram: TE.TaskEither&lt;NetworkError, UserData[]&gt; = pipe(
  fetchAllUsersPrograms,
  TE.sequenceArray
);

async function processarUsuarios() {
  const resultado = await pipe(
    allUsersProgram,
    TE.map(users =&gt; users.map(u =&gt; u.name)), // Extrai apenas os nomes se tudo der certo
    TE.matchE(
      (erro) =&gt; async () =&gt; `Falha ao buscar usuários: ${erro.message}`,
      (nomes) =&gt; async () =&gt; `Nomes dos usuários: ${nomes.join(&#39;, &#39;)}`
    )
  )(); // Executa e obtém a string final
  console.log(resultado);
}

// processarUsuarios();</code></pre>
 <p>Note que o <code>TE.sequenceArray</code> (e seu análogo <code>A.sequence(TE.ApplicativePar)</code>) é poderoso para paralelizar operações falíveis. Adotar <code>Either</code>, <code>Option</code> e <code>TaskEither</code> traz benefícios significativos como type safety explícito e previsibilidade. O compilador se torna seu aliado, forçando você a lidar com todos os caminhos possíveis, enquanto as falhas são tratadas como valores esperados no fluxo de dados, eliminando surpresas como <code>Uncaught Error</code> que interrompem sua aplicação.</p>
<p>A adoção desses tipos funcionais resulta em código mais limpo e declarativo, reduzindo drasticamente a necessidade de <code>try/catch</code> aninhados e condicionais. O fluxo de dados se torna mais claro com operações como <code>pipe</code>, <code>map</code> e <code>chain</code>, enquanto funções que retornam <code>Either</code> ou <code>TaskEither</code> podem ser encadeadas de forma segura e elegante, com propagação automática de erros que simplifica lógicas complexas.</p>
<p>Além disso, a manutenção e evolução do código se tornam mais robustas, pois alterar ou adicionar etapas em um fluxo de processamento é mais seguro quando o sistema de tipos garanta que todos os casos de erro sejam considerados. A testabilidade também é aprimorada, já que funções puras que retornam <code>Either</code> são mais fáceis de testar unitariamente por não dependerem de mecanismos de exceção globais, contribuindo para uma base de código mais confiável e sustentável.</p>
<h2 id="trade-offs">Trade-offs</h2>
<p>Embora as abstrações funcionais como <code>Either</code> e <code>TaskEither</code> ofereçam benefícios significativos para o tratamento de erros, é importante considerar alguns trade-offs, especialmente em relação à performance:</p>
<ul>
<li>
<p><strong>Overhead de Alocação:</strong> cada <code>Either</code>, <code>TaskEither</code> ou <code>Option</code> cria estruturas de dados adicionais na memória. Em <a href="https://en.wikipedia.org/wiki/Hot_path">hot paths</a> de aplicações que processam grandes volumes de dados, esse overhead de alocação pode se tornar perceptível. Comparado com abordagens mais diretas como verificações de <code>null</code> ou <code>try/catch</code>, há um custo adicional de memória.</p>
</li>
<li>
<p><strong>Micro-overhead em Operações Assíncronas:</strong> Benchmarks mostram que <code>TaskEither</code> adiciona aproximadamente <strong>3-5 µs por operação</strong> em comparação com Promises nativas. Este overhead é geralmente insignificante para a maioria das aplicações (uma operação de rede típica leva 50-200ms), mas pode ser relevante em sistemas com milhares de operações por segundo ou requisitos extremos de baixa latência.</p>
</li>
<li>
<p><strong>Curva de Aprendizado:</strong> a programação funcional e seus tipos algebráicos têm uma curva de aprendizado significativa para equipes acostumadas com paradigmas imperativos. Isso pode reduzir temporariamente a produtividade até que a equipe esteja confortável com conceitos como functors, monads e composição de funções.</p>
</li>
<li>
<p><strong>Pilha de Chamadas e Debugging:</strong> em cadeias longas de operações com <code>pipe</code> e <code>chain</code>, os stacktraces podem se tornar mais difíceis de interpretar quando ocorrem erros. Isso pode complicar o debugging em comparação com código imperativo mais direto. Para mitigar esse problema, é recomendável usar <code>mapError</code> ou <code>bimap</code> para enriquecer erros com contexto adicional em pontos estratégicos da cadeia.</p>
</li>
<li>
<p><strong>Tamanho do Bundle:</strong> a inclusão da biblioteca <code>fp-ts</code> adiciona peso ao bundle final da aplicação. Embora técnicas de <a href="https://en.wikipedia.org/wiki/Tree_shaking">tree-shaking</a> possam mitigar isso, aplicações que priorizam tamanho mínimo de bundle (como PWAs ou aplicações móveis) precisam considerar esse impacto.</p>
</li>
</ul>
<hr>
<h2 id="referências">Referências</h2>
<ul>
<li><a href="https://github.com/gcanti/fp-ts">fp-ts</a> - Documentação oficial</li>
<li><a href="https://a.co/d/3LxV0CO">Hands-On Functional Programming with Typescript</a> - Livro do Remo H. Jansen publicado pela Packt. O livro aborda conceitos fundamentais para o tratamento funcional de erros, discutindo na seção &ldquo;side-effects&rdquo; como podemos usar técnicas de programação funcional para tornar explícitos os efeitos colaterais em TypeScript.</li>
</ul>

    </div>
    
    


<div class="post-comments">
    <h3>Comentários</h3>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = 'https:\/\/scovl.github.io\/2025\/05\/12\/tserr\/';
            this.page.identifier = '\/2025\/05\/12\/tserr\/';
            this.page.title = 'Tratamento Funcional de Erros em TypeScript';
        };
        (function() {
            var d = document, s = d.createElement('script');
            s.src = 'https://lobocode.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Por favor, habilite JavaScript para ver os comentários do <a href="https://disqus.com/?ref_noscript">Disqus</a>.</noscript>
</div>
 
</article>

        </div>
    </main>
    
    
    
    <footer class="footer">
    <div class="container">
        <div class="footer-content">
            <div class="footer-links">
                
                <a href="https://github.com/scovl" target="_blank" rel="noopener noreferrer" class="footer-link">
                    GitHub
                </a>
                
                
                
                <a href="https://linkedin.com/in/vitor-lobo" target="_blank" rel="noopener noreferrer" class="footer-link">
                    LinkedIn
                </a>
                
                
                
                <a href="mailto:lobocode@gmail.com" class="footer-link">
                    Email
                </a>
                

                
                <a href="https://hachyderm.io/@lobocode" target="_blank" rel="noopener noreferrer" class="footer-link">
                    Mastodon
                </a>
                

                
                <a href="https://scovl.github.io/index.xml" target="_blank" rel="noopener noreferrer" class="footer-link">
                    RSS
                </a>
                
            </div>
            
            <div class="copyright">
                &copy; 2025 Vitor Lobo
            </div>
        </div>
    </div>
</footer> 
    
    
    
    <script src="/js/main-minimal.js"></script>
    
    
    
</body>
</html> 