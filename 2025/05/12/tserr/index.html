<!DOCTYPE html>
<html lang="pt">
<head>
    <title>Tratamento Funcional de Erros em TypeScript | scovl</title>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Usando fp-ts para gerenciar erros de forma robusta e tipada">



<link rel="preload" href="/vendor/fonts/inter/Inter-400.ttf" as="font" type="font/ttf" crossorigin>
<link rel="preload" href="/vendor/fonts/inter/Inter-600.ttf" as="font" type="font/ttf" crossorigin>
<link rel="preload" href="/vendor/fonts/jetbrains-mono/JetBrainsMono-400.ttf" as="font" type="font/ttf" crossorigin>



<link rel="dns-prefetch" href="//giscus.app">
<link rel="preconnect" href="//giscus.app">



<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="format-detection" content="telephone=no"> 


<link rel="stylesheet" href="/css/main.css?v=1758736084">


<link rel="stylesheet" href="/vendor/fonts/fonts.css?v=1758736084">


<link rel="preload" href="/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin>


<link rel="stylesheet" href="/vendor/prism/prism-tomorrow.min.css?v=1758736084">



<script src="/vendor/mermaid/mermaid.min.js?v=1758736084"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        mermaid.initialize({
            startOnLoad: true,
            theme: 'light',
            align: 'center'
        });SS
    });
</script>












<script>

const I18n = {
    currentLang: 'pt',
    isRTL:  false ,
    
    
    formatDate(date, options = {}) {
        const defaultOptions = {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        };
        
        const locale = this.getLocale();
        const finalOptions = { ...defaultOptions, ...options };
        
        return new Intl.DateTimeFormat(locale, finalOptions).format(date);
    },
    
    
    formatNumber(number, options = {}) {
        const defaultOptions = {
            style: 'decimal',
            minimumFractionDigits: 0,
            maximumFractionDigits: 2
        };
        
        const locale = this.getLocale();
        const finalOptions = { ...defaultOptions, ...options };
        
        return new Intl.NumberFormat(locale, finalOptions).format(number);
    },
    
    
    formatCurrency(amount, currency = 'USD') {
        const locale = this.getLocale();
        return new Intl.NumberFormat(locale, {
            style: 'currency',
            currency: currency
        }).format(amount);
    },
    
    
    formatRelativeTime(date) {
        const locale = this.getLocale();
        const now = new Date();
        const diff = now - date;
        const diffInMinutes = Math.floor(diff / (1000 * 60));
        const diffInHours = Math.floor(diff / (1000 * 60 * 60));
        const diffInDays = Math.floor(diff / (1000 * 60 * 60 * 24));
        
        if (diffInMinutes < 1) {
            return new Intl.RelativeTimeFormat(locale).format(0, 'minute');
        } else if (diffInMinutes < 60) {
            return new Intl.RelativeTimeFormat(locale).format(-diffInMinutes, 'minute');
        } else if (diffInHours < 24) {
            return new Intl.RelativeTimeFormat(locale).format(-diffInHours, 'hour');
        } else {
            return new Intl.RelativeTimeFormat(locale).format(-diffInDays, 'day');
        }
    },
    
    
    getLocale() {
        const localeMap = {
            'en': 'en-US',
            'pt': 'pt-BR',
            'es': 'es-ES',
            'fr': 'fr-FR',
            'de': 'de-DE',
            'it': 'it-IT',
            'ar': 'ar-SA',
            'he': 'he-IL',
            'fa': 'fa-IR',
            'ur': 'ur-PK',
            'zh': 'zh-CN',
            'ja': 'ja-JP',
            'ko': 'ko-KR'
        };
        
        return localeMap[this.currentLang] || 'en-US';
    },
    
    
    t(key, params = {}) {
        const translations = {
            'en': {
                'read_more': 'Read more',
                'back_to_top': 'Back to top',
                'loading': 'Loading...',
                'error': 'Error',
                'success': 'Success',
                'warning': 'Warning',
                'info': 'Information',
                'comments': 'Comments',
                'related_posts': 'Related Posts',
                'tags': 'Tags',
                'categories': 'Categories',
                'search': 'Search',
                'menu': 'Menu',
                'close': 'Close',
                'language': 'Language',
                'theme': 'Theme',
                'dark_mode': 'Dark Mode',
                'light_mode': 'Light Mode'
            },
            'pt': {
                'read_more': 'Ler mais',
                'back_to_top': 'Voltar ao topo',
                'loading': 'Carregando...',
                'error': 'Erro',
                'success': 'Sucesso',
                'warning': 'Aviso',
                'info': 'Informa√ß√£o',
                'comments': 'Coment√°rios',
                'related_posts': 'Posts Relacionados',
                'tags': 'Tags',
                'categories': 'Categorias',
                'search': 'Pesquisar',
                'menu': 'Menu',
                'close': 'Fechar',
                'language': 'Idioma',
                'theme': 'Tema',
                'dark_mode': 'Modo Escuro',
                'light_mode': 'Modo Claro'
            },
            'es': {
                'read_more': 'Leer m√°s',
                'back_to_top': 'Volver arriba',
                'loading': 'Cargando...',
                'error': 'Error',
                'success': '√âxito',
                'warning': 'Advertencia',
                'info': 'Informaci√≥n',
                'comments': 'Comentarios',
                'related_posts': 'Posts Relacionados',
                'tags': 'Etiquetas',
                'categories': 'Categor√≠as',
                'search': 'Buscar',
                'menu': 'Men√∫',
                'close': 'Cerrar',
                'language': 'Idioma',
                'theme': 'Tema',
                'dark_mode': 'Modo Oscuro',
                'light_mode': 'Modo Claro'
            },
            'ar': {
                'read_more': 'ÿßŸÇÿ±ÿ£ ÿßŸÑŸÖÿ≤ŸäÿØ',
                'back_to_top': 'ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ£ÿπŸÑŸâ',
                'loading': 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...',
                'error': 'ÿÆÿ∑ÿ£',
                'success': 'ŸÜÿ¨ÿ≠',
                'warning': 'ÿ™ÿ≠ÿ∞Ÿäÿ±',
                'info': 'ŸÖÿπŸÑŸàŸÖÿßÿ™',
                'comments': 'ÿßŸÑÿ™ÿπŸÑŸäŸÇÿßÿ™',
                'related_posts': 'ÿßŸÑŸÖŸÇÿßŸÑÿßÿ™ ÿ∞ÿßÿ™ ÿßŸÑÿµŸÑÿ©',
                'tags': 'ÿßŸÑÿπŸÑÿßŸÖÿßÿ™',
                'categories': 'ÿßŸÑŸÅÿ¶ÿßÿ™',
                'search': 'ÿ®ÿ≠ÿ´',
                'menu': 'ÿßŸÑŸÇÿßÿ¶ŸÖÿ©',
                'close': 'ÿ•ÿ∫ŸÑÿßŸÇ',
                'language': 'ÿßŸÑŸÑÿ∫ÿ©',
                'theme': 'ÿßŸÑŸÖÿ∏Ÿáÿ±',
                'dark_mode': 'ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÖÿ∏ŸÑŸÖ',
                'light_mode': 'ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÅÿßÿ™ÿ≠'
            }
        };
        
        const langTranslations = translations[this.currentLang] || translations['en'];
        let text = langTranslations[key] || key;
        
        
        Object.keys(params).forEach(param => {
            text = text.replace(`{${param}}`, params[param]);
        });
        
        return text;
    },
    
    
    init() {
        this.updatePageDirection();
        this.updateDateFormats();
        this.updateNumberFormats();
        this.updateTranslations();
    },
    
    
    updatePageDirection() {
        if (this.isRTL) {
            document.documentElement.setAttribute('dir', 'rtl');
            document.documentElement.setAttribute('lang', this.currentLang);
        }
    },
    
    
    updateDateFormats() {
        const dateElements = document.querySelectorAll('[data-date]');
        dateElements.forEach(element => {
            const date = new Date(element.getAttribute('data-date'));
            const format = element.getAttribute('data-date-format') || 'default';
            
            let formattedDate;
            switch (format) {
                case 'relative':
                    formattedDate = this.formatRelativeTime(date);
                    break;
                case 'short':
                    formattedDate = this.formatDate(date, { month: 'short', day: 'numeric' });
                    break;
                case 'long':
                    formattedDate = this.formatDate(date, { 
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    break;
                default:
                    formattedDate = this.formatDate(date);
            }
            
            element.textContent = formattedDate;
        });
    },
    
    
    updateNumberFormats() {
        const numberElements = document.querySelectorAll('[data-number]');
        numberElements.forEach(element => {
            const number = parseFloat(element.getAttribute('data-number'));
            const format = element.getAttribute('data-number-format') || 'decimal';
            
            let formattedNumber;
            switch (format) {
                case 'currency':
                    const currency = element.getAttribute('data-currency') || 'USD';
                    formattedNumber = this.formatCurrency(number, currency);
                    break;
                case 'percent':
                    formattedNumber = this.formatNumber(number / 100, { style: 'percent' });
                    break;
                default:
                    formattedNumber = this.formatNumber(number);
            }
            
            element.textContent = formattedNumber;
        });
    },
    
    
    updateTranslations() {
        const translationElements = document.querySelectorAll('[data-i18n]');
        translationElements.forEach(element => {
            const key = element.getAttribute('data-i18n');
            const params = {};
            
            
            const paramAttributes = element.getAttribute('data-i18n-params');
            if (paramAttributes) {
                try {
                    Object.assign(params, JSON.parse(paramAttributes));
                } catch (e) {
                    console.warn('Invalid i18n params:', paramAttributes);
                }
            }
            
            element.textContent = this.t(key, params);
        });
    }
};


window.I18n = I18n;
</script>


<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('\/sw.js')
                .then(function(registration) {
                    console.log('Service Worker registrado com sucesso:', registration.scope);
                })
                .catch(function(error) {
                    console.log('Falha no registro do Service Worker:', error);
                });
        });
    }
</script> 
</head>
<body>
    
    
    <header class="header">
    <div class="container">
        <div class="header-content">
            <a href="https://scovl.github.io/" class="site-title">scovl</a>
            
            <div class="header-actions">
                
                <nav class="nav-menu">
                    <ul>
                        
                        <li><a href="/page/about/">About</a></li>
                        
                        <li><a href="/page/contact/">Contact</a></li>
                        
                        <li><a href="/page/books/">Books</a></li>
                        
                    </ul>
                </nav>
                
                
                



<div class="language-switcher" id="language-switcher">
    <button class="language-btn" onclick="toggleLanguageMenu()">
        <span class="current-lang">Portugu√™s</span>
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6,9 12,15 18,9"></polyline>
        </svg>
    </button>
    <div class="language-menu" id="language-menu">
        
            
                <a href="https://scovl.github.io/" class="language-option active">
                    Portugu√™s
                </a>
            
        
            
                <a href="https://scovl.github.io/en/" class="language-option ">
                    English
                </a>
            
        
    </div>
</div>
                
                
                <button id="dark-mode-toggle" class="theme-toggle" aria-label="Toggle dark mode">
                    <svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
</header> 
    
    
    
    <main>
        <div class="container">
            
<article class="post">
    <header class="post-header">
        <h1 class="post-title">Tratamento Funcional de Erros em TypeScript</h1>
        
        <div class="post-meta">
            <time datetime="2025-05-12T18:31:45-03:00">
                üìÖ 12/05/2025
            </time>
            
            <span>üë§ Vitor Lobo Ramos</span>
            
            
            
            <div class="post-tags">
                
                <a href="/tags/javascript" class="tag">javascript</a>
                
                <a href="/tags/typescript" class="tag">typescript</a>
                
                <a href="/tags/fp-ts" class="tag">fp-ts</a>
                
                <a href="/tags/programa%C3%A7%C3%A3o-funcional" class="tag">programa√ß√£o funcional</a>
                
                <a href="/tags/tratamento-de-erros" class="tag">tratamento de erros</a>
                
                <a href="/tags/desenvolvimento" class="tag">desenvolvimento</a>
                
            </div>
            
        </div>
        
    </header>
    
    
    















  

  

  

  

  

  

  

  

  

  

  

  

  

  



<aside class="toc" id="toc" aria-labelledby="toc-title">
    <div class="toc-container">
        <div class="toc-header">
            <h3 id="toc-title" class="toc-title">
                <svg class="toc-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18M3 12h18M3 18h18"/>
                </svg>
                Sum√°rio
            </h3>
            <button class="toc-toggle" id="toc-toggle" aria-expanded="true" aria-controls="toc-content" aria-label="Mostrar/Ocultar Sum√°rio">
                <svg class="toc-toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="m6 9 6 6 6-6"/>
                </svg>
            </button>
        </div>
        <div class="toc-content" id="toc-content">
            <div class="toc-progress">
                <div class="toc-progress-bar" id="toc-progress-bar"></div>
            </div>
            <nav class="toc-nav">
                <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#o-dilema-do-tratamento-de-erros-convencional">O Dilema do Tratamento de Erros Convencional</a></li>
        <li><a href="#erros-como-cidad√£os-de-primeira-classe">Erros Como Cidad√£os de Primeira Classe</a></li>
        <li><a href="#sucesso-expl√≠cito-ou-falha-detalhada">Sucesso Expl√≠cito ou Falha Detalhada</a></li>
        <li><a href="#propriedades-avan√ßadas-do-either">Propriedades Avan√ßadas do Either</a></li>
        <li><a href="#usando-match-para-extrair-valores-de-either">Usando <code>match</code> para Extrair Valores de <code>Either</code></a></li>
        <li><a href="#usando-map-para-transformar-o-valor-de-sucesso">Usando <code>map</code> para Transformar o Valor de Sucesso</a></li>
        <li><a href="#usando-chain-para-encadear-opera√ß√µes-fal√≠veis">Usando <code>chain</code> para Encadear Opera√ß√µes Fal√≠veis</a></li>
        <li><a href="#usando-taskeithere-a-o-poder-de-either-no-mundo-ass√≠ncrono">Usando <code>TaskEither&lt;E, A&gt;</code>: O Poder de <code>Either</code> no Mundo Ass√≠ncrono</a>
          <ul>
            <li><a href="#taskeither-computa√ß√£o-ass√≠ncrona-com-tratamento-expl√≠cito-de-erros">TaskEither: Computa√ß√£o Ass√≠ncrona com Tratamento Expl√≠cito de Erros</a></li>
          </ul>
        </li>
        <li><a href="#taskoption-quando-a-aus√™ncia-√©-esperada">TaskOption: Quando a Aus√™ncia √© Esperada</a></li>
        <li><a href="#interoperabilidade-com-promises">Interoperabilidade com Promises</a></li>
        <li><a href="#compondo-m√∫ltiplas-requisi√ß√µes-ass√≠ncronas">Compondo M√∫ltiplas Requisi√ß√µes Ass√≠ncronas</a></li>
        <li><a href="#trade-offs">Trade-offs</a></li>
        <li><a href="#refer√™ncias">Refer√™ncias</a></li>
      </ul>
    </li>
  </ul>
</nav>
            </nav>
        </div>
    </div>
    
    
    <button class="toc-mobile-toggle" id="toc-mobile-toggle" aria-label="Mostrar Sum√°rio">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 6h18M3 12h18M3 18h18"/>
        </svg>
    </button>
</aside>



    
    <div class="post-content">
        <p>Neste artigo, vamos explorar uma abordagem mais estruturada para o tratamento de erros em TypeScript usando conceitos de programa√ß√£o funcional. A biblioteca <a href="https://gcanti.github.io/fp-ts/">fp-ts</a> (Functional Programming em TypeScript) oferece ferramentas que permitem lidar com falhas de forma expl√≠cita e type-safe, melhorando a robustez e legibilidade do c√≥digo. Existem tamb√©m outras bibliotecas com abordagens semelhantes ou complementares no ecossistema TypeScript:</p>
<ul>
<li><a href="https://github.com/purify-ts/purify-ts"><strong>Purify-ts</strong></a>: Uma alternativa mais leve ao fp-ts, focada em tipos como Maybe e Either</li>
<li><a href="https://github.com/microsoft/neverthrow"><strong>Neverthrow</strong></a>: Biblioteca especializada em tratamento de erros com Result/Either</li>
<li><a href="https://effect.website/"><strong>Effect</strong></a>: O sucessor oficial e linha evolutiva do ecossistema fp-ts, oferecendo uma abordagem mais moderna para programa√ß√£o funcional com foco em concorr√™ncia, streaming e gerenciamento de recursos</li>
<li><a href="https://github.com/zio/zio-ts"><strong>Zio-ts</strong></a>: Inspirada na biblioteca ZIO de Scala (atualmente com desenvolvimento menos ativo)</li>
</ul>
<p>Cada uma dessas bibliotecas tem seus pontos fortes. O <a href="https://gcanti.github.io/fp-ts/">fp-ts</a> continua sendo uma escolha s√≥lida pela sua maturidade e estabilidade, enquanto o <a href="https://effect.website/">Effect</a> representa a evolu√ß√£o natural desses conceitos. Neste artigo, focaremos no fp-ts e em como ele aborda o tratamento de erros de forma funcional.</p>
<blockquote>
<p><strong>Nota sobre vers√µes:</strong> Este artigo utiliza a sintaxe atual do fp-ts 2.x (vers√£o est√°vel), que permanece a vers√£o recomendada para produ√ß√£o. A vers√£o 3.x ainda est√° em fase pr√©-release/alpha. Para acompanhar a evolu√ß√£o da biblioteca, consulte a documenta√ß√£o oficial em <a href="https://github.com/gcanti/fp-ts">https://github.com/gcanti/fp-ts</a>.</p></blockquote>
<hr>
<h2 id="o-dilema-do-tratamento-de-erros-convencional">O Dilema do Tratamento de Erros Convencional</h2>
<p>No ecossistema JavaScript/TypeScript, historicamente, recorremos a duas abordagens principais para lidar com erros, cada uma com suas armadilhas. A forma mais comum de sinalizar e capturar erros √© atrav√©s de exce√ß√µes, usando <code>throw</code> e <code>try/catch</code>. Por√©m, essa abordagem tem alguns problemas:</p>


  <pre><code class="language-typescript">function dividirLegado(a: number, b: number): number {
  if (b === 0) {
    throw new Error(&#34;Divis√£o por zero n√£o √© permitida!&#34;);
  }
  return a / b;
}

try {
  const resultado = dividirLegado(10, 0);
  console.log(&#34;Resultado:&#34;, resultado);
} catch (error: any) { // Note o &#39;any&#39;, um ponto fraco comum
  console.error(&#34;Ops, algo deu errado:&#34;, error.message);
  // Sa√≠da: &#34;Ops, algo deu errado: Divis√£o por zero n√£o √© permitida!&#34;
}</code></pre>
 <blockquote>
<p><strong>Nota:</strong> O uso de <code>any</code> para o tipo do erro √© uma pr√°tica comum, mas n√£o √© a melhor op√ß√£o. Em um sistema mais complexo, isso pode levar a erros de tipo que s√£o dif√≠ceis de detectar.</p></blockquote>
<p>O uso de exce√ß√µes apresenta s√©rios problemas de design: a assinatura da fun√ß√£o <code>dividirLegado</code> n√£o revela ao compilador a possibilidade de exce√ß√µes, criando um contrato impl√≠cito onde o chamador precisa adivinhar a necessidade de um <code>try/catch</code>.</p>
<p>Al√©m disso, o <code>throw</code> interrompe abruptamente o fluxo de execu√ß√£o, dificultando o rastreamento e comprometendo a pureza funcional, enquanto a facilidade de esquecer blocos <code>try/catch</code> pode resultar em erros n√£o capturados que derrubam aplica√ß√µes inteiras. Uma alternativa comum √© retornar valores especiais como <code>null</code>, <code>undefined</code> ou objetos de erro para sinalizar falhas, embora essa abordagem tamb√©m apresente suas pr√≥prias limita√ß√µes. Por exemplo:</p>


  <pre><code class="language-typescript">interface ResultadoDivisao {
  valor?: number;
  erro?: string;
}

function dividirComObjeto(a: number, b: number): ResultadoDivisao {
  if (b === 0) {
    return { erro: &#34;Divis√£o por zero!&#34; };
  }
  return { valor: a / b };
}

const resultadoObj = dividirComObjeto(10, 0);
if (resultadoObj.erro) {
  console.error(&#34;Falha:&#34;, resultadoObj.erro);
} else {
  console.log(&#34;Sucesso:&#34;, resultadoObj.valor);
}

// Ou com null:
function dividirComNull(a: number, b: number): number | null {
    if (b === 0) return null;
    return a / b;
}
const resultadoNull = dividirComNull(10, 0);
if (resultadoNull === null) console.error(&#34;Divis√£o por zero!&#34;);</code></pre>
 <p>Essa abordagem infelizmente tamb√©m apresenta problemas significativos de usabilidade e seguran√ßa. O c√≥digo se torna verboso e menos leg√≠vel devido √†s constantes verifica√ß√µes manuais como <code>if (resultado.erro)</code> ou <code>if (resultado === null)</code>, enquanto a perda de contexto √© inevit√°vel, especialmente com valores <code>null</code> que n√£o informam o motivo da falha - mesmo objetos de erro exigem disciplina manual consistente.</p>
<p>Al√©m disso, h√° um risco constante de erros silenciosos no sistema, pois esquecer de verificar o <code>null</code> ou a propriedade <code>erro</code> pode facilmente resultar em erros do tipo <code>TypeError: Cannot read property '...' of null</code> em partes subsequentes do c√≥digo, comprometendo a robustez da aplica√ß√£o como um todo.</p>
<hr>
<h2 id="erros-como-cidad√£os-de-primeira-classe">Erros Como Cidad√£os de Primeira Classe</h2>
<p>A Programa√ß√£o Funcional (FP) encara os erros de uma maneira fundamentalmente diferente: <strong>erros s√£o simplesmente valores</strong>. Em vez de lan√ßar exce√ß√µes que quebram o fluxo, as fun√ß√µes retornam tipos de dados expl√≠citos que representam tanto o sucesso quanto a falha. <code>fp-ts</code> nos fornece estruturas de dados poderosas para isso, como <code>Option</code> e <code>Either</code>. Antes de <code>Either</code>, vamos entender <code>Option</code>. Ele √© usado para representar um valor que pode ou n√£o estar presente. Pense nele como um substituto type-safe para <code>null</code> ou <code>undefined</code>.</p>
<ul>
<li><strong><code>Some&lt;A&gt;</code></strong>: Cont√©m um valor do tipo <code>A</code>.</li>
<li><strong><code>None</code></strong>: Representa a aus√™ncia de um valor.</li>
</ul>
<p>O c√≥digo abaixo mostra como usar <code>Option</code> para lidar com a aus√™ncia de valor. Vejamos:</p>


  <pre><code class="language-typescript">import * as O from &#39;fp-ts/Option&#39;;
import { pipe } from &#39;fp-ts/function&#39;;

interface User {
  id: number;
  name: string;
}
const users: User[] = [{ id: 1, name: &#34;Alice&#34; }, { id: 2, name: &#34;Bob&#34; }];

function findUserById(id: number): O.Option&lt;User&gt; {
  const user = users.find(u =&gt; u.id === id);
  return user ? O.some(user) : O.none; // Explicita a possibilidade de n√£o encontrar
}

// Usando Option
const user1 = findUserById(1); // Some({ id: 1, name: &#34;Alice&#34; })
const user3 = findUserById(3); // None

pipe(
  user1,
  O.map(user =&gt; user.name.toUpperCase()), // S√≥ executa se for Some
  O.match(
    () =&gt; console.log(&#34;Usu√°rio n√£o encontrado.&#34;), // Caso None
    (name) =&gt; console.log(&#34;Nome em mai√∫sculas:&#34;, name) // Caso Some
  )
); // Sa√≠da: Nome em mai√∫sculas: ALICE

pipe(
  user3,
  O.map(user =&gt; user.name.toUpperCase()),
  O.match(
    () =&gt; console.log(&#34;Usu√°rio n√£o encontrado.&#34;),
    (name) =&gt; console.log(&#34;Nome em mai√∫sculas:&#34;, name)
  )
); // Sa√≠da: Usu√°rio n√£o encontrado.</code></pre>
 <p>Note que <code>Option</code> √© perfeito para casos onde a aus√™ncia n√£o √© necessariamente um &ldquo;erro&rdquo;, mas um estado esperado. Ele nos permite modelar de forma elegante situa√ß√µes como buscas que podem n√£o retornar resultados, valores opcionais em formul√°rios, ou acessos a propriedades que podem n√£o existir.</p>
<p>Ao usar <code>Option</code>, tornamos expl√≠cito no sistema de tipos que um valor pode estar ausente, for√ßando o desenvolvedor a lidar com ambos os casos. Isso elimina erros comuns como refer√™ncias nulas inesperadas e torna o c√≥digo mais robusto, previs√≠vel e auto-documentado, sem a necessidade de verifica√ß√µes defensivas espalhadas pelo c√≥digo.</p>
<blockquote>
<p><strong>Nota:</strong> O uso de <code>Option</code> √© uma abordagem mais moderna e elegante para lidar com valores que podem estar ausentes. Ele √© prefer√≠vel ao uso de <code>null</code> ou <code>undefined</code> em muitos casos, pois fornece um tipo mais expl√≠cito e seguro para representar a aus√™ncia de valor.</p></blockquote>
<p>Para ilustrar ainda mais a utilidade de <code>Option</code>, especialmente em cen√°rios do mundo real, vamos considerar uma opera√ß√£o ass√≠ncrona, como buscar dados de uma API. Muitas vezes, uma API pode n√£o encontrar o recurso solicitado, e <code>Option</code> √© uma excelente forma de modelar essa possibilidade sem recorrer a <code>null</code> ou exce√ß√µes para um &ldquo;n√£o encontrado&rdquo; esperado. Imagine que estamos buscando uma not√≠cia por ID:</p>


  <pre><code class="language-typescript">interface Noticia {
  id: number;
  titulo: string;
  conteudo: string;
}

const buscarNoticia = async (id: number): Promise&lt;O.Option&lt;Noticia&gt;&gt; =&gt; {
  const noticia = await fetch(`https://api.exemplo.com/noticias/${id}`);
  if (noticia.status === 404) {
    return O.none;
  }
  return O.some(await noticia.json());
}

const noticia = await buscarNoticia(1);
pipe(
  noticia,
  O.match(
    () =&gt; console.log(&#34;Not√≠cia n√£o encontrada&#34;),
    (noticia) =&gt; console.log(noticia.titulo)
  )
);</code></pre>
 <p>Neste exemplo, <code>buscarNoticia</code> retorna um <code>Option&lt;Noticia&gt;</code>, que pode ser <code>Some</code> (com a not√≠cia encontrada) ou <code>None</code> (quando a not√≠cia n√£o √© encontrada). Isso torna o c√≥digo mais claro e seguro, pois n√£o precisamos verificar o status da resposta ou lidar com <code>null</code>/<code>undefined</code>.</p>
<h2 id="sucesso-expl√≠cito-ou-falha-detalhada">Sucesso Expl√≠cito ou Falha Detalhada</h2>
<p>J√° o <code>Either</code> √© o tipo protagonista no paradigma funcional quando precisamos modelar opera√ß√µes que podem falhar, oferecendo uma estrutura elegante que n√£o apenas sinaliza o erro, mas tamb√©m fornece detalhes espec√≠ficos sobre a falha.</p>
<p>Diferente de exce√ß√µes tradicionais que interrompem o fluxo de execu√ß√£o, <code>Either</code> encapsula tanto o sucesso quanto o erro como valores de primeira classe, permitindo composi√ß√£o e transforma√ß√£o de opera√ß√µes fal√≠veis de forma segura e previs√≠vel. Basicamente, <code>Either</code> √© uma uni√£o de dois tipos: <code>Right</code> e <code>Left</code>:</p>
<ul>
<li><strong><code>Right&lt;A&gt;</code></strong>: Representa um resultado de sucesso, contendo um valor do tipo <code>A</code>. (Pense &ldquo;Right&rdquo; como &ldquo;correto&rdquo;).</li>
<li><strong><code>Left&lt;E&gt;</code></strong>: Representa uma falha, contendo um erro do tipo <code>E</code>. (Pense &ldquo;Left&rdquo; como o que sobrou, o erro).</li>
</ul>
<p>Para ficar mais claro, veja o gr√°fico abaixo:</p>


  
    
  
  <div class="mermaid">graph TD
    A[Sucesso] --&gt; B[Right&lt;A&gt;]
    C[Falha] --&gt; D[Left&lt;E&gt;]</div>
 <p>Esta estrutura nos permite representar de forma expl√≠cita tanto o caminho feliz quanto o caminho de erro em nossas opera√ß√µes, sem recorrer a exce√ß√µes ou valores nulos. O tipo <code>Either</code> for√ßa o programador a considerar ambos os casos, tornando o c√≥digo mais robusto e previs√≠vel. Vamos ver um exemplo pr√°tico em c√≥digo:</p>


  <pre><code class="language-typescript">import * as E from &#34;fp-ts/Either&#34;;
import { pipe } from &#34;fp-ts/function&#34;; // pipe √© essencial!

// Nosso divisor, agora funcional e type-safe!
function dividir(a: number, b: number): E.Either&lt;string, number&gt; {
  if (b === 0) {
    return E.left(&#34;Divis√£o por zero!&#34;); // Falha expl√≠cita com uma mensagem
  }
  return E.right(a / b); // Sucesso expl√≠cito com o valor
}

const resultado1 = dividir(10, 2); // Right(5)
const resultado2 = dividir(10, 0); // Left(&#34;Divis√£o por zero!&#34;)

console.log(resultado1);
console.log(resultado2);</code></pre>
 <p>O tipo de retorno <code>E.Either&lt;string, number&gt;</code> diz claramente: &ldquo;esta fun√ß√£o retorna um n√∫mero em caso de sucesso, OU uma string de erro em caso de falha.&rdquo; O compilador TypeScript agora <em>sabe</em> dos poss√≠veis resultados. Nunca acessamos diretamente <code>Left</code> ou <code>Right</code> (ou <code>Some</code>/<code>None</code>). Em vez disso, usamos fun√ß√µes de alta ordem que operam sobre esses &ldquo;containers&rdquo;. A fun√ß√£o <code>pipe</code> de <code>fp-ts/function</code> √© crucial aqui para compor essas opera√ß√µes de forma leg√≠vel.</p>
<p>A fun√ß√£o <code>pipe(valorInicial, fn1, fn2, fn3)</code> √© equivalente a <code>fn3(fn2(fn1(valorInicial)))</code>, simplificando a composi√ß√£o de fun√ß√µes. Ela recebe um valor inicial e o encaminha atrav√©s de uma sequ√™ncia de transforma√ß√µes, criando um fluxo de dados da esquerda para a direita que √© intuitivo e f√°cil de acompanhar, melhorando significativamente a legibilidade do c√≥digo em compara√ß√£o com as chamadas aninhadas tradicionais. Veja o gr√°fico abaixo:</p>


  
  <div class="mermaid">graph LR
    A[valorInicial] --&gt; B[fn1]
    B --&gt; C[fn2]
    C --&gt; D[fn3]
    
    subgraph &#34;pipe(valorInicial, fn1, fn2, fn3)&#34;
    A
    B
    C
    D
    end
    
    style A fill:#f9f9f9,stroke:#666
    style D fill:#d5f5e3,stroke:#2ecc71,stroke-width:2px</div>
 <p>O diagrama acima mostra como funciona a fun√ß√£o <code>pipe</code> de uma forma simples. Em vez de escrever c√≥digo aninhado como <code>fn3(fn2(fn1(valorInicial)))</code>, que √© dif√≠cil de ler, usamos <code>pipe(valorInicial, fn1, fn2, fn3)</code>, que √© como ler uma receita: primeiro fa√ßa isso, depois aquilo&hellip;por exemplo:</p>


  <pre><code class="language-typescript">// Sem pipe (dif√≠cil de ler):
const resultado = multiplicarPorDois(somarCinco(converterParaNumero(&#34;10&#34;)));

// Com pipe (f√°cil de seguir):
const resultado = pipe(
  &#34;10&#34;,               // Valor inicial
  converterParaNumero, // Primeira transforma√ß√£o
  somarCinco,         // Segunda transforma√ß√£o
  multiplicarPorDois  // Terceira transforma√ß√£o
);</code></pre>
 <p>Pense no <code>pipe</code> como uma linha de montagem: o valor inicial entra por um lado, passa por v√°rias esta√ß√µes de trabalho (fun√ß√µes), e sai transformado do outro lado!</p>
<h2 id="propriedades-avan√ßadas-do-either">Propriedades Avan√ßadas do Either</h2>
<p>O <code>Either</code> vai muito al√©m de ser apenas um container para sucesso ou erro - ele √© um conceito fundamental da programa√ß√£o funcional que implementa padr√µes poderosos que nos permitem compor opera√ß√µes de forma elegante e segura. Na programa√ß√£o funcional, o <code>Either</code> √© classificado como um tipo algebr√°ico que implementa interfaces importantes como <a href="https://en.wikipedia.org/wiki/Functor">Functor</a> e <a href="https://en.wikipedia.org/wiki/Monad_%28category_theory%29">Monad</a>. Vamos entender o que isso significa na pr√°tica e como isso nos ajuda a escrever c√≥digo mais robusto:</p>
<ol>
<li><strong>Functor</strong>: O <code>Either</code> √© um functor porque implementa a opera√ß√£o <code>map</code>, que permite transformar o valor dentro de um <code>Right</code> sem alterar a estrutura do container. Se for um <code>Left</code>, o erro √© simplesmente propagado sem altera√ß√£o.</li>
</ol>


  <pre><code class="language-typescript">// map transforma apenas o lado Right
const resultado = pipe(
  dividir(10, 2), // Right(5)
  E.map(valor =&gt; valor * 2) // Right(10)
);

// Se for Left, map n√£o faz nada
const resultadoErro = pipe(
  dividir(10, 0), // Left(&#34;Divis√£o por zero!&#34;)
  E.map(valor =&gt; valor * 2) // Continua Left(&#34;Divis√£o por zero!&#34;)
);</code></pre>
 <ol start="2">
<li><strong>Monad</strong>: O <code>Either</code> tamb√©m √© uma monad porque implementa a opera√ß√£o <code>chain</code> (tamb√©m chamada de <code>flatMap</code> ou <code>bind</code> em outras linguagens). Isso permite compor opera√ß√µes que tamb√©m podem falhar, evitando o aninhamento de <code>E.Either&lt;E, E.Either&lt;E, A&gt;&gt;</code>.</li>
</ol>


  <pre><code class="language-typescript">// Outra fun√ß√£o que pode falhar
const raizQuadrada = (n: number): E.Either&lt;string, number&gt; =&gt;
n &lt; 0 ? E.left(&#34;N√£o existe raiz de n√∫mero negativo&#34;) : E.right(Math.sqrt(n));

// Usando chain para compor opera√ß√µes fal√≠veis
const calcularRaizDaDivisao = (a: number, b: number) =&gt; pipe(
  dividir(a, b),        // E.Either&lt;string, number&gt;
E.chain(raizQuadrada) // E.Either&lt;string, number&gt;
);

console.log(calcularRaizDaDivisao(16, 4));  // Right(2)
console.log(calcularRaizDaDivisao(16, 0));  // Left(&#34;Divis√£o por zero!&#34;)
console.log(calcularRaizDaDivisao(-16, 4)); // Left(&#34;N√£o existe raiz de n√∫mero negativo&#34;)</code></pre>
 <p>Estas propriedades tornam o <code>Either</code> extremamente poderoso para composi√ß√£o de opera√ß√µes, permitindo criar fluxos complexos de tratamento de erros de forma elegante e type-safe. O <code>map</code> nos permite transformar valores de sucesso, enquanto o <code>chain</code> nos permite sequenciar opera√ß√µes que podem falhar, com propaga√ß√£o autom√°tica de erros.</p>
<h2 id="usando-match-para-extrair-valores-de-either">Usando <code>match</code> para Extrair Valores de <code>Either</code></h2>
<p>Agora que entendemos o conceito de <code>pipe</code>, vamos explorar a fun√ß√£o <code>match</code>, que √© fundamental para extrair valores de um <code>Either</code>. Esta fun√ß√£o permite definir duas fun√ß√µes: uma para o caso <code>Left</code> (erro) e outra para o caso <code>Right</code> (sucesso), funcionando essencialmente como um <code>if/else</code> especializado para o tipo <code>Either</code>. Com <code>match</code>, podemos transformar nosso <code>Either</code> em qualquer outro tipo, garantindo que ambos os casos sejam tratados explicitamente.</p>
<p>O <code>match</code> √© uma forma de &ldquo;pattern matching&rdquo; funcional - um conceito poderoso de linguagens funcionais que permite lidar com diferentes &ldquo;casos&rdquo; ou &ldquo;formas&rdquo; que um valor pode ter. No caso do <code>Either</code>, temos dois padr√µes poss√≠veis: <code>Left</code> e <code>Right</code>.</p>
<p>O pattern matching nos for√ßa a tratar todos os casos poss√≠veis de forma expl√≠cita, eliminando a possibilidade de esquecermos algum caminho. Isso √© especialmente valioso em TypeScript, onde o sistema de tipos garante que n√£o podemos acessar o valor interno de um <code>Either</code> sem primeiro &ldquo;desempacot√°-lo&rdquo; usando <code>match</code> ou fun√ß√µes similares. Agora que voc√™ j√° entendeu o conceito de <code>pipe</code>, vamos ver como usar <code>match</code> para extrair valores de um <code>Either</code> acompanhando o gr√°fico abaixo:</p>


  
  <div class="mermaid">graph LR
    A[Either&lt;E, A&gt;] --&gt; B{√â Right?}
    B --&gt;|Sim| C[Right&lt;A&gt;]
    B --&gt;|N√£o| D[Left&lt;E&gt;]
    C --&gt; E[fnSucesso: A ‚Üí B]
    D --&gt; F[fnErro: E ‚Üí B]
    E --&gt; G[Resultado Final: B]
    F --&gt; G

    subgraph &#34;pipe &#43; match&#34;
    A
    B
    C
    D
    E
    F
    G
    end

    style A fill:#f9f9f9,stroke:#666
    style C fill:#d5f5e3,stroke:#2ecc71
    style D fill:#ffdddd,stroke:#e74c3c
    style G fill:#d6eaf8,stroke:#3498db,stroke-width:2px</div>
 <p>O processo come√ßa com uma entrada <code>E.Either&lt;E, A&gt;</code>, que representa um valor que pode ser um sucesso (<code>Right&lt;A&gt;</code>) ou um erro (<code>Left&lt;E&gt;</code>). Quando aplicamos a fun√ß√£o <code>match</code>, ela toma uma decis√£o baseada no tipo do <code>Either</code>: se for um <code>Right</code>, aplica a fun√ß√£o de sucesso (<code>fnSucesso</code>) ao valor interno, transformando <code>A</code> em <code>B</code>; se for um <code>Left</code>, aplica a fun√ß√£o de erro (<code>fnErro</code>) ao erro interno, transformando <code>E</code> tamb√©m em <code>B</code>. O resultado final deste processo √© sempre um valor do tipo <code>B</code>, independentemente do caminho seguido.</p>
<p>Esta √© a beleza do <code>match</code>: ele unifica os dois caminhos poss√≠veis (sucesso e erro) em um √∫nico tipo de sa√≠da, permitindo que o c√≥digo subsequente trabalhe com um valor concreto sem precisar verificar constantemente se estamos lidando com um sucesso ou um erro. Vamos ver um exemplo pr√°tico em c√≥digo:</p>


  <pre><code class="language-typescript">import * as E from &#34;fp-ts/Either&#34;;
import { pipe } from &#34;fp-ts/function&#34;;

// Fun√ß√£o que pode falhar
const divide = (a: number, b: number): E.Either&lt;string, number&gt; =&gt;
  b === 0 ? E.left(&#34;Divis√£o por zero!&#34;) : E.right(a / b);

// Tratamento com match
const result = pipe(
  divide(10, 0),
  E.match(
    (error) =&gt; `Erro: ${error}`, // fnErro
    (value) =&gt; `Resultado: ${value}` // fnSucesso
  )
);

console.log(result); // &#34;Erro: Divis√£o por zero!&#34;</code></pre>
 <p>O m√©todo <code>match</code> √© particularmente √∫til quando voc√™ precisa <strong>transformar</strong> o resultado final de uma opera√ß√£o em um formato espec√≠fico, como preparar dados para exibi√ß√£o na interface do usu√°rio ou formatar mensagens para logging. Esta fun√ß√£o √© essencial para unificar os caminhos de sucesso e erro em um √∫nico tipo de retorno.</p>
<p>Al√©m disso, <code>match</code> serve como uma excelente maneira de <strong>encerrar</strong> uma cadeia de opera√ß√µes com um valor concreto, permitindo que voc√™ conclua o processamento de um <code>Either</code> e obtenha um resultado final que n√£o √© mais um tipo mon√°dico.</p>
<h2 id="usando-map-para-transformar-o-valor-de-sucesso">Usando <code>map</code> para Transformar o Valor de Sucesso</h2>
<p>Enquanto <code>match</code> nos permite encerrar uma cadeia de opera√ß√µes unificando os caminhos de sucesso e erro, muitas vezes precisamos apenas transformar o valor de sucesso sem alterar o fluxo de tratamento de erros. √â aqui que o operador <code>map</code> se torna valioso. Esta fun√ß√£o aplica uma transforma√ß√£o apenas ao valor contido em um <code>Right</code>, deixando qualquer <code>Left</code> intacto e propagando o erro original sem modifica√ß√£o. O gr√°fico abaixo mostra como funciona o <code>map</code> em um <code>Either</code>:</p>


  
  <div class="mermaid">graph LR
    A[&#34;parseNumber(&#39;42&#39;)&#34;] --&gt; B[Right&lt;42&gt;]
    B --&gt; C[map: n ‚Üí n * 2]
    C --&gt; D[Right&lt;84&gt;]
    D --&gt; E[match: exibe resultado]
    
    A2[&#34;parseNumber(&#39;abc&#39;)&#34;] --&gt; B2[Left&lt;&#39;Erro&#39;&gt;]
    B2 --&gt; C2[map: ignorado]
    C2 --&gt; D2[Left&lt;&#39;Erro&#39;&gt;]
    D2 --&gt; E2[match: exibe erro]

    subgraph &#34;Exemplo Completo&#34;
    A --&gt; E
    A2 --&gt; E2
    end

    style D fill:#d5f5e3,stroke:#2ecc71
    style D2 fill:#ffdddd,stroke:#e74c3c</div>
 <p>Vamos entender o diagrama acima: ele ilustra como o operador <code>map</code> funciona com o tipo <code>Either</code>. No caminho superior, quando <code>parseNumber('42')</code> retorna um <code>Right&lt;42&gt;</code> (sucesso), o <code>map</code> aplica a fun√ß√£o de transforma√ß√£o (multiplica√ß√£o por 2), resultando em <code>Right&lt;84&gt;</code>. No caminho inferior, quando <code>parseNumber('abc')</code> retorna um <code>Left&lt;'Erro'&gt;</code> (falha), o <code>map</code> ignora completamente a fun√ß√£o de transforma√ß√£o, propagando o erro original sem modifica√ß√£o.</p>
<p>Este comportamento √© fundamental para a programa√ß√£o funcional, pois permite transformar valores de sucesso enquanto preserva automaticamente os erros, criando um fluxo de dados seguro e previs√≠vel. Vejamos um exemplo pr√°tico de como usar <code>map</code> com <code>Either</code>:</p>


  <pre><code class="language-typescript">const resultadoDobrado = pipe(
  dividir(20, 2),         // Right(10)
  E.map(valor =&gt; valor * 2) // Aplica valor * 2 somente se for Right
); // resultadoDobrado √© Right(20)

const falhaDobrada = pipe(
  dividir(20, 0),         // Left(&#34;Divis√£o por zero!&#34;)
  E.map(valor =&gt; valor * 2) // N√£o √© executado
); // falhaDobrada √© Left(&#34;Divis√£o por zero!&#34;)</code></pre>
 <h2 id="usando-chain-para-encadear-opera√ß√µes-fal√≠veis">Usando <code>chain</code> para Encadear Opera√ß√µes Fal√≠veis</h2>
<p>Enquanto <code>map</code> √© perfeito para transforma√ß√µes simples de valores de sucesso, ele n√£o √© suficiente quando a pr√≥pria transforma√ß√£o pode falhar. √â aqui que <code>chain</code> se torna essencial. Esta fun√ß√£o permite compor opera√ß√µes sequenciais onde cada etapa depende do resultado bem-sucedido da anterior e pode, por si s√≥, produzir um erro. Diferente do <code>map</code>, que sempre envolve o resultado da transforma√ß√£o em um novo <code>Right</code>, o <code>chain</code> espera que a fun√ß√£o de transforma√ß√£o j√° retorne um <code>Either</code>, evitando o aninhamento desnecess√°rio de estruturas.</p>
<p>Na pr√°tica, <code>chain</code> √© fundamental para construir fluxos de valida√ß√£o e processamento robustos. Por exemplo, ao processar dados de usu√°rio, podemos encadear v√°rias valida√ß√µes (verificar formato de email, checar comprimento de senha, validar idade) onde cada etapa s√≥ √© executada se a anterior for bem-sucedida. Se qualquer valida√ß√£o falhar, o erro √© propagado automaticamente at√© o final da cadeia, eliminando a necessidade de verifica√ß√µes condicionais repetitivas e tornando o c√≥digo mais declarativo e menos propenso a erros. Vejamos um exemplo pr√°tico de como usar <code>chain</code> com <code>Either</code> no gr√°fico abaixo:</p>


  
  <div class="mermaid">graph TD
    A[Either&lt;E, A&gt;] --&gt; B{√â Right?}
    B --&gt;|Sim| C[Right&lt;A&gt;]
    B --&gt;|N√£o| D[Left&lt;E&gt;]
    C --&gt; E[chain: A ‚Üí Either&lt;E, B&gt;]
    D --&gt; F[Left&lt;E&gt;]
    E --&gt; G{√â Right?}
    G --&gt;|Sim| H[Right&lt;B&gt;]
    G --&gt;|N√£o| I[Left&lt;E&gt;]
    H --&gt; J[map: B ‚Üí C]
    I --&gt; K[Left&lt;E&gt;]
    J --&gt; L[Right&lt;C&gt;]
    K --&gt; M[Left&lt;E&gt;]
        L --&gt; N[match: C ‚Üí D]
    M --&gt; N[match: E ‚Üí D]
    
    subgraph &#34;pipe &#43; chain &#43; map &#43; match&#34;
    A
    B
    C
    D
    E
    F
    G
    H
    I
    J
    K
    L
    M
    N
    end

    style A fill:#f9f9f9,stroke:#666
    style C fill:#d5f5e3,stroke:#2ecc71
    style D fill:#ffdddd,stroke:#e74c3c
    style H fill:#d5f5e3,stroke:#2ecc71
    style I fill:#ffdddd,stroke:#e74c3c
    style L fill:#d5f5e3,stroke:#2ecc71
    style M fill:#ffdddd,stroke:#e74c3c
    style N fill:#d6eaf8,stroke:#3498db,stroke-width:2px</div>
 <p>O diagrama acima ilustra o fluxo de processamento usando a combina√ß√£o de operadores <code>pipe</code>, <code>chain</code>, <code>map</code> e <code>match</code> com o tipo <code>Either</code>. Ele demonstra como um valor inicial <code>E.Either&lt;E, A&gt;</code> √© processado atrav√©s de uma s√©rie de transforma√ß√µes condicionais. Se o valor for um <code>Right&lt;A&gt;</code>, ele passa pela fun√ß√£o <code>chain</code> que pode produzir um novo <code>E.Either&lt;E, B&gt;</code>. Se esse resultado for um <code>Right&lt;B&gt;</code>, ele √© transformado pela fun√ß√£o <code>map</code> em um <code>Right&lt;C&gt;</code>. Em qualquer ponto onde um <code>Left&lt;E&gt;</code> √© encontrado, o fluxo de transforma√ß√µes √© curto-circuitado, propagando o erro at√© o final.</p>
<p>Finalmente, a fun√ß√£o <code>match</code> √© aplicada para extrair o valor final, seja ele um sucesso (<code>C</code>) ou um erro (<code>E</code>), convertendo-os para um tipo comum <code>D</code>. Este padr√£o de composi√ß√£o permite criar pipelines de processamento robustos onde os erros s√£o tratados de forma elegante e expl√≠cita. Vamos ver um exemplo pr√°tico de como usar <code>chain</code> com <code>Either</code> no c√≥digo abaixo:</p>


  <pre><code class="language-typescript">// Fun√ß√£o que valida se um n√∫mero √© positivo
const garantirPositivo = (n: number): E.Either&lt;string, number&gt; =&gt;
  n &gt; 0 ? E.right(n) : E.left(&#34;N√∫mero deve ser positivo!&#34;);

// Fun√ß√£o que calcula a raiz quadrada (apenas para positivos)
const raizQuadradaSegura = (n: number): E.Either&lt;string, number&gt; =&gt;
  n &lt; 0 ? E.left(&#34;N√£o √© poss√≠vel calcular raiz de n√∫mero negativo!&#34;) : E.right(Math.sqrt(n));

// Cen√°rio 1: Sucesso em tudo
const computacaoSucesso = pipe(
  dividir(32, 2),           // Right(16)
  E.chain(garantirPositivo),  // Right(16) -&gt; garantirPositivo(16) -&gt; Right(16)
  E.chain(raizQuadradaSegura) // Right(16) -&gt; raizQuadradaSegura(16) -&gt; Right(4)
);
console.log(pipe(computacaoSucesso, E.match(e =&gt; e, v =&gt; v.toString()))); // &#34;4&#34;

// Cen√°rio 2: Falha na divis√£o
const computacaoFalhaDivisao = pipe(
  dividir(32, 0),           // Left(&#34;Divis√£o por zero!&#34;)
  E.chain(garantirPositivo),  // Ignorado, propaga Left(&#34;Divis√£o por zero!&#34;)
  E.chain(raizQuadradaSegura) // Ignorado, propaga Left(&#34;Divis√£o por zero!&#34;)
);
console.log(pipe(computacaoFalhaDivisao, E.match(e =&gt; e, v =&gt; v.toString()))); // &#34;Divis√£o por zero!&#34;

// Cen√°rio 3: Falha na valida√ß√£o de positivo
const computacaoFalhaPositivo = pipe(
  E.right(-10),               // Come√ßamos com um Right(-10) para este exemplo
  E.chain(garantirPositivo),  // Right(-10) -&gt; garantirPositivo(-10) -&gt; Left(&#34;N√∫mero deve ser positivo!&#34;)
  E.chain(raizQuadradaSegura) // Ignorado, propaga Left(&#34;N√∫mero deve ser positivo!&#34;)
);
console.log(pipe(computacaoFalhaPositivo, E.match(e =&gt; e, v =&gt; v.toString()))); // &#34;N√∫mero deve ser positivo!&#34;</code></pre>
 <p>Note como o primeiro <code>Left</code> encontrado interrompe a cadeia e √© propagado at√© o final.</p>
<hr>
<h2 id="usando-taskeithere-a-o-poder-de-either-no-mundo-ass√≠ncrono">Usando <code>TaskEither&lt;E, A&gt;</code>: O Poder de <code>Either</code> no Mundo Ass√≠ncrono</h2>
<p>E quando nossas opera√ß√µes s√£o ass√≠ncronas, como chamadas de API ou intera√ß√µes com banco de dados? Para entender o <code>TaskEither&lt;E, A&gt;</code>, vamos construir o conceito passo a passo:</p>
<ol>
<li>
<p>Uma <code>Promise&lt;A&gt;</code> no JavaScript representa uma opera√ß√£o ass√≠ncrona que eventualmente produzir√° um valor do tipo <code>A</code> ou ser√° rejeitada com um erro.</p>
</li>
<li>
<p>Na biblioteca fp-ts, o tipo <code>Task&lt;A&gt;</code> √© essencialmente uma fun√ß√£o que retorna uma <code>Promise&lt;A&gt;</code>, mas com uma abordagem mais funcional. √â definido como <code>() =&gt; Promise&lt;A&gt;</code>.</p>
</li>
<li>
<p>O <code>TaskEither&lt;E, A&gt;</code> combina o conceito de <code>Task</code> com <code>Either</code>. Formalmente, √© um <code>Task&lt;Either&lt;E, A&gt;&gt;</code>, ou seja, uma fun√ß√£o que retorna uma promessa que resolver√° para um <code>Either&lt;E, A&gt;</code>.</p>
</li>
</ol>
<p>Isso nos d√° o melhor dos dois mundos: a capacidade de lidar com opera√ß√µes ass√≠ncronas (como o <code>Promise</code>) e um tratamento de erros expl√≠cito e tipado (como o <code>Either</code>).</p>
<p>Na pr√°tica, o <code>TaskEither</code> √© perfeito para opera√ß√µes que demoram para completar e podem falhar, como buscar dados de um servidor ou ler um arquivo. Em vez de usar <code>try/catch</code> espalhados pelo c√≥digo ou verificar erros manualmente, voc√™ encadeia opera√ß√µes de forma elegante e o sistema de tipos garante que voc√™ n√£o esque√ßa de tratar os erros.</p>
<p>A grande vantagem √© que, diferente de uma <code>Promise</code> comum que mistura o fluxo de sucesso e erro em callbacks separados (<code>.then()</code> e <code>.catch()</code>), o <code>TaskEither</code> mant√©m ambos os caminhos dentro do mesmo tipo, permitindo composi√ß√£o mais segura e previs√≠vel de opera√ß√µes ass√≠ncronas que podem falhar. Vamos ver um exemplo pr√°tico de como usar <code>TaskEither</code> no c√≥digo abaixo:</p>


  <pre><code class="language-typescript">import * as TE from &#34;fp-ts/TaskEither&#34;;
// &#39;pipe&#39; j√° foi importado de &#39;fp-ts/function&#39;

interface UserData {
  id: number;
  name: string;
  email: string;
}

// Erro customizado para nossa API
class NetworkError extends Error {
  constructor(message: string, public status?: number) {
    super(message);
    this.name = &#34;NetworkError&#34;;
  }
}

const fetchUser = (userId: number): TE.TaskEither&lt;NetworkError, UserData&gt; =&gt;
  TE.tryCatch&lt;NetworkError, UserData&gt;(
    // A fun√ß√£o que retorna uma Promise (o &#34;try&#34; do tryCatch)
    async () =&gt; {
      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
      if (!response.ok) {
        // Lan√ßamos um erro customizado para ser capturado pelo &#39;onRejected&#39;
        throw new NetworkError(`Falha na requisi√ß√£o: ${response.statusText}`, response.status);
      }
      return response.json() as Promise&lt;UserData&gt;; // Garantimos o tipo
    },
    // A fun√ß√£o que converte o erro/rejei√ß√£o da Promise em um Left&lt;E&gt;
    (motivoDesconhecido: unknown): NetworkError =&gt; {
      if (motivoDesconhecido instanceof NetworkError) {
        return motivoDesconhecido;
      }
      // Para outros tipos de erros (ex: falha de rede antes da resposta HTTP)
      return new NetworkError(String(motivoDesconhecido));
    }
  );

// Como usar:
async function exibirNomeUsuario(id: number): Promise&lt;void&gt; {
  const programa = pipe(
    fetchUser(id), // Retorna TaskEither&lt;NetworkError, UserData&gt;
    TE.map(user =&gt; `Nome do usu√°rio: ${user.name}`), // Transforma o sucesso
    TE.matchE(
      // Fun√ß√£o para o caso de falha (Left)
      (erro) =&gt; async () =&gt; console.error(`Erro ao buscar usu√°rio: ${erro.message}${erro.status ? ` (Status: ${erro.status})` : &#39;&#39;}`),
      // Fun√ß√£o para o caso de sucesso (Right)
      (nomeFormatado) =&gt; async () =&gt; console.log(nomeFormatado)
    )
  );
  // Para executar o TaskEither e obter o resultado (ou efeito colateral), chamamos a fun√ß√£o retornada por matchE:
  await programa();
}

// Pattern alternativo: TE.mapError para logging de erros no pipeline
// Nota: Em TaskEither, mapError √© a forma preferida; mapLeft permanece como alias legado
const programaComLog = pipe(
  fetchUser(id),
  TE.mapError((erro) =&gt; {
    console.error(`Falha na opera√ß√£o: ${erro.message}`);
    // Aqui voc√™ pode adicionar logging estruturado, m√©tricas, etc.
    return erro; // Retorna o erro para continuar o pipeline
  }),
  TE.matchE(
    (erro) =&gt; async () =&gt; console.error(`Erro final: ${erro.message}`),
    (user) =&gt; async () =&gt; console.log(`Sucesso: ${user.name}`)
  )
);

// Testando:
// exibirNomeUsuario(1); // Deve imprimir &#34;Nome do usu√°rio: Leanne Graham&#34; (ou similar)
// exibirNomeUsuario(999); // Deve imprimir o erro de &#34;Falha na requisi√ß√£o: Not Found (Status: 404)&#34;</code></pre>
 <p>O <code>tryCatch</code> √© um construtor muito √∫til para envolver c√≥digo baseado em Promises que pode rejeitar. Ele transforma o modelo tradicional de tratamento de erros com <code>try/catch</code> em uma estrutura funcional, encapsulando tanto o caminho feliz quanto o de erro em um √∫nico tipo de dados <code>TaskEither</code>. Isso permite que o c√≥digo cliente trabalhe com um valor que representa explicitamente a possibilidade de falha, em vez de depender de exce√ß√µes impl√≠citas.</p>
<p>A principal vantagem desse construtor √© a separa√ß√£o clara entre a l√≥gica de neg√≥cio e o tratamento de erros. Ao usar <code>tryCatch</code>, voc√™ define duas fun√ß√µes: uma que executa a opera√ß√£o principal (retornando uma Promise) e outra que converte qualquer erro em um tipo espec√≠fico. Isso torna o c√≥digo mais previs√≠vel e facilita o rastreamento de todos os poss√≠veis caminhos de erro atrav√©s do sistema de tipos.</p>
<p>Al√©m disso, <code>tryCatch</code> se integra perfeitamente com outras fun√ß√µes do ecossistema fp-ts, permitindo compor opera√ß√µes ass√≠ncronas que podem falhar de maneira elegante e segura. Em vez de aninhamentos complexos de try/catch ou promessas encadeadas com .catch(), voc√™ pode usar operadores como pipe, map e chain para expressar fluxos de dados complexos de forma declarativa, mantendo o tratamento de erros consistente em toda a aplica√ß√£o.</p>
<p>A tabela abaixo compara as diferentes estrat√©gias de tratamento de erros em TypeScript, destacando os pontos fortes e fracos de cada uma:</p>
<table>
  <thead>
      <tr>
          <th>Abordagem</th>
          <th>Pr√≥s</th>
          <th>Contras</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>try/catch com exce√ß√µes</strong></td>
          <td>‚Ä¢ Sintaxe familiar e padr√£o da linguagem<br>‚Ä¢ Separa√ß√£o visual entre c√≥digo normal e tratamento de erro<br>‚Ä¢ Captura erros em qualquer n√≠vel da pilha de chamadas</td>
          <td>‚Ä¢ Contrato impl√≠cito (assinatura da fun√ß√£o n√£o indica possibilidade de erro)<br>‚Ä¢ Interrompe abruptamente o fluxo de execu√ß√£o<br>‚Ä¢ F√°cil esquecer de usar try/catch<br>‚Ä¢ Dif√≠cil composi√ß√£o de fun√ß√µes que podem lan√ßar exce√ß√µes<br>‚Ä¢ Tipagem de erros geralmente fraca (any)</td>
      </tr>
      <tr>
          <td><strong>Retorno de null/undefined</strong></td>
          <td>‚Ä¢ Simplicidade de implementa√ß√£o<br>‚Ä¢ N√£o interrompe o fluxo de execu√ß√£o</td>
          <td>‚Ä¢ Perda completa de contexto do erro<br>‚Ä¢ Verifica√ß√µes constantes de null/undefined<br>‚Ä¢ F√°cil esquecer verifica√ß√µes, causando erros em runtime<br>‚Ä¢ N√£o escala bem para opera√ß√µes compostas</td>
      </tr>
      <tr>
          <td><strong>Objetos de resultado/erro</strong></td>
          <td>‚Ä¢ Contrato expl√≠cito<br>‚Ä¢ Preserva algum contexto de erro<br>‚Ä¢ N√£o interrompe o fluxo de execu√ß√£o</td>
          <td>‚Ä¢ C√≥digo verboso com muitas verifica√ß√µes manuais<br>‚Ä¢ Disciplina manual para manter consist√™ncia<br>‚Ä¢ Composi√ß√£o de opera√ß√µes torna-se complexa<br>‚Ä¢ Tipagem pode ser amb√≠gua (propriedades opcionais)</td>
      </tr>
      <tr>
          <td><strong>Either/TaskEither</strong></td>
          <td>‚Ä¢ Contrato totalmente expl√≠cito via sistema de tipos<br>‚Ä¢ Composi√ß√£o elegante de opera√ß√µes<br>‚Ä¢ Tratamento de erro obrigat√≥rio (imposs√≠vel &ldquo;esquecer&rdquo;)<br>‚Ä¢ Preserva√ß√£o completa do contexto de erro<br>‚Ä¢ Fluxo de execu√ß√£o previs√≠vel<br>‚Ä¢ Facilita testes unit√°rios</td>
          <td>‚Ä¢ Curva de aprendizado inicial<br>‚Ä¢ Requer familiaridade com conceitos funcionais<br>‚Ä¢ Verbosidade em casos simples<br>‚Ä¢ Depend√™ncia de biblioteca externa (fp-ts)</td>
      </tr>
  </tbody>
</table>
<p>A abordagem com <code>Either</code> e <code>TaskEither</code> oferece o melhor equil√≠brio entre seguran√ßa de tipos, composi√ß√£o e manutenibilidade para sistemas complexos, embora exija um investimento inicial em aprendizado dos conceitos de programa√ß√£o funcional.</p>
<h3 id="taskeither-computa√ß√£o-ass√≠ncrona-com-tratamento-expl√≠cito-de-erros">TaskEither: Computa√ß√£o Ass√≠ncrona com Tratamento Expl√≠cito de Erros</h3>
<p>Um aspecto fundamental a ser compreendido sobre <code>TaskEither</code> √© que ele representa uma <em>descri√ß√£o</em> de uma computa√ß√£o ass√≠ncrona que pode falhar, n√£o a execu√ß√£o imediata dessa computa√ß√£o. Quando voc√™ cria um <code>TaskEither</code>, est√° apenas definindo o que deve acontecer, sem executar nenhum c√≥digo ass√≠ncrono naquele momento. Esta √© uma caracter√≠stica poderosa da programa√ß√£o funcional: a separa√ß√£o entre a defini√ß√£o de uma computa√ß√£o e sua execu√ß√£o.</p>
<p>Formalmente, um <code>TaskEither&lt;E, A&gt;</code> √© definido como <code>() =&gt; Promise&lt;E.Either&lt;E, A&gt;&gt;</code> - uma fun√ß√£o que retorna uma Promise que resolver√° para um <code>E.Either&lt;E, A&gt;</code>. Esta defini√ß√£o torna expl√≠cito que <code>TaskEither</code> √© lazy: a computa√ß√£o s√≥ √© executada quando a fun√ß√£o √© chamada.</p>
<p>Esta separa√ß√£o oferece benef√≠cios significativos. Primeiro, permite compor opera√ß√µes complexas de forma declarativa, construindo um pipeline de transforma√ß√µes antes de qualquer execu√ß√£o. Segundo, facilita o teste unit√°rio, j√° que voc√™ pode inspecionar e manipular a descri√ß√£o da computa√ß√£o sem disparar efeitos colaterais. Terceiro, proporciona otimiza√ß√µes como <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation (avalia√ß√£o pregui√ßosa)</a>, onde computa√ß√µes s√£o executadas apenas quando realmente necess√°rias.</p>
<p>A execu√ß√£o real s√≥ ocorre no que chamamos de &ldquo;fim do mundo&rdquo; - o momento em que voc√™ efetivamente precisa do resultado ou do efeito colateral. Isso acontece em duas etapas: primeiro, quando usamos <code>matchE</code> (ou outros combinadores finais como <code>getOrElseEW</code>) para &ldquo;consumir&rdquo; o <code>TaskEither</code> e transform√°-lo em uma <code>Task</code> (que √© essencialmente uma fun√ß√£o <code>() =&gt; Promise&lt;A&gt;</code>) que deve ser invocada; e depois, quando chamamos <code>await programa()</code> para executar essa <code>Task</code> e obter o resultado final.</p>
<p>Este modelo de execu√ß√£o adiada d√° ao desenvolvedor controle preciso sobre quando e como os efeitos ocorrem, tornando o c√≥digo mais previs√≠vel e facilitando o racioc√≠nio sobre o fluxo de dados, especialmente em aplica√ß√µes complexas com m√∫ltiplas opera√ß√µes ass√≠ncronas interdependentes.</p>
<h2 id="taskoption-quando-a-aus√™ncia-√©-esperada">TaskOption: Quando a Aus√™ncia √© Esperada</h2>
<p>Al√©m do <code>TaskEither</code>, o fp-ts oferece <code>TaskOption</code> para cen√°rios onde a aus√™ncia de valor √© um resultado esperado em opera√ß√µes ass√≠ncronas. Diferente do <code>TaskEither</code>, que modela falhas como erros, o <code>TaskOption</code> √© ideal quando &ldquo;n√£o encontrado&rdquo; √© um estado v√°lido da aplica√ß√£o.</p>


  <pre><code class="language-typescript">import * as TO from &#39;fp-ts/TaskOption&#39;;

// Buscar usu√°rio que pode n√£o existir
const buscarUsuarioOpcional = (id: number): TO.TaskOption&lt;UserData&gt; =&gt;
  TO.tryCatch(async () =&gt; {
    const res = await fetch(`/api/users/${id}`);
    if (res.status === 404) throw new Error(&#39;NOT_FOUND&#39;); // vira none
    if (!res.ok) throw new Error(String(res.status));
    return res.json() as Promise&lt;UserData&gt;;
  });

// Uso: a aus√™ncia √© tratada como um caso normal
const programa = pipe(
  buscarUsuarioOpcional(123),
  TO.match(
    () =&gt; console.log(&#34;Usu√°rio n√£o encontrado&#34;), // Caso normal
    (user) =&gt; console.log(`Usu√°rio: ${user.name}`)
  )
);</code></pre>
 <p>Use <code>TaskOption</code> quando a aus√™ncia de valor √© um resultado esperado (como buscas que podem n√£o retornar resultados), e <code>TaskEither</code> quando a aus√™ncia representa uma falha real da opera√ß√£o.</p>
<h2 id="interoperabilidade-com-promises">Interoperabilidade com Promises</h2>
<p>O fp-ts 3.x oferece fun√ß√µes especializadas para interoperar com c√≥digo baseado em Promises existente. Em vez de usar <code>tryCatch</code> manualmente para envolver fun√ß√µes que j√° retornam <code>Promise</code>, prefira <code>tryCatchK</code> ou <code>fromPromise</code>:</p>


  <pre><code class="language-typescript">import * as TE from &#39;fp-ts/TaskEither&#39;;

// ‚ùå Evite: tryCatch manual para fun√ß√µes que j√° retornam Promise
const fetchUserManual = (id: number): TE.TaskEither&lt;Error, UserData&gt; =&gt;
  TE.tryCatch(
    () =&gt; fetchUserPromise(id), // Fun√ß√£o que j√° retorna Promise&lt;UserData&gt;
    (e) =&gt; new Error(String(e))
  );

// ‚úÖ Prefira: tryCatchK para fun√ß√µes que j√° retornam Promise
const fetchUserK = (id: number): TE.TaskEither&lt;Error, UserData&gt; =&gt;
  TE.tryCatchK(
    fetchUserPromise, // Passa a fun√ß√£o diretamente
    (e: unknown) =&gt; new Error(String(e))
  )(id);</code></pre>
 <p>Estas fun√ß√µes s√£o mais idiom√°ticas e type-safe, especialmente quando voc√™ est√° integrando bibliotecas existentes que j√° trabalham com Promises.</p>
<blockquote>
<p><strong>Nota:</strong> A abordagem lazy evaluation √© uma t√©cnica que adia a execu√ß√£o de uma computa√ß√£o at√© que seu resultado seja realmente necess√°rio. Em outras palavras, a computa√ß√£o n√£o √© executada imediatamente, mas apenas quando realmente precisamos do resultado. Isso pode ser ben√©fico em situa√ß√µes onde a computa√ß√£o √© cara (em termos de tempo ou recursos) e n√£o √© necess√°ria imediatamente.</p></blockquote>
<p>Um dos benef√≠cios mais profundos de <code>Either</code> e <code>TaskEither</code> √© como eles tornam os efeitos colaterais expl√≠citos no sistema de tipos. Em programa√ß√£o funcional, um &ldquo;efeito colateral&rdquo; √© qualquer intera√ß√£o com o mundo externo: leitura/escrita de arquivos, chamadas de rede, acesso a banco de dados, ou qualquer opera√ß√£o que possa falhar por raz√µes fora do controle do programa.</p>
<p>Tradicionalmente, esses efeitos s√£o &ldquo;invis√≠veis&rdquo; na assinatura das fun√ß√µes em TypeScript/JavaScript. Uma fun√ß√£o que faz uma chamada HTTP n√£o indica isso em seu tipo de retorno, e as exce√ß√µes que podem ocorrer n√£o s√£o capturadas pelo sistema de tipos. Isso cria um &ldquo;vazamento&rdquo; onde efeitos potencialmente perigosos escapam da an√°lise est√°tica.</p>
<h2 id="compondo-m√∫ltiplas-requisi√ß√µes-ass√≠ncronas">Compondo M√∫ltiplas Requisi√ß√µes Ass√≠ncronas</h2>
<p>O <code>fp-ts</code> brilha na composi√ß√£o. Se precisarmos de dados de m√∫ltiplas fontes, podemos encadear opera√ß√µes de forma elegante e segura, como demonstrado nos exemplos acima. Por fim, a biblioteca fp-ts oferece uma abordagem robusta para lidar com erros em TypeScript, transformando o tratamento de exce√ß√µes tradicional em um fluxo de dados previs√≠vel e tipado.</p>
<p>Ao adotar esses padr√µes funcionais, conseguimos criar c√≥digo mais confi√°vel, test√°vel e manuten√≠vel, onde os erros s√£o tratados como cidad√£os de primeira classe em vez de casos excepcionais.</p>
<p>Essa mudan√ßa de paradigma n√£o apenas melhora a qualidade do c√≥digo, mas tamb√©m proporciona uma experi√™ncia de desenvolvimento mais agrad√°vel, onde a composi√ß√£o de opera√ß√µes complexas se torna natural e o sistema de tipos trabalha a nosso favor para garantir que todos os casos de erro sejam devidamente considerados.</p>
<p>Vamos ver um exemplo pr√°tico de como usar <code>TaskEither</code> para buscar um post e depois seus coment√°rios:</p>


  <pre><code class="language-typescript">import * as TE from &#39;fp-ts/TaskEither&#39;;
// pipe j√° importado de &#39;fp-ts/function&#39;

// Suponha que fetchPost retorne TaskEither&lt;NetworkError, PostData&gt;
// e fetchComments retorne TaskEither&lt;NetworkError, CommentData[]&gt; para um postId

// Exemplo fict√≠cio:
interface PostData { id: number; title: string; userId: number; }
interface CommentData { id: number; body: string; postId: number; }

const fetchPost = (postId: number): TE.TaskEither&lt;NetworkError, PostData&gt; =&gt;
  TE.tryCatch(
    async () =&gt; {
      const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`);
      if (!res.ok) throw new NetworkError(`Post n√£o encontrado: ${res.status}`, res.status);
      return res.json();
    },
    (r: unknown): NetworkError =&gt; new NetworkError(String(r))
  );

const fetchCommentsForPost = (postId: number): TE.TaskEither&lt;NetworkError, CommentData[]&gt; =&gt;
  TE.tryCatch(
    async () =&gt; {
      const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${postId}/comments`);
      if (!res.ok) throw new NetworkError(`Coment√°rios n√£o encontrados: ${res.status}`, res.status);
      return res.json();
    },
    (r: unknown): NetworkError =&gt; new NetworkError(String(r))
  );


// Objetivo: buscar um post e depois seus coment√°rios
const getPostWithComments = (postId: number): TE.TaskEither&lt;NetworkError, { post: PostData; comments: CommentData[] }&gt; =&gt;
  pipe(
    fetchPost(postId), // TaskEither&lt;NetworkError, PostData&gt;
    TE.chain(post =&gt; // Se fetchPost deu certo, &#39;post&#39; √© PostData
      pipe(
        fetchCommentsForPost(post.id), // TaskEither&lt;NetworkError, CommentData[]&gt;
        TE.map(comments =&gt; ({ post, comments })) // Se fetchComments deu certo, combina os resultados
      )
    )
  );

// Para buscar v√°rios posts e seus coment√°rios em paralelo (cuidado com limites de API):
const getUserIds = [1, 2, 3]; // IDs de posts, por exemplo

// Criamos um array de TaskEithers, cada um buscando um usu√°rio
const fetchAllUsersPrograms: Array&lt;TE.TaskEither&lt;NetworkError, UserData&gt;&gt; = getUserIds.map(fetchUser);

// TE.sequenceArray transforma Array&lt;TaskEither&lt;E, A&gt;&gt; em TaskEither&lt;E, Array&lt;A&gt;&gt;
// Ele executa todas as Tasks em paralelo. Se qualquer uma falhar, o resultado √© o primeiro Left.
// ‚ö†Ô∏è Importante: sequenceArray s√≥ funciona com tipos homog√™neos (todos retornam o mesmo tipo A).
// Se os tipos de retorno diferem, use sequenceT ou mapeie para uma uni√£o A | B.
// Para padr√µes mais gerais, considere tamb√©m TE.traverseReadonlyArrayWithIndex
const allUsersProgram: TE.TaskEither&lt;NetworkError, UserData[]&gt; = pipe(
  fetchAllUsersPrograms,
  TE.sequenceArray
);

async function processarUsuarios() {
  const resultado = await pipe(
    allUsersProgram,
    TE.map(users =&gt; users.map(u =&gt; u.name)), // Extrai apenas os nomes se tudo der certo
    TE.matchE(
      (erro) =&gt; async () =&gt; `Falha ao buscar usu√°rios: ${erro.message}`,
      (nomes) =&gt; async () =&gt; `Nomes dos usu√°rios: ${nomes.join(&#39;, &#39;)}`
    )
  )(); // Executa e obt√©m a string final
  console.log(resultado);
}

// processarUsuarios();</code></pre>
 <p>Note que o <code>TE.sequenceArray</code> (e seu an√°logo <code>A.sequence(TE.ApplicativePar)</code>) √© poderoso para paralelizar opera√ß√µes fal√≠veis. Adotar <code>Either</code>, <code>Option</code> e <code>TaskEither</code> traz benef√≠cios significativos como type safety expl√≠cito e previsibilidade. O compilador se torna seu aliado, for√ßando voc√™ a lidar com todos os caminhos poss√≠veis, enquanto as falhas s√£o tratadas como valores esperados no fluxo de dados, eliminando surpresas como <code>Uncaught Error</code> que interrompem sua aplica√ß√£o.</p>
<p>A ado√ß√£o desses tipos funcionais resulta em c√≥digo mais limpo e declarativo, reduzindo drasticamente a necessidade de <code>try/catch</code> aninhados e condicionais. O fluxo de dados se torna mais claro com opera√ß√µes como <code>pipe</code>, <code>map</code> e <code>chain</code>, enquanto fun√ß√µes que retornam <code>Either</code> ou <code>TaskEither</code> podem ser encadeadas de forma segura e elegante, com propaga√ß√£o autom√°tica de erros que simplifica l√≥gicas complexas.</p>
<p>Al√©m disso, a manuten√ß√£o e evolu√ß√£o do c√≥digo se tornam mais robustas, pois alterar ou adicionar etapas em um fluxo de processamento √© mais seguro quando o sistema de tipos garanta que todos os casos de erro sejam considerados. A testabilidade tamb√©m √© aprimorada, j√° que fun√ß√µes puras que retornam <code>Either</code> s√£o mais f√°ceis de testar unitariamente por n√£o dependerem de mecanismos de exce√ß√£o globais, contribuindo para uma base de c√≥digo mais confi√°vel e sustent√°vel.</p>
<h2 id="trade-offs">Trade-offs</h2>
<p>Embora as abstra√ß√µes funcionais como <code>Either</code> e <code>TaskEither</code> ofere√ßam benef√≠cios significativos para o tratamento de erros, √© importante considerar alguns trade-offs, especialmente em rela√ß√£o √† performance:</p>
<ul>
<li>
<p><strong>Overhead de Aloca√ß√£o:</strong> cada <code>Either</code>, <code>TaskEither</code> ou <code>Option</code> cria estruturas de dados adicionais na mem√≥ria. Em <a href="https://en.wikipedia.org/wiki/Hot_path">hot paths</a> de aplica√ß√µes que processam grandes volumes de dados, esse overhead de aloca√ß√£o pode se tornar percept√≠vel. Comparado com abordagens mais diretas como verifica√ß√µes de <code>null</code> ou <code>try/catch</code>, h√° um custo adicional de mem√≥ria.</p>
</li>
<li>
<p><strong>Micro-overhead em Opera√ß√µes Ass√≠ncronas:</strong> <code>TaskEither</code> introduz um micro-overhead por aloca√ß√£o e composi√ß√£o em compara√ß√£o com Promises nativas. Este overhead √© geralmente insignificante para a maioria das aplica√ß√µes (uma opera√ß√£o de rede t√≠pica leva 50-200ms), mas pode ser relevante em sistemas com milhares de opera√ß√µes por segundo ou requisitos extremos de baixa lat√™ncia.</p>
</li>
<li>
<p><strong>Curva de Aprendizado:</strong> a programa√ß√£o funcional e seus tipos algebr√°icos t√™m uma curva de aprendizado significativa para equipes acostumadas com paradigmas imperativos. Isso pode reduzir temporariamente a produtividade at√© que a equipe esteja confort√°vel com conceitos como functors, monads e composi√ß√£o de fun√ß√µes.</p>
</li>
<li>
<p><strong>Pilha de Chamadas e Debugging:</strong> em cadeias longas de opera√ß√µes com <code>pipe</code> e <code>chain</code>, os stacktraces podem se tornar mais dif√≠ceis de interpretar quando ocorrem erros. Isso pode complicar o debugging em compara√ß√£o com c√≥digo imperativo mais direto. Para mitigar esse problema, √© recomend√°vel usar <code>E.mapLeft</code> (para Either) ou <code>TE.mapError</code> (para TaskEither) para enriquecer erros com contexto adicional em pontos estrat√©gicos da cadeia.</p>
</li>
<li>
<p><strong>Tamanho do Bundle:</strong> a inclus√£o da biblioteca <code>fp-ts</code> adiciona peso ao bundle final da aplica√ß√£o. Embora t√©cnicas de <a href="https://en.wikipedia.org/wiki/Tree_shaking">tree-shaking</a> possam mitigar isso, aplica√ß√µes que priorizam tamanho m√≠nimo de bundle (como PWAs ou aplica√ß√µes m√≥veis) precisam considerar esse impacto.</p>
</li>
</ul>
<hr>
<h2 id="refer√™ncias">Refer√™ncias</h2>
<ul>
<li><a href="https://github.com/gcanti/fp-ts">fp-ts</a> - Documenta√ß√£o oficial</li>
<li><a href="https://a.co/d/3LxV0CO">Hands-On Functional Programming with Typescript</a> - Livro do Remo H. Jansen publicado pela Packt. O livro aborda conceitos fundamentais para o tratamento funcional de erros, discutindo na se√ß√£o &ldquo;side-effects&rdquo; como podemos usar t√©cnicas de programa√ß√£o funcional para tornar expl√≠citos os efeitos colaterais em TypeScript.</li>
</ul>

    </div>
    
    
    



    
    
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                        
                        
                    
                
                    
                
                    
                        
                        
                    
                
                    
                        
                        
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
                
            
        
    
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
            
            
        
    
        
            
            
            
            
            
            
        
    
    
    
        
        
        
        <div class="related-posts">
            <h3 class="related-posts-title">üìö Posts Relacionados</h3>
            <div class="related-posts-grid">
                
                    
                    <article class="related-post-item animate-on-scroll">
                        <div class="related-post-content">
                            <h4 class="related-post-title">
                                <a href="/2025/05/23/trycatch/">Try/Catch: Origem, Prop√≥sito e o Erro de Us√°-lo como Fluxo L√≥gico</a>
                            </h4>
                            <p class="related-post-excerpt">
                                <p>O tratamento de exce√ß√µes surgiu para separar o fluxo normal do programa do tratamento de situa√ß√µes inesperadas, como falhas de hardware ou erros de entrada/sa√≠da. Inicialmente, programas usavam c√≥digos de retorno para lidar com erros, mas isso era propenso a falhas e dif√≠cil de manter.</p>
<p>O modelo <code>try/catch</code> foi evoluindo desde os anos 60, ganhando formas mais estruturadas em linguagens como <a href="https://en.wikipedia.org/wiki/PL/I">PL/I</a>, <a href="https://en.wikipedia.org/wiki/Ada_%28programming_language%29">Ada</a>, <a href="https://en.wikipedia.org/wiki/C%2B%2B">C++</a> e <a href="https://en.wikipedia.org/wiki/Java_%28programming_language%29">Java</a>, e depois sendo adotado por outras como <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>.</p>
<p>O objetivo sempre foi permitir que programas lidassem de forma controlada com erros imprevis√≠veis, sem travar o sistema. As exce√ß√µes n√£o foram criadas para controlar o fluxo normal do programa, mas sim para tratar casos realmente excepcionais. Neste artigo, vamos ver por que usar <code>try/catch</code> como controle de fluxo √© um erro e qual √© o seu prop√≥sito real.</p>
                            </p>
                            <div class="related-post-meta">
                                <span class="related-post-date">23/05/2025</span>
                                
                                    <div class="related-post-tags">
                                        
                                            <span class="tag">tratamento de erros</span>
                                        
                                            <span class="tag">exce√ß√µes</span>
                                        
                                    </div>
                                
                            </div>
                            <div class="related-post-score">
                                <modern-badge variant="info">3 tags em comum</modern-badge>
                            </div>
                        </div>
                    </article>
                
            </div>
        </div>
    

    
    
    
    
<div class="comments-section">
    <h3 class="comments-title">üí¨ Coment√°rios</h3>
    <div class="comments-container">
        <script src="https://giscus.app/client.js"
                data-repo="scovl/scovl.github.io"
                data-repo-id="MDEwOlJlcG9zaXRvcnkxMzg1OTI2ODA="
                data-category="General"
                data-category-id="DIC_kwDOCELBqM4CthUV"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="pt"
                crossorigin="anonymous"
                async>
        </script>
    </div>
</div>

    
</article>

        </div>
    </main>
    
    
    
    <footer class="footer">
    <div class="container">
        <div class="footer-content">
            <div class="footer-links">
                
                <a href="https://github.com/scovl" target="_blank" rel="noopener noreferrer" class="footer-link">
                    GitHub
                </a>
                
                
                
                <a href="https://linkedin.com/in/vitor-lobo" target="_blank" rel="noopener noreferrer" class="footer-link">
                    LinkedIn
                </a>
                
                
                
                <a href="mailto:lobocode@gmail.com" class="footer-link">
                    Email
                </a>
                

                
                <a href="https://hachyderm.io/@lobocode" target="_blank" rel="noopener noreferrer" class="footer-link">
                    Mastodon
                </a>
                

                
                <a href="https://scovl.github.io/index.xml" target="_blank" rel="noopener noreferrer" class="footer-link">
                    RSS
                </a>
                
            </div>
            
            
            <div class="back-to-top-container">
                <button id="back-to-top" class="back-to-top-btn" aria-label="Voltar ao topo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m18 15-6-6-6 6"/>
                    </svg>
                    <span data-i18n="back_to_top">Voltar ao topo</span>
                </button>
            </div>
            
            <div class="copyright">
                &copy; 2025 scovl
            </div>
        </div>
    </div>
</footer> 
    
    
    
    <script src="/vendor/prism/prism-core.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-clike.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-c.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-cpp.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-rust.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-clojure.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-lisp.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-swift.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-bash.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-javascript.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-typescript.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-zig.min.js?v=1758736084"></script>
    <script src="/vendor/prism/prism-autoloader.min.js?v=1758736084"></script>
    
    
    <script src="/js/main-minimal.js?v=1758736084"></script>
    <script src="/js/lazy-loading.js?v=1758736084"></script>
    <script src="/js/toc.js?v=1758736084"></script>
    
    
    
</body>
</html> 