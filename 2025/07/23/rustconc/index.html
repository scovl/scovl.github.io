<!DOCTYPE html>
<html lang="pt">
<head>
    <title>Compreendendo a concorrÃªncia em Rust | scovl</title>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Thread safety em Rust nÃ£o Ã© magia: Ã© matemÃ¡tica">


<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        mermaid.initialize({
            startOnLoad: true,
            theme: 'light',
            align: 'center'
        });
    });
</script>
 
</head>
<body>
    
    
    <header class="header">
    <div class="container">
        <div class="header-content">
            <a href="https://scovl.github.io/" class="site-title">scovl</a>
            
            <nav>
                <ul class="nav-menu">
                    
                    
                    <li>
                        <a href="/page/about/" class="nav-link ">
                            About
                        </a>
                    </li>
                    
                    <li>
                        <a href="/page/contact/" class="nav-link ">
                            Contact
                        </a>
                    </li>
                    
                </ul>
            </nav>
        </div>
    </div>
</header> 
    
    
    
    <main>
        <div class="container">
            
<article class="post">
    <header class="post-header">
        <h1 class="post-title">Compreendendo a concorrÃªncia em Rust</h1>
        <div class="post-meta">
            
            <time datetime="2025-07-23T12:00:00Z">
                Wed, Jul 23, 2025
            </time>
            
            
            
            <span class="post-author">por Vitor Lobo Ramos</span>
            
            
            
            <div class="post-tags">
                
                <a href="/tags/rust/" class="tag">Rust</a>
                
                <a href="/tags/concorr%C3%AAncia/" class="tag">ConcorrÃªncia</a>
                
                <a href="/tags/seguran%C3%A7a/" class="tag">SeguranÃ§a</a>
                
                <a href="/tags/threads/" class="tag">Threads</a>
                
                <a href="/tags/async/" class="tag">Async</a>
                
            </div>
            
            
            
            <div class="reading-time">
                Estimated reading time: 46 min
            </div>
            
            
            
            <div class="post-description">
                Thread safety em Rust nÃ£o Ã© magia: Ã© matemÃ¡tica
            </div>
            
        </div>
    </header>
    
    <div class="post-content">
        <p>O Rust costuma ser apresentado como <strong>a linguagem que impede aqueles bugs de memÃ³ria cabeludos</strong> antes mesmo do seu cÃ³digo rodar. Mas essa histÃ³ria nÃ£o para no <strong><a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html#the-borrow-checker">borrow checker</a></strong>: ela se estende Ã  concorrÃªncia. O pessoal da comunidade fala em <strong>fearless concurrenc</strong> â€” â€œconcorrÃªncia sem medoâ€. Mas o que isso significa realmente? Como explicar isso para alguÃ©m que vem de outras linguagens? Em resumo, Rust transforma muitos erros de concorrÃªncia em erros de compilaÃ§Ã£o em vez de runtime, graÃ§as ao seu sistema de <em>ownership</em> e tipos. Esse aspecto Ã© o que chamamos de <strong>concorrÃªncia sem medo</strong>, onde escrever cÃ³digo concorrente nÃ£o precisa ser uma roleta-russa de bugs sutis.</p>
<h2 id="1-por-que-concorrÃªncia-costuma-dar-ruim">1. Por que concorrÃªncia costuma dar ruim?</h2>
<p>Um exemplo clÃ¡ssico de problema de concorrÃªncia aconteceu no <a href="https://www.kernel.org/">Linux</a>, documentado no <a href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2022-49443">CVEâ€‘2022â€‘49443</a>. Nesse caso, duas partes diferentes do sistema tentaram acessar e modificar a mesma lista na memÃ³ria ao mesmo tempo, sem nenhum mecanismo de sincronizaÃ§Ã£o para coordenar esse acesso. Como resultado, ocorreu um <a href="https://en.wikipedia.org/wiki/Data_race">data race</a>, em que as operaÃ§Ãµes simultÃ¢neas causaram inconsistÃªncias e corromperam o estado interno da lista.</p>
<p>O kernel do Linux detectou esse acesso inseguro e emitiu um alerta, mostrando exatamente onde a leitura e a escrita concorrentes aconteceram. Esse tipo de bug Ã© difÃ­cil de prever e reproduzir, pois depende do momento exato em que as threads acessam o recurso compartilhado, podendo causar falhas imprevisÃ­veis e difÃ­ceis de depurar. Abaixo estÃ¡ o alerta gerado pelo <a href="https://www.kernel.org/doc/html/latest/dev-tools/kcsan.html">KCSAN</a>:</p>


  <pre><code class="language-text">BUG: KCSAN: data-race in do_epoll_wait / do_epoll_wait
write to 0xffff88810480c7d8 ...
    ep_poll fs/eventpoll.c:1806
read to 0xffff88810480c7d8 ...
    list_empty_careful include/linux/list.h:329</code></pre>
 <p>Para resolver esse tipo de problema, Ã© preciso adicionar mecanismos de sincronizaÃ§Ã£o â€” como se fosse um &ldquo;sinal vermelho&rdquo; â€” para garantir que apenas uma thread por vez possa acessar ou modificar o recurso compartilhado, evitando a bagunÃ§a causada por acessos simultÃ¢neos. Ferramentas como o <strong><a href="https://www.chromium.org/developers/testing/threadsanitizer-tsan-v2/">ThreadSanitizer (TSan)</a></strong> e o <strong><a href="https://www.kernel.org/doc/html/latest/dev-tools/kcsan.html">KCSAN</a></strong> ajudam a identificar essas <a href="https://en.wikipedia.org/wiki/Race_condition">race conditions</a> durante os testes, monitorando a execuÃ§Ã£o do programa e apontando exatamente onde ocorreu o acesso inseguro como mostra a imagem abaixo:</p>
<p><img src="" alt="KCSAN alerta"></p>
<p>No entanto, essas ferramentas sÃ³ conseguem flagrar o erro se ele realmente acontecer durante os testes; caso contrÃ¡rio, o bug pode passar despercebido e sÃ³ se manifestar depois que o sistema jÃ¡ estiver em produÃ§Ã£o, como jÃ¡ ocorreu em projetos conhecidos como <a href="https://github.com/curl/curl/issues/4915">cURL</a> e <a href="https://github.com/grpc/grpc/issues/21729">gRPC</a> onde o problema sÃ³ foi detectado apÃ³s subir em produÃ§Ã£o. Em Rust, olha sÃ³ o que acontece se vocÃª tentar rodar esse cÃ³digo que Ã© um exemplo de um <a href="https://en.wikipedia.org/wiki/Data_race">data race</a>:</p>


  <pre><code class="language-rust">use std::{rc::Rc, thread};

fn main() {
    let rc = Rc::new(5);
    thread::spawn(move || println!(&#34;{rc}&#34;));
}</code></pre>
 <p>O compilador jÃ¡ reclama assim:</p>


  <pre><code class="language-">error[E0277]: `Rc&lt;i32&gt;` cannot be sent between threads safely</code></pre>
 <p>O Rust impede esse tipo de erro jÃ¡ na compilaÃ§Ã£o! Mas vale lembrar: se vocÃª recorrer a trechos <code>unsafe</code>, a responsabilidade volta para vocÃª â€” e aÃ­, se nÃ£o tomar cuidado, ainda pode acabar com bugs difÃ­ceis, como jÃ¡ aconteceu <a href="https://github.com/m-ou-se/evmap/issues/1">evmap</a>, em que o programa travou por causa de um <a href="https://en.wikipedia.org/wiki/Data_race">data race</a>. Ou seja, mesmo com as ferramentas certas, atenÃ§Ã£o e boas prÃ¡ticas continuam essenciais. Mas, como o Rust impede esse tipo de erro? como ele sabe que o <code>Rc&lt;i32&gt;</code> nÃ£o Ã© seguro de ser enviado entre threads? Que bruxaria Ã© essa?</p>
<h2 id="por-baixo-do-capÃ´-a-mÃ¡gica-dos-traits-send-e-sync">Por baixo do capÃ´: a mÃ¡gica dos traits <code>Send</code> e <code>Sync</code></h2>
<p>A seguranÃ§a de concorrÃªncia do Rust vem de regras inteligentes no sistema de tipos, usando <strong><a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html#using-traits-to-define-shared-state">traits especiais</a></strong>. A documentaÃ§Ã£o oficial do Rust explica: <em>&ldquo;Cada tipo de dado sabe se pode ser enviado ou compartilhado entre threads com seguranÃ§a, e o Rust forÃ§a essas regras. NÃ£o hÃ¡ corridas de dados!&rdquo;</em>.</p>
<p>Em outras palavras, o compilador verifica automaticamente, em tempo de compilaÃ§Ã£o, se um tipo pode ou nÃ£o ser usado por mÃºltiplas threads ao mesmo tempo. Esses verificadores sÃ£o dois <em>marker traits</em> (traits de marcaÃ§Ã£o) chamados <code>Send</code> e <code>Sync</code>. Eles nÃ£o tÃªm funÃ§Ãµes nem implementaÃ§Ãµes ativas em tempo de execuÃ§Ã£o; sÃ£o apenas etiquetas que dizem ao compilador: &ldquo;Este tipo Ã© seguro para enviar para outra thread&rdquo; ou &ldquo;Este tipo Ã© seguro para compartilhar entre threads&rdquo;.</p>
<p><strong><code>Send</code>:</strong> Indica que um tipo pode <strong>ser enviado</strong> (transferido em propriedade) de uma thread para outra com seguranÃ§a. Se um tipo implementa <code>Send</code>, vocÃª pode movÃª-lo para outra thread (por exemplo, passando como argumento para <code>std::thread::spawn</code>) sem risco de corromper dados. A maior parte dos tipos bÃ¡sicos do Rust Ã© <code>Send</code>: nÃºmeros primitivos (<code>i32</code>, <code>f64</code> etc.), booleanos, <em>strings</em> (<code>String</code>), vetores (<code>Vec&lt;T&gt;</code> se <code>T</code> for <code>Send</code>), entre outros. Isso equivale a dizer: &ldquo;Pode levar este dado para outra thread que nÃ£o vai ter problema â€“ ele Ã© seguro para transferÃªncia!&rdquo;.</p>
<p>No diagrama abaixo, ilustramos a verificaÃ§Ã£o do compilador para o trait <code>Send</code>. A &ldquo;Thread 1&rdquo; quer enviar um dado (caixa) para a &ldquo;Thread 2&rdquo;. O compilador Rust atua como uma ponte de inspeÃ§Ã£o: ele confere se o tipo do dado tem o selo <code>Send</code>. Se tiver, a transferÃªncia Ã© permitida, isto Ã©, a caixa atravessa a ponte e chega Ã  outra thread. Caso contrÃ¡rio, o compilador emite um erro em tempo de compilaÃ§Ã£o e nÃ£o deixa o programa seguir. No desenho, representamos o dado com a etiqueta <code>Send</code> sendo entregue atravÃ©s da ponte (compilador) da Thread 1 para a Thread 2, indicando que a passagem foi aprovada.</p>


  
    
  
  <div class="mermaid">graph LR
    subgraph Thread1 [Thread 1]
        A1((ğŸ¦€))
    end
    subgraph Thread2 [Thread 2]
        B1((ğŸ¦€))
    end

    %% Ponte (Compilador Rust verificando Send)
    A1 -- Entrega Caixa --&gt; P[Ponte: Compilador Rust, Aprovado âœ…]
    P -- Caixa Segura --&gt; B1

    %% Caixa de dados com etiqueta Send sendo transportada
    DADO[&#34;Dado&lt;br/&gt;&lt;span class=&#39;sendTag&#39;&gt;Send&lt;/span&gt;&#34;]
    style DADO fill:#fff,stroke:#888,stroke-width:2px
    style P fill:#d1fae5,stroke:#10b981,stroke-width:2px
    style A1 fill:#fef08a,stroke:#fbbf24,stroke-width:2px
    style B1 fill:#fed7aa,stroke:#fb923c,stroke-width:2px

    %% Mostrar caixa sobre a ponte durante a transferÃªncia
    P --- DADO
    DADO -.-&gt; B1</div>
 <p>No exemplo acima, a Thread 1 (esquerda) estÃ¡ enviando um dado para a Thread 2 (direita). A â€œponteâ€ representa o compilador Rust checando o tipo desse dado. Como o dado possui o marcador <code>Send</code>, o compilador permite a transferÃªncia (indicada pelo sÃ­mbolo âœ…). Se o tipo nÃ£o fosse <code>Send</code>, essa transferÃªncia seria barrada com um erro de compilaÃ§Ã£o.</p>
<blockquote>
<p>Esse mecanismo garante que nÃ£o existirÃ¡ <em>data race</em> simplesmente por mover dados de uma thread para outra, pois somente tipos seguros (ou seja, que nÃ£o tÃªm referÃªncias nÃ£o sincronizadas apontando para dados compartilhados) podem ser movidos entre threads.</p></blockquote>
<p><strong><code>Sync</code>:</strong> Indica que um tipo pode <strong>ser compartilhado</strong> entre threads atravÃ©s de referÃªncias imutÃ¡veis de forma segura. Mais formalmente, um tipo <code>T</code> Ã© <code>Sync</code> se uma referÃªncia imutÃ¡vel <code>&amp;T</code> pode ser enviada para outra thread (ou seja, <code>&amp;T</code> implementa <code>Send</code>). Na prÃ¡tica, se vÃ¡rios threads podem acessar simultaneamente o mesmo dado <strong>sem modificar</strong>, esse tipo Ã© <code>Sync</code>.</p>
<p>Tipos primitivos como nÃºmeros e referÃªncias imutÃ¡veis a qualquer <code>Send</code> tambÃ©m sÃ£o <code>Sync</code> naturalmente, jÃ¡ que lÃª-los simultaneamente nÃ£o causa condiÃ§Ã£o de corrida. Por exemplo, uma referÃªncia imutÃ¡vel (<code>&amp;String</code>) de uma string pode ser compartilhada entre threads diferentes para leitura, se <code>String</code> for <code>Sync</code> (e Ã©, pois vocÃª nÃ£o pode modificÃ¡-la atravÃ©s de uma <code>&amp;String</code>).</p>
<p>O diagrama a seguir representa visualmente a verificaÃ§Ã£o do trait <code>Sync</code>. Temos um dado (representado pela bola com a etiqueta <code>Sync</code>) que vÃ¡rias threads tentam acessar ao mesmo tempo para leitura. O compilador Rust, indicado pelo selo verde de &ldquo;OK seguro para compartilhar&rdquo;, garante que isso sÃ³ Ã© possÃ­vel porque o tipo do dado Ã© <code>Sync</code>. Assim, Thread 1, Thread 2 e Thread 3 conseguem observar (acessar) o mesmo dado simultaneamente sem conflito, pois todas apenas leem o valor, e o compilador certificou-se de que esse acesso concorrente Ã© seguro.</p>


  
  <div class="mermaid">graph TD
    %% Dado (bola) com etiqueta Sync
    Bola([&lt;span style=&#39;font-size:2em&#39;&gt;ğŸ¦€&lt;/span&gt;&lt;br/&gt;Dado&lt;br/&gt;&lt;span style=&#39;background:#bbf7d0;color:#15803d;padding:2px 10px;border-radius:8px&#39;&gt;Sync&lt;/span&gt;])

    %% Threads observando (leitura concorrente)
    Thread1([ğŸ§‘â€ğŸ’»&lt;br/&gt;Thread 1&lt;br/&gt;ğŸ”­])
    Thread2([ğŸ§‘â€ğŸ¨&lt;br/&gt;Thread 2&lt;br/&gt;ğŸ”­])
    Thread3([ğŸ§‘â€ğŸ”¬&lt;br/&gt;Thread 3&lt;br/&gt;ğŸ”­])
    Thread1 -- &#34;ler&#34; --&gt; Bola
    Thread2 -- &#34;ler&#34; --&gt; Bola
    Thread3 -- &#34;ler&#34; --&gt; Bola

    %% Sinal do compilador indicando aprovaÃ§Ã£o
    Sinal([&lt;b style=&#39;background:#d1fae5;color:#166534;padding:8px 18px;border-radius:12px&#39;&gt;âœ… Compilador Rust&lt;br/&gt;Seguro para compartilhar!&lt;/b&gt;])
    Bola --- Sinal

    %% Estilos visuais
    style Bola fill:#f1f5f9,stroke:#22c55e,stroke-width:3px
    style Sinal fill:#d1fae5,stroke:#16a34a,stroke-width:2px
    style Thread1 fill:#f3e8ff,stroke:#7c3aed,stroke-width:2px
    style Thread2 fill:#fee2e2,stroke:#b91c1c,stroke-width:2px
    style Thread3 fill:#fef9c3,stroke:#a16207,stroke-width:2px</div>
 <p>O <code>Send</code> e <code>Sync</code> funcionam como etiquetas de seguranÃ§a verificadas em tempo de compilaÃ§Ã£o. O compilador do Rust age como um fiscal rigoroso: se vocÃª tentar transferir para outra thread um tipo que <strong>nÃ£o</strong> implemente <code>Send</code>, ou se tentar compartilhar entre threads um tipo que <strong>nÃ£o</strong> seja <code>Sync</code>, o compilador emitirÃ¡ um erro de compilaÃ§Ã£o e recusarÃ¡ rodar o programa.</p>
<p>Por exemplo, se vocÃª tentar enviar um ponteiro inteligente <code>Rc&lt;i32&gt;</code> (contador de referÃªncia nÃ£o atÃ´mico) para outra thread, o Rust vai reclamar com um erro parecido com <code>E0277</code>, indicando que aquele tipo nÃ£o implementa <code>Send</code> ou <code>Sync</code>. Isso evita, jÃ¡ na compilaÃ§Ã£o, as chamadas <strong>data races</strong> â€“ situaÃ§Ã£o em que duas threads acessam e modificam o mesmo dado simultaneamente, causando corrupÃ§Ã£o de memÃ³ria ou resultados imprevisÃ­veis.</p>
<p>Para concretizar, veja o caso do <code>Rc&lt;T&gt;</code> abaixo. O tipo <code>Rc</code> (Reference Counted) da biblioteca padrÃ£o <strong>nÃ£o</strong> implementa <code>Send</code> nem <code>Sync</code>. Ele foi projetado apenas para uso em single-thread, pois nÃ£o utiliza travas ou atomicidade para atualizar seu contador de referÃªncias. O diagrama seguinte ilustra o compilador barrando o uso de <code>Rc&lt;i32&gt;</code> em contexto multi-thread: o compilador (representado pelo fiscal) detecta um <code>Rc&lt;i32&gt;</code> sendo compartilhado e imediatamente levanta uma placa de â€œproibidoâ€, impedindo a passagem desse valor para outra thread:</p>


  
  <div class="mermaid">graph LR
    %% Compilador flagra o uso indevido de Rc&lt;i32&gt; entre threads
    Compilador([&#34;ğŸ‘®&lt;br/&gt;Compilador Rust&#34;])
    Sinal([ğŸ”´&lt;br/&gt;Rc&amp;lt;i32&amp;gt;&lt;br/&gt;&lt;span style=&#39;font-size:32px&#39;&gt;âŒ&lt;/span&gt;])
    Placa([&#34;ğŸš« Proibido compartilhar entre threads!&lt;br/&gt;Tipo nÃ£o Ã© Send/Sync&#34;])

    Compilador -- identifica erro --&gt; Sinal
    Sinal -- aviso --&gt; Placa

    style Sinal fill:#e11d48,stroke:#b91c1c,stroke-width:4px,color:#fff
    style Placa fill:#334155,stroke:#334155,stroke-width:3px,color:#fff
    style Compilador fill:#fbbf24,stroke:#a16207,stroke-width:2px</div>
 <p>Acima, o <code>Rc&lt;i32&gt;</code> aparece em vermelho com um &ldquo;X&rdquo;, indicando que falha nos requisitos de seguranÃ§a. O compilador Rust exibe uma placa de aviso proibindo enviar esse tipo para outra thread. Essa imagem traduz visualmente a mensagem de erro que o Rust daria nesse caso, reforÃ§ando: se um tipo nÃ£o for seguro para uso concorrente, o Rust nem permite compilar o cÃ³digo que tentasse fazÃª-lo, garantindo assim a seguranÃ§a em <em>tempo de compilaÃ§Ã£o</em>.</p>
<h2 id="quando-o-rc-falha-entra-o-arc">Quando o <code>Rc</code> falha, entra o <code>Arc</code>!</h2>
<p>Como vimos, <code>Rc&lt;T&gt;</code> nÃ£o pode ser usado entre threads diferentes. EntÃ£o, o que fazer se vocÃª <strong>precisa</strong> compartilhar dados entre vÃ¡rias threads? A resposta do Rust Ã© usar <strong><code>Arc&lt;T&gt;</code></strong> â€“ que significa <em>Atomic Reference Counted</em>. O <code>Arc</code> Ã© uma variante do <code>Rc</code> projetada para ambientes concorrentes: ele realiza a contagem de referÃªncias de forma <strong>atÃ´mica</strong>, isto Ã©, usando instruÃ§Ãµes de hardware que garantem atualizaÃ§Ã£o consistente mesmo quando mÃºltiplas threads tentam incrementar ou decrementar o contador ao mesmo tempo.</p>
<blockquote>
<p>GraÃ§as a essa sincronizaÃ§Ã£o interna, <code>Arc&lt;T&gt;</code> implementa <code>Send</code> e <code>Sync</code> (desde que o tipo <code>T</code> contido tambÃ©m seja seguro para enviar/compartilhar). Em termos simples, vocÃª pode imaginar o <code>Arc</code> como um <code>Rc</code> com colete Ã  prova de balas para threads: ele faz o mesmo trabalho de compartilhar posse de um valor, sÃ³ que de forma segura em ambientes multi-thread.</p></blockquote>
<p><strong>Exemplo de uso:</strong> Suponha que vocÃª tinha um <code>Rc&lt;Algo&gt;</code> no seu cÃ³digo single-thread e quer portar para multi-thread. Basta trocar para <code>Arc&lt;Algo&gt;</code>. Assim, diferentes threads podem possuir clones do <code>Arc</code> apontando para o mesmo dado. O compilador, que antes bloqueava o <code>Rc</code>, agora vai permitir o <code>Arc</code> porque reconhece que ele Ã© thread-safe. Internamente, cada incremento ou decremento no contador de referÃªncias do <code>Arc</code> Ã© feito atomicamente (isso tem um pequeno custo de desempenho em comparaÃ§Ã£o ao <code>Rc</code>, mas garante a seguranÃ§a). Portanto, use <code>Arc</code> somente quando for realmente necessÃ¡rio compartilhar dados entre threads; se o seu cÃ³digo Ã© single-thread ou nÃ£o precisa dividir posse de dados, prefira <code>Rc</code> pelo menor overhead.</p>
<p>No diagrama abaixo, visualizamos o funcionamento seguro do <code>Arc</code>. A caixa maior representa um valor protegido por <code>Arc&lt;T&gt;</code>, ostentando os selos <code>Send</code> e <code>Sync</code> (porque <code>Arc</code> implementa essas traits quando o conteÃºdo Ã© apropriado). O compilador Rust (novamente como fiscal) confere e <strong>aprova</strong> o uso do <code>Arc</code>, permitindo que vÃ¡rias threads tenham acesso ao dado.</p>
<p>Cada thread estÃ¡ conectada Ã  caixa por uma espÃ©cie de corda, ilustrando que elas compartilham a posse daquele mesmo valor por meio de referÃªncias do tipo <code>Arc&lt;T&gt;</code>. Em contraste, ao lado, um caixote menor rotulado <code>Rc</code> com um &ldquo;X&rdquo; vermelho lembra que <code>Rc</code> nÃ£o pode fazer isso â€“ ele serve apenas para uma thread Ãºnica. A comparaÃ§Ã£o destaca que, em cenÃ¡rio multi-thread, deve-se usar <code>Arc</code> no lugar de <code>Rc</code>.</p>


  
  <div class="mermaid">graph TD
    %% Caixa representando Arc&lt;T&gt; com etiquetas Send e Sync
    ArcBox([&#34;Arc&lt;T&gt;&lt;br/&gt;&lt;span style=&#39;background:#bae6fd;color:#0369a1;padding:1px 8px;border-radius:8px&#39;&gt;Send&lt;/span&gt; &lt;span style=&#39;background:#bbf7d0;color:#15803d;padding:1px 8px;border-radius:8px&#39;&gt;Sync&lt;/span&gt;&#34;])

    %% Sinal de aprovado do compilador Rust
    Aprovado([&#34;âœ…&lt;br/&gt;Compilador Rust&lt;br/&gt;Aprovado&#34;])
    ArcBox -- &#34;verificaÃ§Ã£o&#34; --&gt; Aprovado

    %% MÃºltiplas threads conectadas ao mesmo Arc&lt;T&gt;
    Thread1([&#34;ğŸ§‘â€ğŸ’»&lt;br/&gt;Thread 1&#34;])
    Thread2([&#34;ğŸ§‘â€ğŸš€&lt;br/&gt;Thread 2&#34;])
    Thread3([&#34;ğŸ§‘â€ğŸ”¬&lt;br/&gt;Thread 3&#34;])
    Thread4([&#34;ğŸ§‘â€ğŸ¨&lt;br/&gt;Thread 4&#34;])
    Thread1 -- &#34;possui ref&#34; --&gt; ArcBox
    Thread2 -- &#34;possui ref&#34; --&gt; ArcBox
    Thread3 -- &#34;possui ref&#34; --&gt; ArcBox
    Thread4 -- &#34;possui ref&#34; --&gt; ArcBox

    %% Caixa menor representando Rc com X (uso apenas single-thread)
    RcBox([&#34;Rc&lt;T&gt;&lt;br/&gt;&lt;span style=&#39;color:#b91c1c;font-size:2em&#39;&gt;âŒ&lt;/span&gt;&lt;br/&gt;&lt;span style=&#39;font-size:0.8em&#39;&gt;sÃ³ 1 thread&lt;/span&gt;&#34;])
    ArcBox -. comparativo .-&gt; RcBox

    %% Estilos para distinÃ§Ã£o visual
    style ArcBox fill:#f1f5f9,stroke:#0284c7,stroke-width:3px
    style RcBox fill:#fee2e2,stroke:#b91c1c,stroke-width:2px
    style Aprovado fill:#d1fae5,stroke:#10b981,stroke-width:2px
    style Thread1 fill:#fff7ed,stroke:#fbbf24,stroke-width:2px
    style Thread2 fill:#f3e8ff,stroke:#a21caf,stroke-width:2px
    style Thread3 fill:#e0f2fe,stroke:#0284c7,stroke-width:2px
    style Thread4 fill:#f0fdf4,stroke:#22c55e,stroke-width:2px</div>
 <p>No diagrama, vemos claramente que o <code>Arc&lt;T&gt;</code> permite mÃºltiplas threads acessando o mesmo dado: cada thread segura uma &ldquo;corda&rdquo; ligada Ã  caixa <code>Arc&lt;T&gt;</code>, simbolizando um ponteiro compartilhado. O compilador dÃ¡ o sinal verde (âœ…) para essa configuraÃ§Ã£o. JÃ¡ o <code>Rc</code> aparece riscado em vermelho ao lado, indicando que ele ficaria de fora numa situaÃ§Ã£o de threads concorrentes. Em suma, quando <code>Rc</code> falha por nÃ£o ser <code>Send/Sync</code>, o <code>Arc</code> entra como a alternativa segura, embora com um custo de desempenho um pouco maior devido ao uso de operaÃ§Ãµes atÃ´micas para manter a contagem de referÃªncias consistente entre threads.</p>
<h2 id="outros-ajudantes-para-threads">Outros ajudantes para threads</h2>
<p>AlÃ©m de <code>Arc</code>, o Rust oferece vÃ¡rias estruturas na biblioteca padrÃ£o para garantir seguranÃ§a e sincronizaÃ§Ã£o ao compartilhar ou trocar dados entre threads. Cada uma serve a propÃ³sitos diferentes, e escolher a ferramenta correta ajuda a manter seu cÃ³digo conciso e seguro:</p>
<p><strong><code>Mutex&lt;T&gt;</code>:</strong> Mutual Exclusion (exclusÃ£o mÃºtua). Um <code>Mutex</code> Ã© essencialmente um cadeado que protege um dado do tipo <code>T</code>. Apenas uma thread por vez pode adquirir o lock (trancar o mutex) e acessar ou modificar o valor dentro do <code>Mutex</code>. Enquanto uma thread estÃ¡ com o cadeado, as outras que tentarem acessÃ¡-lo vÃ£o esperar. Isso previne que duas threads alterem o mesmo dado simultaneamente.</p>
<p>O <code>Mutex&lt;T&gt;</code> implementa <code>Send</code> e <code>Sync</code> <em>desde que</em> <code>T</code> seja <code>Send</code> â€“ ou seja, vocÃª pode enviar um <code>Mutex</code> para outra thread ou compartilhar sua referÃªncia, contanto que o conteÃºdo tambÃ©m possa ser enviado com seguranÃ§a. Quando uma thread termina de usar o dado e libera o cadeado, outra thread pode entÃ£o adquiri-lo e acessar o dado. Em resumo, Ã© como uma porta com fechadura: sÃ³ um pode entrar de cada vez.</p>
<p><strong><code>RwLock&lt;T&gt;</code>:</strong> Leitura/Escrita com bloqueio. Ã‰ parecido com um <code>Mutex</code>, mas mais flexÃ­vel em termos de acesso concorrente. Um <code>RwLock</code> (Read-Write Lock) permite que vÃ¡rias threads adquiram simultaneamente um <em>lock</em> de leitura imutÃ¡vel para inspecionar o dado (vÃ¡rias pessoas podem ler um livro ao mesmo tempo, se nenhuma estiver escrevendo nele). PorÃ©m, se alguma thread precisar escrever/modificar o valor, ela deve adquirir um <em>lock</em> de escrita exclusivo â€“ e enquanto a escrita nÃ£o terminar, nenhuma outra thread pode acessar (nem para ler nem para escrever).</p>
<blockquote>
<p>Em termos de thread safety, um <code>RwLock&lt;T&gt;</code> Ã© <code>Sync</code> (se <code>T</code> for <code>Send</code>), pois mÃºltiplas threads podem ter referÃªncias de leitura simultaneamente com seguranÃ§a garantida pelo mecanismo de lock interno. Use <code>RwLock</code> quando o padrÃ£o de acesso for muitas leituras e poucas escritas, pois assim vocÃª evita bloquear leitores entre si desnecessariamente.</p></blockquote>
<p><strong>Tipos AtÃ´micos (<code>AtomicBool</code>, <code>AtomicUsize</code>, etc.):</strong> Esses sÃ£o tipos primitivos especializados que suportam operaÃ§Ãµes atÃ´micas de forma segura entre threads, sem necessidade de um mutex. Por exemplo, um <code>AtomicUsize</code> Ã© como um nÃºmero inteiro cujo incremento, decremento ou comparaÃ§Ã£o sÃ£o feitas de modo <em>atÃ´mico</em> (indivisÃ­vel), garantindo que duas threads nÃ£o consigam interferir uma na outra nessas operaÃ§Ãµes. Os tipos atÃ´micos implementam <code>Sync</code> e <code>Send</code> (sÃ£o projetados para uso thread-safe intrÃ­nseco) e costumam ser muito eficientes para casos simples, como contadores, flags booleanas ou Ã­ndices compartilhados. PorÃ©m, eles sÃ³ funcionam para dados simples (geralmente nÃºmeros ou ponteiros).</p>
<blockquote>
<p>Pense neles como variÃ¡veis globais thread-safe que utilizam instruÃ§Ãµes de hardware para sincronizaÃ§Ã£o. Por exemplo, um <code>AtomicBool</code> pode ser usado para um â€œflagâ€ que vÃ¡rias threads verificam e definem sem precisar de trava.</p></blockquote>
<p><strong>Canais de Mensagem (ex: <code>std::sync::mpsc</code>):</strong> Em muitos casos, a forma mais fÃ¡cil e segura de coordenar threads Ã© <strong>nÃ£o compartilhar</strong> diretamente a posse de dados, mas sim mandar mensagens de uma thread para outra. O mÃ³dulo <code>mpsc</code> (multiple producer, single consumer) fornece canais de comunicaÃ§Ã£o pelo qual vocÃª pode <strong>enviar</strong> valores de um thread (produtor) e recebÃª-los em outro thread (consumidor).</p>
<p>Pense em um canal como uma esteira transportadora ou uma fila: em vez de duas threads acessarem o mesmo objeto em memÃ³ria, a thread A envia uma cÃ³pia ou propriedade do dado para a thread B processar. Assim, evita-se completamente condiÃ§Ãµes de corrida, jÃ¡ que cada dado sÃ³ Ã© possuÃ­do por uma thread de cada vez (transferido pelo canal). Os canais sÃ£o excelentes para designs baseados em passagem de mensagens (similar ao modelo do Erlang ou Go) e muitas vezes simplificam a sincronizaÃ§Ã£o, pois nÃ£o requerem locks manuais. O diagrama a seguir ilustra essas diferentes ferramentas de sincronizaÃ§Ã£o de forma visual:</p>


  
  <div class="mermaid">graph TD
    %% Mutex representado como um dado trancado por cadeado
    Mutex[&#34;ğŸ”’ Mutex&lt;T&gt;&lt;br/&gt;(exclusÃ£o Ãºnica)&#34;]
    
    %% RwLock representado como uma estante de livros com mÃºltiplos leitores
    RwLock[&#34;RwLock&lt;T&gt;&lt;br/&gt;(vÃ¡rias leituras, uma escrita)&#34;]
    Livro1[&#34;ğŸ“– Dado&#34;]
    Livro2[&#34;ğŸ“– Dado&#34;]
    Livro3[&#34;ğŸ“– Dado&#34;]
    Leitor1[&#34;ğŸ§‘â€ğŸ“ Thread lendo&#34;]
    Leitor2[&#34;ğŸ§‘â€ğŸ’¼ Thread lendo&#34;]
    Leitor3[&#34;ğŸ§‘â€ğŸ¨ Thread lendo&#34;]
    Leitor1 -- &#34;lÃª&#34; --&gt; Livro1
    Leitor2 -- &#34;lÃª&#34; --&gt; Livro2
    Leitor3 -- &#34;lÃª&#34; --&gt; Livro3
    RwLock --&gt; Livro1
    RwLock --&gt; Livro2
    RwLock --&gt; Livro3

    %% Canal: esteira transportadora de caixas (mensagens) da Thread A para Thread B
    ThreadA[&#34;ğŸ§‘â€ğŸ’» Thread A&#34;]
    ThreadB[&#34;ğŸ§‘â€ğŸ”§ Thread B&#34;]
    Esteira[&#34;Canal de Mensagens&lt;br/&gt;ğŸ“¦â†’ğŸ“¦â†’ğŸ“¦&#34;]
    ThreadA -- &#34;envia dado&#34; --&gt; Esteira
    Esteira -- &#34;recebe dado&#34; --&gt; ThreadB
    
    %% Layout / separaÃ§Ãµes
    Mutex --- RwLock
    RwLock --- Esteira
    style Mutex fill:#c7d2fe,stroke:#4338ca,stroke-width:3px
    style Esteira fill:#dcfce7,stroke:#22c55e,stroke-width:2px
    style ThreadA fill:#fee2e2,stroke:#b91c1c,stroke-width:2px
    style ThreadB fill:#fef9c3,stroke:#ca8a04,stroke-width:2px
    style RwLock fill:#f1f5f9,stroke:#0ea5e9,stroke-width:2px
    style Livro1 fill:#f1f5f9,stroke:#0ea5e9,stroke-width:1px
    style Livro2 fill:#f1f5f9,stroke:#0ea5e9,stroke-width:1px
    style Livro3 fill:#f1f5f9,stroke:#0ea5e9,stroke-width:1px
    style Leitor1 fill:#f1f5f9,stroke:#0ea5e9,stroke-width:1px
    style Leitor2 fill:#f1f5f9,stroke:#0ea5e9,stroke-width:1px
    style Leitor3 fill:#f1f5f9,stroke:#0ea5e9,stroke-width:1px</div>
 <p>Na imagem acima, cada componente ilustra um mecanismo diferente de gerenciar concorrÃªncia:</p>
<ul>
<li>
<p>O <strong>Mutex</strong> (Ã  esquerda) aparece como uma caixa com um cadeado, indicando que o conteÃºdo estÃ¡ protegido e apenas uma thread por vez pode acessar. Imagine que uma thread tenha a chave do cadeado: enquanto ela estiver usando o recurso dentro do <code>Mutex</code>, nenhuma outra entra. Quando termina, ela libera o cadeado para outra thread poder usar.</p>
</li>
<li>
<p>O <strong>RwLock</strong> (centro) Ã© mostrado como uma estante de livros onde vÃ¡rias threads (pessoas) leem em paralelo. Isso representa que vÃ¡rias threads podem ter acesso de leitura simultaneamente ao dado. Se alguma delas precisasse escrever, terÃ­amos que â€œfechar a estanteâ€ para todos os leitores e dar acesso exclusivo ao escritor (no diagrama nÃ£o tem um escritor desenhado, mas essa Ã© a ideia). SÃ³ depois de terminar a escrita Ã© que outros leitores podem pegar os livros novamente. Assim funciona o <code>RwLock</code>: mÃºltiplos leitores ou um Ãºnico escritor de cada vez.</p>
</li>
<li>
<p>O <strong>Canal</strong> (Ã  direita) Ã© simbolizado por uma esteira transportadora passando caixas da Thread A para a Thread B. Cada caixa seria uma mensagem ou dado sendo transferido. Note que a Thread B recebe a caixa inteira â€“ ou seja, ela agora tem posse daquele dado, e a Thread A nÃ£o precisa mais acessÃ¡-lo. Isso evita compartilhamento simultÃ¢neo. Na prÃ¡tica, usar canais Ã© uma forma de <strong>transferir</strong> dados entre threads em vez de compartilhÃ¡-los, o que elimina a necessidade de locks e simplifica muito o raciocÃ­nio (nÃ£o tem duas threads brigando pelo mesmo dado, uma entregou para a outra processar).</p>
</li>
</ul>
<p>E os tipos <strong>AtÃ´micos</strong> (<code>AtomicUsize</code>, <code>AtomicBool</code>, etc.)? Eles nÃ£o estÃ£o ilustrados explicitamente no diagrama, mas podemos imaginar um cenÃ¡rio simples: se quisÃ©ssemos representar um contador atÃ´mico, poderÃ­amos desenhar um contador cujo valor vÃ¡rias threads podem incrementar sem conflitos.</p>
<blockquote>
<p>O ponto-chave Ã© que uma operaÃ§Ã£o atÃ´mica age como se tivesse um mini-lock invisÃ­vel embutido em nÃ­vel de hardware apenas para aquele valor, garantindo que, por exemplo, duas threads incrementando um contador ao mesmo tempo nÃ£o causem erro (cada incremento serÃ¡ realizado completamente um apÃ³s o outro, mesmo sem um mutex explÃ­cito no cÃ³digo). Por isso, no texto do diagrama mencionamos &ldquo;Atomic*&rdquo; ao lado do Mutex e do RwLock: os tipos atÃ´micos sÃ£o outra ferramenta na caixa de ferramentas do Rust para garantir seguranÃ§a, mas aplicados a casos especÃ­ficos de variÃ¡veis simples.</p></blockquote>
<h2 id="mutabilidade-interior-e-o-sync">Mutabilidade interior e o <code>Sync</code></h2>
<p>AtÃ© agora falamos de acesso concorrente a dados considerando que as referÃªncias compartilhadas sÃ£o imutÃ¡veis (exceto quando usamos locks para mutar). Entretanto, o Rust possui tipos especiais que permitem modificar um valor mesmo atravÃ©s de referÃªncias imutÃ¡veis â€“ Ã© o chamado <strong>interior mutability</strong> (mutabilidade interna).</p>
<p>Esses tipos usam artifÃ­cios como operaÃ§Ãµes nÃ£o seguras (<em>unsafe</em>) ou checagens em tempo de execuÃ§Ã£o para contornar as restriÃ§Ãµes usualmente impostas pelo sistema de emprÃ©stimo do Rust. Exemplos incluem <code>Cell&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code>. Embora sejam muito Ãºteis em contextos de single-thread (permitindo mutaÃ§Ã£o onde o compilador normalmente nÃ£o deixaria, como dentro de um <code>&amp;T</code>), eles trazem implicaÃ§Ãµes para o mundo multi-thread.</p>
<p>Em termos de <code>Send</code> e <code>Sync</code>, a <strong>regra geral</strong> Ã©: se um tipo permite <em>interior mutability</em> sem garantir sincronizaÃ§Ã£o entre threads, ele <strong>nÃ£o serÃ¡ <code>Sync</code></strong>. O motivo Ã© claro â€“ se vÃ¡rias threads acessassem simultaneamente um mesmo objeto que pode mudar internamente de forma nÃ£o sincronizada, terÃ­amos uma condiÃ§Ã£o de corrida. Vamos aos casos comuns:</p>
<ul>
<li><strong><code>Cell&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code>:</strong> nÃ£o sÃ£o <code>Sync</code>. VocÃª nÃ£o pode compartilhar referÃªncias a um <code>Cell</code> ou <code>RefCell</code> entre threads ao mesmo tempo, nem mesmo sÃ³ para leitura, porque internamente eles permitem modificaÃ§Ãµes ou verificaÃ§Ãµes de emprÃ©stimo que nÃ£o sÃ£o protegidas contra acesso concorrente. O <code>RefCell</code> em particular realiza checagens de emprÃ©stimo em tempo de execuÃ§Ã£o (panica se violar regras de referÃªncia Ãºnica mutÃ¡vel ou mÃºltiplas imutÃ¡veis), mas essas checagens nÃ£o sÃ£o implementadas para funcionar com mÃºltiplas threads â€“ sÃ£o apenas dentro de uma Ãºnica thread.</li>
</ul>
<p>Portanto, o compilador marca esses tipos como nÃ£o <code>Sync</code> exatamente para prevenir que alguÃ©m tente compartilhÃ¡-los entre threads (seria inseguro). Inclusive, <code>RefCell</code> e <code>Cell</code> tambÃ©m nÃ£o implementam <code>Send</code> se o tipo contido nÃ£o for <code>Copy</code>, porque mover eles para outra thread poderia quebrar invariantes de emprÃ©stimo pendentes.</p>
<ul>
<li>
<p><strong>Tipos AtÃ´micos (<code>AtomicX</code>):</strong> sÃ£o <code>Sync</code>. Apesar de permitirem mutaÃ§Ã£o interna (vocÃª pode alterar o valor atÃ´mico atravÃ©s de uma referÃªncia compartilhada, jÃ¡ que os mÃ©todos deles recebem <code>&amp;self</code> em vez de <code>&amp;mut self</code>), eles fazem isso de forma segura para threads, utilizando instruÃ§Ãµes atÃ´micas. Assim, vocÃª pode ter mÃºltiplas threads segurando referÃªncias ao mesmo <code>AtomicUsize</code>, por exemplo, e realizando operaÃ§Ãµes nele concorrentemente, que estarÃ¡ tudo bem â€“ nÃ£o haverÃ¡ data race. Por isso, os atÃ´micos implementam <code>Sync</code> (e <code>Send</code> tambÃ©m).</p>
</li>
<li>
<p><strong><code>Mutex&lt;T&gt;</code> e <code>RwLock&lt;T&gt;</code>:</strong> tambÃ©m sÃ£o <code>Sync</code> (desde que <code>T</code> seja <code>Send</code>). Parece contra-intuitivo Ã  primeira vista, pois tanto o <code>Mutex</code> quanto o <code>RwLock</code> permitem mudanÃ§a do valor interno mesmo atravÃ©s de uma referÃªncia imutÃ¡vel ao lock (por exemplo, vocÃª pode chamar <code>lock()</code> em um <code>&amp;Mutex&lt;T&gt;</code> e entÃ£o obter um <code>&amp;mut T</code>). Contudo, a diferenÃ§a Ã© que essa mutaÃ§Ã£o interna estÃ¡ <em>sincronizada</em> por mecanismos de lock.</p>
</li>
</ul>
<p>Ou seja, se duas threads tiverem referÃªncias (imutÃ¡veis) ao mesmo <code>Mutex&lt;T&gt;</code>, quando uma thread entrar no lock, a outra ficarÃ¡ esperando, garantindo exclusÃ£o mÃºtua. Assim, o <code>Mutex</code> em si pode ser compartilhado entre threads (<code>Sync</code>) com seguranÃ§a, pois evita acesso simultÃ¢neo ao interior. O mesmo vale para <code>RwLock</code>: vÃ¡rias threads podem compartilhar um <code>&amp;RwLock&lt;T&gt;</code>; internamente o lock gerencia quem pode ler ou escrever de cada vez, mantendo a seguranÃ§a.</p>
<p>O diagrama abaixo exemplifica a diferenÃ§a de comportamento entre um tipo com mutabilidade interna <strong>nÃ£o</strong> segura (<code>Cell</code>) e um tipo atÃ´mico que fornece mutabilidade interna <strong>segura</strong>:</p>


  
  <div class="mermaid">graph TD
    %% Caixa Cell com um X vermelho indicando nÃ£o Sync
    Cell([&#34;Cell&lt;i32&gt;&lt;br/&gt;&lt;span style=&#39;color:#b91c1c;font-size:2em&#39;&gt;âŒ&lt;/span&gt;&lt;br/&gt;&lt;span style=&#39;font-size:0.8em&#39;&gt;nÃ£o Sync&lt;/span&gt;&#34;])
    
    %% Caixa AtomicUsize com sinal verde indicando Sync
    Atomic([&#34;AtomicUsize&lt;br/&gt;&lt;span style=&#39;color:#16a34a;font-size:2em&#39;&gt;âœ…&lt;/span&gt;&lt;br/&gt;&lt;span style=&#39;font-size:0.8em&#39;&gt;Sync&lt;/span&gt;&#34;])

    %% Threads tentando acessar o Cell simultaneamente
    Thread1([ğŸ§‘â€ğŸ’» Thread 1])
    Thread2([ğŸ§‘â€ğŸ¨ Thread 2])
    Thread3([ğŸ§‘â€ğŸ”¬ Thread 3])
    Thread1 -- &#34;acesso?&#34; --&gt; Cell
    Thread2 -- &#34;acesso?&#34; --&gt; Cell
    Thread3 -- &#34;acesso?&#34; --&gt; Cell

    %% Compilador bloqueia acesso ao Cell entre threads
    Compilador([ğŸ‘® Compilador Rust])
    Compilador -. &#34;erro: !Sync&#34; .- Cell
    
    %% As mesmas threads acessando AtomicUsize (permitido)
    Thread1 -- &#34;acessa&#34; --&gt; Atomic
    Thread2 -- &#34;acessa&#34; --&gt; Atomic
    Thread3 -- &#34;acessa&#34; --&gt; Atomic

    %% Estilos dos nÃ³s para visual
    style Cell fill:#fee2e2,stroke:#b91c1c,stroke-width:2px
    style Atomic fill:#dcfce7,stroke:#22c55e,stroke-width:2px
    style Compilador fill:#fef9c3,stroke:#ca8a04,stroke-width:2px
    style Thread1 fill:#f1f5f9,stroke:#0369a1,stroke-width:2px
    style Thread2 fill:#f3e8ff,stroke:#7c3aed,stroke-width:2px
    style Thread3 fill:#f0fdf4,stroke:#22c55e,stroke-width:2px</div>
 <p>No diagrama, o <code>Cell&lt;i32&gt;</code> aparece marcado com um X vermelho e a indicaÃ§Ã£o de que nÃ£o Ã© <code>Sync</code>. As trÃªs threads 1, 2 e 3 tentam acessÃ¡-lo simultaneamente, mas o compilador (o &ldquo;guarda&rdquo; representado) impede isso, gerando um erro em tempo de compilaÃ§Ã£o. JÃ¡ do lado direito, temos um <code>AtomicUsize</code> marcado com âœ… (pois Ã© <code>Sync</code>): as trÃªs threads conseguem acessÃ¡-lo &ldquo;normalmente&rdquo; ao mesmo tempo. Essa figura ajuda a fixar que tipos com mutabilidade interna sÃ³ serÃ£o considerados seguros para compartilhamento (<code>Sync</code>) se incluÃ­rem mecanismos internos de sincronizaÃ§Ã£o. Caso contrÃ¡rio, o Rust proÃ­be seu uso simultÃ¢neo entre threads, prevenindo possÃ­veis condiÃ§Ãµes de corrida.</p>
<h2 id="dica-de-ouro">Dica de ouro</h2>
<p>Diante de tantas ferramentas de concorrÃªncia, pode surgir a dÃºvida: <strong>qual usar e quando?</strong> Uma dica de ouro para projetar programas multi-thread em Rust (e em geral) Ã© preferir a soluÃ§Ã£o mais simples que atenda ao seu caso de uso, privilegiando a transferÃªncia de dados entre threads em vez de compartilhamento, sempre que possÃ­vel. Em termos prÃ¡ticos:</p>
<ul>
<li>
<p><strong>Prefira usar canais (<code>mpsc</code>) para comunicar threads</strong> sempre que isso fizer sentido. Mandar mensagens evita muitos dos problemas de sincronizaÃ§Ã£o porque, ao transferir a posse de um dado de uma thread para outra, vocÃª nÃ£o precisa lidar com locks naquele dado especÃ­fico â€“ a lÃ³gica passa a ser &ldquo;um produtor envia, um consumidor recebe&rdquo;. Muitas vezes dÃ¡ para estruturar o programa de forma que threads trabalhem em pipeline (cada uma fazendo uma parte do trabalho e passando resultados adiante), o que Ã© naturalmente seguro e fÃ¡cil de entender.</p>
</li>
<li>
<p>Se realmente for necessÃ¡rio que vÃ¡rias threads acessem o <strong>mesmo dado</strong> (por exemplo, um cache compartilhado, um contador global, ou uma configuraÃ§Ã£o global que vÃ¡rias threads leem), escolha a estrutura apropriada:</p>
<ul>
<li>Para <strong>contadores simples ou flags booleanas</strong>, considere usar os tipos <strong>AtÃ´micos</strong>. Eles sÃ£o leves e muito eficientes para esses propÃ³sitos especÃ­ficos.</li>
<li>Para estruturas de dados mais complexas que muitas threads precisam <strong>ler frequentemente e raramente escrever</strong>, um <strong><code>RwLock&lt;T&gt;</code></strong> pode oferecer melhor desempenho, pois permite mÃºltiplas leituras simultÃ¢neas.</li>
<li>Para casos em que pode haver necessidade de <strong>escrita frequente ou acesso exclusivo</strong>, um <strong><code>Mutex&lt;T&gt;</code></strong> simples pode ser mais adequado, garantindo que apenas uma thread por vez modifique ou leia o dado protegido (Ã s vezes um Mutex acaba sendo suficiente e mais simples do que um RwLock, dependendo do padrÃ£o de acesso).</li>
</ul>
</li>
<li>
<p><strong>Evite compartilhar desnecessariamente.</strong> Muitas vezes, duplicar alguns dados para cada thread ou organizar seu programa para minimizar compartilhamento pode eliminar a necessidade de sincronizaÃ§Ã£o complexa. Lembre-se: dados que estÃ£o confinados a uma Ãºnica thread nÃ£o precisam de <code>Arc</code> ou <code>Mutex</code> â€“ eles podem ser usados livremente. Use mecanismos de compartilhamento apenas quando o design exigir realmente acesso concorrente ao mesmo recurso.</p>
</li>
</ul>
<p>A grande vantagem do Rust Ã© que ele atua como um guardiÃ£o em tempo de compilaÃ§Ã£o. Se vocÃª seguir as regras e usar essas ferramentas, o compilador vai <strong>impedir</strong> que vocÃª cometa enganos como esquecer de proteger um dado compartilhado. Por exemplo, se tentar compartilhar um tipo que nÃ£o seja <code>Sync</code> sem proteÃ§Ã£o, nÃ£o compila; se tentar enviar um tipo nÃ£o <code>Send</code> para outra thread, nÃ£o compila.</p>
<p>Assim, boa parte dos problemas de concorrÃªncia sÃ£o pegos antes mesmo de rodar o programa. O desenvolvedor fica entÃ£o livre para se concentrar no <em>design</em> da sincronizaÃ§Ã£o (como dividir tarefas, onde realmente precisa de compartilhamento etc.), e nÃ£o em caÃ§ar <em>race conditions</em> na depuraÃ§Ã£o.</p>
<p>Para visualizar essa ideia, o diagrama a seguir mostra uma â€œestradaâ€ hipotÃ©tica onde threads trafegam. As threads que carregam apenas dados marcados como <code>Send</code>/<code>Sync</code> recebem sinal verde do &ldquo;Guarda (compilador) Rust&rdquo; e podem prosseguir. JÃ¡ as threads que tentam carregar algo como um <code>Rc</code> ou um <code>Cell</code> (que nÃ£o sÃ£o seguras para multiplas threads) sÃ£o barradas pelo compilador â€“ nÃ£o podem entrar na via de multi-threading.</p>
<p>Somente apÃ³s resolver isso (por exemplo, trocando <code>Rc</code> por <code>Arc</code>, ou removendo o <code>Cell</code> ou encapsulando em um <code>Mutex</code>) o compilador permitirÃ¡ o trÃ¡fego. Essa metÃ¡fora reforÃ§a: siga a sinalizaÃ§Ã£o (as traits) que o Rust providencia, e vocÃª evitarÃ¡ acidentes na estrada da concorrÃªncia!</p>


  
  <div class="mermaid">graph TD
    %% Threads representadas por carros com &#34;placas&#34; indicando seus dados
    Carro1([ğŸš—&lt;br/&gt;Thread 1&lt;br/&gt;&lt;span style=&#39;background:#d1fae5;color:#166534;padding:2px 7px;border-radius:6px&#39;&gt;Send&lt;/span&gt; &lt;span style=&#39;background:#d1fae5;color:#166534;padding:2px 7px;border-radius:6px&#39;&gt;Sync&lt;/span&gt;])
    Carro2([ğŸš™&lt;br/&gt;Thread 2&lt;br/&gt;&lt;span style=&#39;background:#fee2e2;color:#b91c1c;padding:2px 7px;border-radius:6px&#39;&gt;Rc&lt;/span&gt;])
    Carro3([ğŸš•&lt;br/&gt;Thread 3&lt;br/&gt;&lt;span style=&#39;background:#fee2e2;color:#b91c1c;padding:2px 7px;border-radius:6px&#39;&gt;Cell&lt;/span&gt;])
    Carro4([ğŸš“&lt;br/&gt;Thread 4&lt;br/&gt;&lt;span style=&#39;background:#d1fae5;color:#166534;padding:2px 7px;border-radius:6px&#39;&gt;Send&lt;/span&gt; &lt;span style=&#39;background:#d1fae5;color:#166534;padding:2px 7px;border-radius:6px&#39;&gt;Sync&lt;/span&gt;])

    %% Estrada representando o caminho para execuÃ§Ã£o multi-thread
    Estrada([ğŸ›£ï¸&lt;br/&gt;ExecuÃ§Ã£o concorrente segura])
    
    %% Guarda (compilador) verificando as &#34;placas&#34; dos carros (traits)
    Guarda([ğŸ‘®&lt;br/&gt;Compilador Rust&lt;br/&gt;Checagem&lt;br/&gt;Send/Sync])

    %% Fluxo: Carros com dados seguros passam, inseguros sÃ£o barrados
    Carro1 -- &#34;pode prosseguir&#34; --&gt; Estrada
    Carro4 -- &#34;pode prosseguir&#34; --&gt; Estrada
    Carro2 -- &#34;barrado&#34; --&gt; Guarda
    Carro3 -- &#34;barrado&#34; --&gt; Guarda
    Guarda -- &#34;apenas tipos seguros passam&#34; --&gt; Estrada

    %% EstilizaÃ§Ã£o visual
    style Estrada fill:#f1f5f9,stroke:#6366f1,stroke-width:4px
    style Guarda fill:#fef9c3,stroke:#ca8a04,stroke-width:2px
    style Carro1 fill:#dcfce7,stroke:#22c55e,stroke-width:2px
    style Carro2 fill:#fee2e2,stroke:#b91c1c,stroke-width:2px
    style Carro3 fill:#fef9c3,stroke:#a16207,stroke-width:2px
    style Carro4 fill:#dcfce7,stroke:#22c55e,stroke-width:2px</div>
 <h2 id="cuidado-com-o-unsafe">Cuidado com o <code>unsafe</code></h2>
<p>Todas as garantias que discutimos sobre <code>Send</code> e <code>Sync</code> se aplicam apenas ao cÃ³digo Rust <strong>seguro</strong> (safe). Ou seja, quando vocÃª programa sem recorrer a <code>unsafe</code>, pode contar que o compilador nÃ£o vai deixar passar nenhuma violaÃ§Ã£o das regras de thread safety estabelecidas pelos traits. <strong>PorÃ©m</strong>, o Rust tambÃ©m permite, em casos necessÃ¡rios, utilizar cÃ³digo marcado como <code>unsafe</code> para realizar operaÃ§Ãµes que fogem Ã  verificaÃ§Ã£o normal do compilador.</p>
<p>Isso inclui implementar manualmente traits como <code>Send</code> e <code>Sync</code> para seus prÃ³prios tipos. Ao fazer isso, vocÃª estÃ¡ dizendo ao Rust: &ldquo;Confie em mim, eu garanto que isto Ã© seguro&rdquo;. A partir desse ponto, a responsabilidade Ã© toda sua â€“ se estiver enganado, as consequÃªncias podem ser graves (comportamento indefinido, crashes, corrupÃ§Ã£o de memÃ³ria etc.).</p>
<p>Portanto, use <code>unsafe</code> com extrema cautela, especialmente no contexto de concorrÃªncia. SÃ³ deve-se implementar <code>Send</code> ou <code>Sync</code> manualmente (via <code>unsafe impl</code>) se vocÃª tiver absoluta certeza do que estÃ¡ fazendo. Um exemplo real foi o caso de uma biblioteca (crate) que fez um <code>unsafe impl Send</code> para um tipo que na verdade nÃ£o era seguro para threads, resultando em travamentos e comportamento incorreto quando usado em cenÃ¡rios concorrentes.</p>
<p>Esse tipo de erro escapa do compilador porque vocÃª essencialmente burlou o guardiÃ£o. EntÃ£o, a dica Ã©: confie no sistema de tipos do Rust e nas abstraÃ§Ãµes fornecidas; evite reinventar a roda com <code>unsafe</code> a nÃ£o ser que seja realmente necessÃ¡rio e, se for, siga rigorosamente as referÃªncias do Rustonomicon (guia de coisas perigosas do Rust) para nÃ£o violar invariantes de seguranÃ§a.</p>
<h2 id="o-que-send-e-sync-nÃ£o-evitam">O que <code>Send</code> e <code>Sync</code> <strong>nÃ£o</strong> evitam</h2>
<p>Com <code>Send</code> e <code>Sync</code>, o Rust resolve de forma robusta o problema de <em>data races</em> (duas threads escrevendo/lendo o mesmo dado simultaneamente sem sincronizaÃ§Ã£o). No entanto, Ã© importante entender que essas regras nÃ£o previnem todos os problemas possÃ­veis em programaÃ§Ã£o concorrente. Dois problemas notÃ³rios que ainda podem ocorrer sÃ£o:</p>
<ul>
<li><strong>Deadlocks (impasses):</strong> Isso acontece quando duas ou mais threads ficam bloqueadas esperando umas Ã s outras indefinidamente. Por exemplo, a Thread A adquire o Mutex X e em seguida tenta adquirir o Mutex Y, enquanto simultaneamente a Thread B jÃ¡ tem o Mutex Y e tenta adquirir o Mutex X. Nenhuma das duas libera o que a outra precisa, e assim elas ficam travadas para sempre.</li>
</ul>
<blockquote>
<p>O Rust nÃ£o tem como detectar ou impedir deadlocks automaticamente, porque eles resultam da lÃ³gica de travas adquiridas em ordem desfavorÃ¡vel, algo que estÃ¡ alÃ©m da anÃ¡lise de tipo local. Portanto, mesmo que <code>Mutex</code> e <code>RwLock</code> lhe protejam de condiÃ§Ãµes de corrida, vocÃª deve planejar o uso deles cuidadosamente para evitar deadlocks (por exemplo, seguindo sempre a mesma ordem ao adquirir mÃºltiplos locks, ou usando ferramentas de tempo de execuÃ§Ã£o para detectar deadlocks durante testes).</p></blockquote>
<ul>
<li><strong>Outras condiÃ§Ãµes de sincronizaÃ§Ã£o incorreta:</strong> Por exemplo, <em>starvation</em> (quando uma thread nunca consegue tempo de execuÃ§Ã£o porque outras monopolizam recursos), ou ainda erros lÃ³gicos na divisÃ£o de trabalho (como esquecer de enviar um sinal ou mensagem, deixando outra thread esperando eternamente). Essas questÃµes tambÃ©m nÃ£o sÃ£o magicamente resolvidas por <code>Send</code>/<code>Sync</code> â€“ elas exigem cuidado do desenvolvedor na arquitetura do programa.</li>
</ul>
<p>O diagrama a seguir ilustra um caso de deadlock simples entre duas threads. Cada thread estÃ¡ segurando um recurso (representado pelo cadeado ğŸ”’) que a outra precisa, e ambas estÃ£o esperando pela outra liberar. Nenhuma das duas pode prosseguir, caracterizando o impasse. Colocamos um sinal de alerta para lembrar: mesmo com toda a ajuda do compilador, cabe a nÃ³s projetarmos bem a interaÃ§Ã£o entre threads para que situaÃ§Ãµes assim nÃ£o ocorram.</p>


  
  <div class="mermaid">graph TD
    %% Threads cada uma segurando um lock e esperando o do outro (deadlock)
    Thread1([ğŸ§‘â€ğŸ’»&lt;br/&gt;Thread 1&lt;br/&gt;ğŸ”’ Recurso A])
    Thread2([ğŸ§‘â€ğŸ”¬&lt;br/&gt;Thread 2&lt;br/&gt;ğŸ”’ Recurso B])

    %% Cada thread esperando o recurso oposto
    Thread1 -- &#34;esperando Recurso B&#34; --&gt; Thread2
    Thread2 -- &#34;esperando Recurso A&#34; --&gt; Thread1

    %% Sinal de alerta sobre deadlock
    Sinal([&lt;b style=&#39;background:#fef08a;color:#b91c1c;padding:8px 18px;border-radius:12px&#39;&gt;âš ï¸ Deadlock! Planeje a ordem de travas&lt;/b&gt;])
    Thread1 -. parado .- Sinal
    Thread2 -. parado .- Sinal

    %% Estilos visuais
    style Thread1 fill:#f3e8ff,stroke:#a21caf,stroke-width:2px
    style Thread2 fill:#fee2e2,stroke:#b91c1c,stroke-width:2px
    style Sinal fill:#fef08a,stroke:#fbbf24,stroke-width:2px</div>
 <p>Em resumo, <code>Send</code> e <code>Sync</code> nos livram de uma classe enorme de problemas (as condiÃ§Ãµes de corrida de dados), o que jÃ¡ Ã© um alÃ­vio enorme para quem lida com mÃºltiplas threads. Mas eles nÃ£o substituem o bom design de concorrÃªncia. Ainda precisamos pensar na coordenaÃ§Ã£o entre threads: qual vai esperar por qual, que recurso deve ser bloqueado primeiro, quando usar um canal em vez de um lock, etc.</p>
<p>O Rust fornece as ferramentas e garantias de baixo nÃ­vel, mas o alto nÃ­vel da lÃ³gica concorrente â€“ garantir progresso sem deadlocks, sem starvation e com corretude lÃ³gica â€“ fica sob nossa responsabilidade. A boa notÃ­cia Ã© que, livre das preocupaÃ§Ãµes com <em>data races</em>, podemos focar nesses aspectos de design com muito mais tranquilidade.</p>
<p>O Rust, com seus traits <code>Send</code> e <code>Sync</code> e suas primitivas de sincronizaÃ§Ã£o, praticamente elimina os erros de concorrÃªncia mais comuns antes mesmo que seu programa rode. Isso permite escrever cÃ³digo multithreaded eficiente e, principalmente, confiÃ¡vel. Adotar uma mentalidade de &ldquo;seguranÃ§a em primeiro lugar&rdquo; â€“ seguindo as regras do compilador e usando as estruturas adequadas â€“ nos dÃ¡ a base sÃ³lida para entÃ£o construir lÃ³gicas de paralelismo mais complexas de forma controlada.</p>
<blockquote>
<p>Em outras linguagens, Ã© fÃ¡cil cair em armadilhas sutis de concorrÃªncia; em Rust, o compilador age como um guardiÃ£o incansÃ¡vel que nos protege do descuido, restando a nÃ³s projetar conscientemente a interaÃ§Ã£o entre threads. Com atenÃ§Ã£o e as abstraÃ§Ãµes corretas, Ã© possÃ­vel aproveitar o potencial do paralelismo sem abrir mÃ£o da seguranÃ§a e previsibilidade do software. Boa programaÃ§Ã£o concorrente!</p></blockquote>
<h2 id="2-ownership-alÃ©m-da-memÃ³ria-banindo-data-races">2. Ownership alÃ©m da memÃ³ria: banindo <em>data races</em></h2>
<p>O Rust garante seguranÃ§a de memÃ³ria com duas regras fundamentais:</p>
<ol>
<li>Cada valor tem um Ãºnico dono responsÃ¡vel por sua liberaÃ§Ã£o.</li>
<li>VocÃª sÃ³ pode ter vÃ¡rias referÃªncias imutÃ¡veis <strong>ou</strong> uma referÃªncia mutÃ¡vel exclusiva a um dado â€” nunca ambos ao mesmo tempo.</li>
</ol>
<p><img src="" alt="Ownership"></p>
<p>O <strong><a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html#the-borrow-checker">borrow checker</a></strong> do compilador fiscaliza essas regras, impedindo que duas partes do mesmo programa modifiquem um valor simultaneamente. Isso jÃ¡ elimina muitos bugs de concorrÃªncia dentro de uma Ãºnica thread.Quando o assunto Ã© multithread, essas mesmas regras continuam valendo, mas o Rust vai alÃ©m: ele utiliza dois marcadores especiais, chamados de <strong>traits</strong> <code>Send</code> e <code>Sync</code>, para garantir que apenas tipos seguros possam ser compartilhados ou transferidos entre threads.</p>
<p><img src="" alt="Ownership"></p>
<p>Assim, o compilador consegue detectar em tempo de compilaÃ§Ã£o se um dado pode causar problemas de concorrÃªncia, bloqueando usos inseguros antes mesmo do programa rodar.</p>
<h3 id="send-e-sync-em-uma-frase"><code>Send</code> e <code>Sync</code> em uma frase</h3>
<ul>
<li><strong><code>Send</code></strong> â†’ â€œPosso ser <strong>movido</strong> com seguranÃ§a para outra thread.â€ (Ou seja, Ã© seguro transferir a posse desse valor para uma outra thread).</li>
<li><strong><code>Sync</code></strong> â†’ â€œPosso ser <strong>acessado</strong> de mÃºltiplas threads ao mesmo tempo (desde que vocÃª sÃ³ leia ou use sincronizaÃ§Ã£o adequada).â€ Em outras palavras, um tipo <code>T</code> Ã© <code>Sync</code> se, e somente se, <code>&amp;T</code> (referÃªncia a ele) for <code>Send</code>.</li>
</ul>
<p>A maioria dos tipos â€œnormaisâ€ â€“ nÃºmeros primitivos (<code>i32</code>, <code>f64</code>&hellip;), <code>String</code>, <code>Vec&lt;T&gt;</code> etc. â€“ implementa <code>Send</code> e <code>Sync</code> automaticamente. Isso porque eles nÃ£o guardam <em>ponteiros brutos</em> ou outros recursos que poderiam causar condiÃ§Ãµes de corrida por baixo dos panos. O Rust possui uma derivaÃ§Ã£o automÃ¡tica dessas <em>traits</em>: se todas as partes internas de um tipo sÃ£o <code>Send</code>, o tipo em si torna-se <code>Send</code> (mesma lÃ³gica para <code>Sync</code>). Assim, praticamente todos os tipos que vocÃª usa no dia a dia acabam sendo <code>Send</code>/<code>Sync</code> sem esforÃ§o, exceto algumas <strong>notÃ¡veis exceÃ§Ãµes</strong>:</p>
<ul>
<li>Tipos como <code>std::rc::Rc&lt;T&gt;</code> <strong>nÃ£o</strong> implementam <code>Send</code>/<code>Sync</code>. O <code>Rc</code> mantÃ©m um contador de referÃªncias <strong>nÃ£o atÃ´mico</strong>; usÃ¡-lo em duas threads sem proteÃ§Ã£o causaria atualizaÃ§Ãµes concorrentes nesse contador â€“ algo inseguro. Portanto, <code>Rc&lt;T&gt;</code> Ã© deliberadamente marcado como nÃ£o-thread-safe (nem <code>Send</code> nem <code>Sync</code>).</li>
<li>Da mesma forma, <code>Cell&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code> (que usam internamente <code>UnsafeCell</code>) permitem mutaÃ§Ã£o interior nÃ£o sincronizada e por isso <strong>nÃ£o</strong> sÃ£o <code>Sync</code>.</li>
<li>Ponteiros brutos (<code>*const T</code>/<code>*mut T</code>) tambÃ©m nÃ£o sÃ£o <code>Send</code>/<code>Sync</code> por si sÃ³s, pois o compilador nÃ£o tem como garantir nada sobre o que eles apontam.</li>
</ul>
<p><img src="" alt="Ownership"></p>
<p>O compilador usa essas <em>marker traits</em> para restringir o que pode ser compartilhado ou enviado entre threads. Por exemplo, se vocÃª tentar enviar um <code>Rc&lt;T&gt;</code> para outra thread, verÃ¡ um <strong>erro de compilaÃ§Ã£o</strong> informando que <code>Rc&lt;T&gt;</code> nÃ£o implementa <code>Send</code>. Considere este cÃ³digo:</p>


  <pre><code class="language-rust">use std::rc::Rc;
use std::thread;

fn main() {
    let rc = Rc::new(5);

    // Erro de compilaÃ§Ã£o: Rc&lt;i32&gt; nÃ£o Ã© Send
    thread::spawn(move || {
        println!(&#34;{}&#34;, rc);
    });
}</code></pre>
 <p>Aqui, o closure da nova thread tenta capturar <code>rc</code> (um <code>Rc&lt;i32&gt;</code>) por movimento. Como <code>Rc&lt;i32&gt;</code> nÃ£o Ã© <code>Send</code>, o Rust se recusa a compilar o programa â€“ em vez de permitir um possÃ­vel acesso concorrente errado. De fato, o erro Ã© detectado estaticamente: <em>&quot;<code>Rc&lt;..&gt;</code> cannot be sent between threads safely &hellip; trait <code>Send</code> is not implemented for <code>Rc&lt;..&gt;</code>&quot;</em>. Ou seja, o Rust previne a situaÃ§Ã£o antes que ela aconteÃ§a, em vez de vocÃª descobrir o bug durante a execuÃ§Ã£o.</p>
<p><img src="" alt="Ownership"></p>
<p>Para compartilhar dados entre threads de forma segura, o Rust oferece alternativas apropriadas. Por exemplo, o tipo <code>Arc&lt;T&gt;</code> (Atomic Reference Counted) Ã© uma versÃ£o thread-safe de <code>Rc&lt;T&gt;</code>, usando contador atÃ´mico. Ele implementa <code>Send</code> e <code>Sync</code>, podendo ser utilizado em mÃºltiplas threads simultaneamente. Se vocÃª <strong>precisa compartilhar</strong> um valor entre threads (mesmo que apenas para leitura), use <code>std::sync::Arc&lt;T&gt;</code> em vez de <code>Rc&lt;T&gt;</code> â€“ o compilador, novamente, forÃ§a vocÃª a fazer a coisa certa.</p>
<h2 id="3-trÃªs-jeitos-de-fazer-concorrÃªncia-sem-perder-o-sono">3. TrÃªs jeitos de fazer concorrÃªncia sem perder o sono</h2>
<p>O Rust nÃ£o impÃµe um Ãºnico estilo de concorrÃªncia; em vez disso, oferece vÃ¡rias ferramentas de baixo nÃ­vel para vocÃª construir o modelo que preferir. Vamos abordar trÃªs abordagens comuns no Rust <em>moderno</em> para coordenar computaÃ§Ãµes concorrentes, todas beneficiando-se da seguranÃ§a garantida pelo compilador.</p>
<h3 id="31-threads-nativas-stdthread">3.1 Threads nativas (<code>std::thread</code>)</h3>
<p>O modelo mais bÃ¡sico de concorrÃªncia Ã© trabalhar com <strong>threads do sistema operacional</strong>. Em Rust, isso Ã© feito via <code>std::thread</code>. VocÃª lanÃ§a uma nova thread chamando <code>thread::spawn</code> com um closure que serÃ¡ executado em paralelo. Exemplo simples e seguro:</p>


  <pre><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];       // Vec&lt;i32&gt; Ã© Send
    let handle = thread::spawn(move || {
        println!(&#34;Vector = {:?}&#34;, v);
    });
    handle.join().unwrap();
}</code></pre>
 <p>Acima, criamos um vetor <code>v</code> no thread principal e entÃ£o geramos uma thread filha com <code>spawn</code>. Repare no <code>move ||</code>: isso faz com que o closure capture <code>v</code> por <strong>movimento</strong>, transferindo a posse do vetor para a thread nova. Como <code>Vec&lt;i32&gt;</code> implementa <code>Send</code> (inteiros sÃ£o <code>Send</code>, entÃ£o <code>Vec</code> de inteiro tambÃ©m Ã©), essa transferÃªncia Ã© permitida. ApÃ³s o <code>spawn</code>, a variÃ¡vel <code>v</code> <strong>nÃ£o pode mais ser usada</strong> na thread original â€“ ela foi movida.</p>
<p>Assim, evitamos qualquer aliasing simultÃ¢neo: apenas a thread filha acessa o vetor, garantindo seguranÃ§a sem necessidade de locks. No final, usamos <code>handle.join().unwrap()</code> para esperar a thread terminar antes de encerrar o programa.</p>
<h3 id="32-asyncawait-o-modelo-moderno-de-concorrÃªncia">3.2 Async/Await: O modelo moderno de concorrÃªncia</h3>
<p>No ecossistema Rust moderno, <strong>async/await</strong> Ã© frequentemente preferido para I/O concorrente. Diferente de threads do SO, async permite ter milhares de tarefas concorrentes executando em um pool limitado de threads atravÃ©s de um executor (como Tokio ou async-std).</p>


  <pre><code class="language-rust">use tokio;

#[tokio::main]
async fn main() {
    let v = vec![1, 2, 3];
    
    // Spawn de uma task async
    let handle = tokio::spawn(async move {
        println!(&#34;Vector = {:?}&#34;, v);
    });
    
    handle.await.unwrap();
}</code></pre>
 <p><strong>O trait <code>Send</code> continua sendo crucial em async/await!</strong> Quando vocÃª usa um executor multi-thread (como o Tokio por padrÃ£o), as futures podem ser movidas entre threads diferentes durante a execuÃ§Ã£o. Isso significa que qualquer dado capturado pela future deve implementar <code>Send</code>.</p>


  <pre><code class="language-rust">use tokio;
use std::rc::Rc;

#[tokio::main]
async fn main() {
    let rc = Rc::new(5);
    
    // ERRO: Rc nÃ£o Ã© Send!
    tokio::spawn(async move {
        println!(&#34;{}&#34;, rc);
    });
}</code></pre>
 <p>O compilador barra esse cÃ³digo porque <code>Rc&lt;T&gt;</code> nÃ£o implementa <code>Send</code>, e o executor multi-thread pode mover a future para outra thread entre pontos de await.</p>
<p><strong>Pontos de await sÃ£o crÃ­ticos</strong>: Cada <code>.await</code> marca onde uma task pode ser suspensa e retomada em uma thread diferente. O Rust exige que dados nÃ£o-<code>Send</code> nÃ£o atravessem pontos de await em futures que precisam ser <code>Send</code>:</p>


  <pre><code class="language-rust">use tokio;
use std::rc::Rc;

async fn problematic_function() {
    let rc = Rc::new(5);
    
    // ERRO: Rc nÃ£o pode atravessar .await em future Send
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    
    println!(&#34;{}&#34;, rc); // rc nÃ£o Ã© mais vÃ¡lido aqui!
}</code></pre>
 <p>Para resolver, use <code>Arc&lt;T&gt;</code> em vez de <code>Rc&lt;T&gt;</code> quando precisar compartilhar dados em contextos async multi-thread.</p>
<p><img src="" alt="Ownership"></p>
<blockquote>
<p><strong>Dica:</strong> Se vocÃª precisa que mÃºltiplas threads <strong>compartilhem leitura</strong> de alguns dados (ao invÃ©s de mover a posse para uma Ãºnica thread), pode usar um <code>Arc&lt;T&gt;</code> para encapsular esses dados e entÃ£o clonÃ¡-lo para cada thread. O <code>Arc</code> fornece contagem de referÃªncia atÃ´mica, permitindo referÃªncia imutÃ¡vel de mÃºltiplas threads com seguranÃ§a. Apenas lembre-se: quando qualquer thread precisar <em>mutar</em> um valor compartilhado, aÃ­ jÃ¡ entramos no prÃ³ximo tÃ³pico (locks).</p></blockquote>
<p>Em resumo, <code>thread::spawn</code> em Rust jÃ¡ garante em tempo de compilaÃ§Ã£o que qualquer dado capturado pelo novo thread seja seguro de acessar lÃ¡. Isso ocorre porque a assinatura da funÃ§Ã£o <code>spawn</code> exige que o closure (e seu retorno) implementem <code>Send + 'static</code> â€“ ou seja, que possam ser movidos para outra thread e que nÃ£o tenham referÃªncias nÃ£o vÃ¡lidas.</p>
<p>Esses bounds impedem, por exemplo, que vocÃª passe um ponteiro ou referÃªncia para algo na stack da thread original (que poderia nÃ£o existir mais) ou um tipo nÃ£o thread-safe. O Rust sÃ³ deixa vocÃª enviar para outra thread valores que ele sabe que podem ser usados com seguranÃ§a lÃ¡. Resultado: <strong>se compila, provavelmente estÃ¡ correto</strong> no que tange a uso de memÃ³ria entre threads.</p>
<h3 id="33-passagem-de-mensagens-stdsyncmpsc">3.3 Passagem de mensagens (<code>std::sync::mpsc</code>)</h3>
<p>Muitas vezes Ã© <strong>mais simples mandar dados entre threads do que compartilhar estado mutable</strong>. A biblioteca padrÃ£o do Rust segue o estilo CSP (comunicaÃ§Ã£o por passagem de mensagem) oferecendo <em>channels</em> (canais) multi-produtor, single-consumer (<em>mpsc</em>). A ideia Ã©: uma ou mais threads <strong>enviam</strong> mensagens, e uma thread as <strong>recebe</strong> do outro lado. Assim, evitamos compartilhar memÃ³ria; em vez disso, transferimos a propriedade das mensagens de um lugar para outro.</p>
<p><img src="" alt="Ownership"></p>
<p>Um canal Ã© criado com <code>mpsc::channel()</code>, que retorna uma dupla <code>(tx, rx)</code> â€“ o transmissor e o receptor, respectivamente. Enviar uma mensagem com <code>tx.send(msg)</code> <strong>move</strong> a mensagem para dentro do canal (o <code>msg</code> sai da posse do sender), e fazer <code>rx.recv()</code> do outro lado bloqueia atÃ© receber e entÃ£o <strong>retorna a posse</strong> ao thread receptor. Veja um exemplo:</p>


  <pre><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send(String::from(&#34;OlÃ¡, de outra thread!&#34;)).unwrap();
    });

    // rx Ã© Dropâ€‘based; a chamada abaixo bloqueia atÃ© chegar uma msg
    println!(&#34;Recebi: {}&#34;, rx.recv().unwrap());
}</code></pre>
 <p>No cÃ³digo acima, a thread filha envia uma <code>String</code> para o canal, e a thread principal espera recebÃª-la. Note que apÃ³s fazer <code>tx.send(val)</code>, vocÃª nÃ£o pode mais usar <code>val</code> na thread emissora â€“ ele foi movido (se tentar, darÃ¡ erro de uso de valor movido). De fato, se tentÃ¡ssemos usar a variÃ¡vel <code>val</code> depois do <code>send</code>, o compilador reclamaria: ele sabe que o valor agora pertence a outro thread. Esse mecanismo de transferÃªncia de ownership garante que <strong>nenhuma thread fique com um ponteiro â€œpenduradoâ€ para dados que agora estÃ£o em posse de outra</strong>. Sem locks, sem necessidade de cÃ³pias manuais desnecessÃ¡rias â€“ e tudo verificado na compilaÃ§Ã£o.</p>
<p>Outra vantagem de canais Ã© a <strong>sincronizaÃ§Ã£o implÃ­cita</strong>: no exemplo, <code>rx.recv()</code> bloqueou a thread principal atÃ© que a mensagem chegasse. Isso nos poupa de usar outras primitivas de sincronizaÃ§Ã£o para coordenar o momento de leitura. Quando o <code>tx</code> Ã© dropado (todas as senders sÃ£o dropadas), o <code>rx.recv()</code> comeÃ§a a retornar erro, indicando que nÃ£o haverÃ¡ mais mensagens.</p>
<p><img src="" alt="Ownership"></p>
<p>Em suma, canais promovem um estilo de concorrÃªncia onde dados tÃªm <strong>um dono por vez</strong>, saltando de thread em thread. Esse modelo elimina condiÃ§Ãµes de corrida porque, por construÃ§Ã£o, duas threads nunca acessam o mesmo dado simultaneamente â€“ a posse estÃ¡ sempre com apenas uma (atÃ© ser transferida). O Rust ainda checa em tempo de compilaÃ§Ã£o que os tipos das mensagens sÃ£o <code>Send</code> (senÃ£o, vocÃª nem conseguiria criar o thread ou enviar pelo canal). Isso possibilita <strong>concorrÃªncia sem medo</strong> tambÃ©m via passagem de mensagens.</p>
<h3 id="34-memÃ³ria-compartilhada-com-locks-mutex-rwlock">3.4 MemÃ³ria compartilhada com locks (<code>Mutex</code>, <code>RwLock</code>)</h3>
<p>Quando vocÃª <em>realmente</em> precisa de estado mutÃ¡vel compartilhado entre threads (por exemplo, um contador global sendo incrementado por vÃ¡rios threads), o padrÃ£o idiomÃ¡tico Ã© usar um <strong>mutex</strong> (exclusÃ£o mÃºtua) para proteger esse dado. Em Rust, os mutexes vivem no mÃ³dulo <code>std::sync</code>. O combo tÃ­pico Ã© usar <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>: um <code>Arc</code> para permitir mÃºltiplas owners do mesmo dado, e um <code>Mutex</code> para serializar o acesso a ele. Exemplo clÃ¡ssico, incrementando um contador de forma concorrente em 10 threads:</p>


  <pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let h = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num &#43;= 1;
        });
        handles.push(h);
    }
    for h in handles {
        h.join().unwrap();
    }

    println!(&#34;Resultado = {}&#34;, *counter.lock().unwrap());
}</code></pre>
 <p>Nesse cÃ³digo, <code>counter</code> Ã© um <code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>. Cada thread clona o <code>Arc</code> (incrementando o contador atÃ´mico de referÃªncia) e, dentro do closure, chama <code>counter.lock().unwrap()</code>. O mÃ©todo <code>lock()</code> trava o mutex e retorna um <strong><code>MutexGuard</code></strong> â€“ um guardiÃ£o que representa a permissÃ£o exclusiva de acesso ao dado. Enquanto esse <em>guard</em> (aqui chamado <code>num</code>) estÃ¡ em scope, ele empresta uma referÃªncia mutÃ¡vel para o valor interno (<code>i32</code>), permitindo-nos fazer <code>*num += 1</code>.</p>
<p><img src="" alt="Ownership"></p>
<p>Nenhuma outra thread consegue travar o mutex nesse meio tempo â€“ se tentasse, ficaria bloqueada atÃ© o guard ser liberado. Quando o guard sai de escopo (no fim do closure ou se fosse dropado antes), ele automaticamente libera o lock do mutex. Alguns detalhes importantes:</p>
<ul>
<li><code>Mutex::lock()</code> devolve um <code>Result&lt;MutexGuard&lt;T&gt;, _&gt;</code>; usamos <code>.unwrap()</code> apenas por simplicidade. Em caso de outro thread ter panicado dentro do mutex, vocÃª receberia um erro (mutex â€œenvenenadoâ€). Ignorando isso por ora, o ponto Ã© que vocÃª obtÃ©m um <code>MutexGuard</code>. Esse guard implementa <code>Deref</code> e <code>DerefMut</code> para permitir acesso ao dado protegido (como vimos, podemos usar <code>*num</code> para acessar o <code>i32</code>).</li>
<li>O <code>MutexGuard</code> tambÃ©m implementa o trait <code>Drop</code>. Quando Ã© dropado, ele automaticamente libera o lock. Isso significa que nÃ£o hÃ¡ risco de esquecermos de chamar <code>unlock()</code> â€“ a lib garante o unlock no fim do scope do guard. Esse Ã© o idioma de RAII: aquisiÃ§Ã£o de recurso (lock) e liberaÃ§Ã£o acopladas na prÃ³pria vida do objeto guard.</li>
<li>Enquanto um thread estiver com o mutex travado, outros que chamarem <code>lock()</code> vÃ£o bloquear atÃ© poder prosseguir. Assim, garantimos exclusÃ£o mÃºtua: sÃ³ um thread por vez altera (ou lÃª, se for um Mutex normal) o valor dentro do lock.</li>
</ul>
<p><img src="" alt="Ownership"></p>
<p>Uma variaÃ§Ã£o do mutex Ã© o <code>RwLock</code> (lock de leitura/escrita), que permite mÃºltiplos leitores simultÃ¢neos ou um Ãºnico escritor de cada vez. Em casos onde o acesso de leitura Ã© muito mais frequente que escrita, um <code>RwLock</code> pode aumentar desempenho permitindo paralelismo nas leituras. O uso em Rust Ã© semelhante (tambÃ©m via <code>Arc</code> para compartilhar, e mÃ©todos <code>read()</code>/<code>write()</code> que fornecem guards de leitura ou escrita).</p>
<blockquote>
<p>Um detalhe de implementaÃ§Ã£o: <code>Mutex&lt;T&gt;</code> em Rust sÃ³ implementa <code>Sync</code> se <code>T</code> tambÃ©m for <code>Send</code> (ou <code>Sync</code>). Faz sentido â€“ nÃ£o adiantaria proteger um tipo que em si nÃ£o pode ser acessado entre threads. Por baixo dos panos, o Rust usa um truque de <em>interior mutability</em> seguro: o <code>Mutex</code> contÃ©m um <code>UnsafeCell</code> internamente (permite mutaÃ§Ã£o atravÃ©s de referÃªncia imutÃ¡vel, necessÃ¡ria para a implementaÃ§Ã£o), mas como o acesso Ã© protegido pelo lock, isso Ã© â€œdomadoâ€.</p></blockquote>
<p>O compilador confia na corretude do <code>Mutex</code> porque ele foi escrito usando <code>unsafe</code> de forma sound, entÃ£o marca <code>Mutex&lt;T&gt;</code> como <code>Send + Sync</code> se possÃ­vel. Tudo isso para dizer: vocÃª pode guardar qualquer coisa que seja Send dentro de um Mutex e compartilhar entre threads via Arc, com garantia de que estÃ¡ protegido.</p>
<p><img src="" alt="Ownership"></p>
<p>Resumindo, com <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> conseguimos <strong>compartilhar e mutar</strong> um valor <code>T</code> entre vÃ¡rias threads de forma segura. O mesmo compilador que impede aliasing mutÃ¡vel em uma thread garante que, se vocÃª precisar mutaÃ§Ã£o entre threads, vocÃª vai usar as ferramentas certas (como Mutex) para sincronizar. O resultado Ã© um cÃ³digo concorrente <strong>sem <em>data races</em></strong>, mesmo usando memÃ³ria compartilhada. A contrapartida Ã© que problemas de <strong>deadlock</strong> podem acontecer se vocÃª nÃ£o tomar cuidado (mais sobre isso adiante). Mas novamente, o Rust lhe fornece as ferramentas (e atÃ© patterns, como RAII) para minimizar esses riscos.</p>
<h2 id="4-e-o-asyncawait">4. E o <code>async</code>/<code>await</code>?</h2>
<p>ConcorrÃªncia nÃ£o Ã© sinÃ´nimo apenas de threads de SO. Rust tambÃ©m suporta <strong>programaÃ§Ã£o assÃ­ncrona</strong> usando <code>async/await</code> e <em>executors</em> (como Tokio, async-std, etc.). Nesse modelo, vocÃª pode ter milhares de tarefas concorrentes executando em um nÃºmero limitado de threads, atravÃ©s de um agendador. A grande sacada: <strong>o mesmo alicerce de seguranÃ§a vale para tasks assÃ­ncronas</strong>. Alguns pontos de engenharia sobre o async em Rust:</p>
<ul>
<li>O tipo fundamental Ã© o <code>Future</code>. Quando vocÃª escreve uma funÃ§Ã£o <code>async fn</code>, por baixo dos panos ela retorna um tipo que implementa a trait <code>Future</code>. Importante: um <code>Future</code> em Rust <strong>pode ou nÃ£o ser <code>Send</code>/<code>Sync</code></strong>, dependendo de seus campos internos. Se todos os dados usados na state machine do futuro forem <code>Send</code>, o futuro serÃ¡ marcado automaticamente como <code>Send</code>. Se nÃ£o, nÃ£o serÃ¡. Isso significa que vocÃª <strong>pode ter futures que nÃ£o sÃ£o seguros de enviar para outra thread</strong> â€“ e o Rust vai usar essa informaÃ§Ã£o. Por exemplo, um <code>Future</code> que contÃ©m um <code>Rc&lt;T&gt;</code> capturado em um <code>.await</code> <em>nÃ£o</em> serÃ¡ <code>Send</code>.</li>
<li>Um runtime multithread (como o Tokio por padrÃ£o) exige que os futures que ele move entre threads sejam <code>Send</code>. De fato, se vocÃª tentar usar <code>.spawn()</code> de Tokio em uma future que nÃ£o Ã© <code>Send</code>, nÃ£o vai compilar. O compilador verifica no momento em que vocÃª tenta mover a futura para outro thread (similar ao <code>thread::spawn</code>) e acusa erro se ela nÃ£o for <code>Send</code>. Isso forÃ§a vocÃª, por exemplo, a nÃ£o segurar referÃªncias nÃ£o thread-safe atravÃ©s de pontos de espera.</li>
<li>Falando em pontos de espera: cada <code>.await</code> marca claramente onde uma tarefa assÃ­ncrona pode pausar e eventualmente retomar em outra thread. O Rust impÃµe que <strong>nenhuma variÃ¡vel capturada que nÃ£o seja <code>Send</code> atravesse um <code>.await</code></strong> se a future precisar ser sendÃ¡vel. Se vocÃª tentar manter um <code>Rc</code> vivo entre dois awaits e depois mandar a task para o executor multi-thread, serÃ¡ erro de compilaÃ§Ã£o. Esse comportamento evita situaÃ§Ãµes onde uma task poderia suspender segurando, por exemplo, uma referÃªncia para algo no stack e retomar em outra thread acessando algo invÃ¡lido â€“ novamente, o Rust proÃ­be no compile time.</li>
<li>Em suma, <strong>futures e tasks Rust tambÃ©m nÃ£o tÃªm <em>data races</em></strong>. Se vocÃª conseguir rodar seu cÃ³digo async, ele obedece as mesmas regras: ou sÃ³ hÃ¡ acesso Ãºnico/mutÃ¡vel a um dado, ou acessos simultÃ¢neos ocorrem somente a dados sincronizados (por exemplo, usando <code>Arc&lt;Mutex&lt;_&gt;</code> mesmo dentro de async, se necessÃ¡rio). NÃ£o Ã© porque usamos um modelo cooperativo que magicamente escapa das garantias â€“ o Rust estende a lei a esse reino tambÃ©m. Como disse Aaron Turon, <em>â€œThread safety isn&rsquo;t just documentation; it&rsquo;s law.â€</em>. O resultado prÃ¡tico Ã© que vocÃª obtÃ©m <strong>I/O assÃ­ncrono com zero _data race</strong>* â€“ tasks podem trocar mensagens, compartilhar Arcs, tudo com a tranquilidade de que se compilar, as condiÃ§Ãµes de corrida de dados foram eliminadas.</li>
</ul>
<p>Naturalmente, o cÃ³digo async pode interagir com threads nativas. Por exemplo, vocÃª pode ter uma tarefa async que dentro usa <code>spawn_blocking</code> para delegar trabalho pesado a uma threadpool, ou pode controlar tasks em mÃºltiplos cores. O importante Ã©: <strong>as mesmas regras de <code>Send</code>/<code>Sync</code> continuam valendo</strong>.</p>
<p><img src="" alt="Ownership"></p>
<p>A combinaÃ§Ã£o de Rust + Tokio consegue atingir concorrÃªncia altamente eficiente (evitando custos de thread onde nÃ£o precisa) sem sacrificar a seguranÃ§a. Mais uma vez, erros como â€œ duas tasks acessaram ao mesmo tempo um objeto e corromperam-noâ€ sÃ£o evitados antes de virar bug.</p>
<h2 id="5-nem-tudo-sÃ£o-flores-deadlocks-e-lÃ³gica-de-concorrÃªncia">5. Nem tudo sÃ£o flores: deadlocks e lÃ³gica de concorrÃªncia</h2>
<p>O compilador barra <em>data races</em>, mas <strong>nÃ£o</strong> pode detectar outros problemas clÃ¡ssicos de concorrÃªncia, por exemplo:</p>
<ul>
<li><strong>Deadlocks</strong> â€“ quando duas ou mais threads ficam esperando eternamente por locks em ordem invertida. Por exemplo, thread A trava <code>Mutex A</code> e em seguida <code>Mutex B</code>, enquanto thread B trava <code>Mutex B</code> e depois quer <code>Mutex A</code>. Nenhuma libera o que a outra precisa, e ambas congelam. O Rust <strong>nÃ£o</strong> detecta isso em tempo de compilaÃ§Ã£o (problema indecidÃ­vel em geral). Esses erros ainda podem ocorrer se vocÃª nÃ£o planejar bem seu locking. (Vale notar: isso nÃ£o viola seguranÃ§a de memÃ³ria â€“ Ã© um <em>liveness bug</em>, nÃ£o um <em>safety bug</em>. Por isso, Rust permite deadlocks acontecerem, assim como permite leaks de memÃ³ria, por exemplo.)</li>
<li><strong>Starvation</strong> â€“ uma thread ou task fica eternamente sem acesso ao recurso porque outra domina (por exemplo, um mutex que Ã© sempre adquirido rapidamente por outras threads e nunca libera chance para uma certa thread). TambÃ©m entra na conta do desenvolvedor evitar.</li>
<li><strong>Erros de lÃ³gica</strong> â€“ aqui entram todas as condiÃ§Ãµes de corrida nÃ£o relacionadas Ã  memÃ³ria. Por exemplo, ler valores em ordem errada (mesmo com locks, vocÃª pode implementar lÃ³gica incorreta), perder mensagens em um sistema de filas, nÃ£o tratar corretamente a simultaneidade de eventos etc. O compilador nÃ£o tem como saber se seu protocolo de comunicaÃ§Ã£o entre threads estÃ¡ certo.</li>
</ul>
<p>Esses continuam sendo problemas difÃ­ceis que exigem cuidado de engenharia, testes, design adequado. As dicas clÃ¡ssicas para mitigÃ¡-los continuam valendo no mundo Rust:</p>
<ul>
<li>Mantenha uma <strong>ordem global de travamento</strong> de recursos. Se sua aplicaÃ§Ã£o tem vÃ¡rios mutexes, defina uma ordem (por exemplo, sempre travar primeiro o de ID menor, depois o de ID maior) e <strong>siga essa ordem consistentemente</strong> em todos os lugares. Isso evita deadlock circular. Essa recomendaÃ§Ã£o Ã© agnÃ³stica de linguagem, mas no Rust Ã© igualmente aplicÃ¡vel (lembre-se: Rust nÃ£o impede deadlocks!).</li>
<li>Prefira usar <strong>channels</strong> e passagem de mensagem sempre que possÃ­vel, em vez de ficar compartilhando estado mutÃ¡vel. Se vocÃª consegue modelar o problema com threads isoladas trocando mensagens, vocÃª elimina uma grande categoria de problemas â€“ nÃ£o hÃ¡ deadlock se nÃ£o hÃ¡ dois locks ğŸ˜‰. Go popularizou esse conceito com o slogan â€œnÃ£o compartilhe memÃ³ria, passe mensagensâ€ (que o Rust tambÃ©m cita).</li>
<li>Se performance for crÃ­tica e vocÃª quiser evitar bloqueios, considere usar <strong>primitivas atÃ´micas</strong> ou tentar dividir o trabalho de forma que nÃ£o precise de lock. O Rust oferece coisas como <code>std::sync::atomic</code> (tipos atÃ´micos de inteiros, booleans, etc.) que permitem algumas operaÃ§Ãµes lock-free de forma segura. PorÃ©m, use com cautela: embora atÃ´micos individuais nÃ£o causem <em>data race</em>, vocÃª ainda pode introduzir <em>race conditions</em> lÃ³gicas. AlÃ©m disso, atÃ´micos alÃ©m de muito simples (como incrementos) podem ficar complexos rapidamente.</li>
<li>Timeout e <em>try_lock</em>: Ao usar locks, Ã s vezes Ã© saudÃ¡vel programar timeouts ou usar tentativas nÃ£o bloqueantes (<code>try_lock</code>) para evitar esperar para sempre por um recurso que talvez indique um deadlock. Claro, isso nÃ£o resolve a condiÃ§Ã£o de corrida em si, mas pode tornar o sintoma menos catastrÃ³fico (o thread pode detectar que nÃ£o conseguiu o lock e talvez logar um aviso, etc.).</li>
</ul>
<p>Resumindo: Rust te blinda dos problemas de <strong>seguranÃ§a de memÃ³ria</strong> em concorrÃªncia (ou seja, <em>data races</em> virando corrupÃ§Ã£o de dados), mas <strong>nÃ£o elimina a necessidade de projetar bem a sincronizaÃ§Ã£o</strong>. VocÃª continua responsÃ¡vel por garantir que a concorrÃªncia faÃ§a a coisa certa em termos de lÃ³gica e progresso do programa.</p>
<h2 id="6-comparativo-rÃ¡pido">6. Comparativo rÃ¡pido</h2>
<p>Para colocar em perspectiva, vejamos como Rust se compara a algumas outras linguagens populares quanto Ã  seguranÃ§a da concorrÃªncia:</p>
<table>
  <thead>
      <tr>
          <th>Linguagem</th>
          <th><em>Data race</em> em cÃ³digo seguro?</th>
          <th>VerificaÃ§Ã£o</th>
          <th>GC?</th>
          <th>ObservaÃ§Ãµes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Rust</strong></td>
          <td><strong>ImpossÃ­vel</strong> (em Rust <em>safe</em>) ğŸ”’</td>
          <td>100% em tempo de compilaÃ§Ã£o (via <code>Send</code>/<code>Sync</code> + borrow checker)</td>
          <td>NÃ£o</td>
          <td>Zero-cost: sem overhead de runtime; deadlocks ainda sÃ£o possÃ­veis e precisam de cuidado</td>
      </tr>
      <tr>
          <td><strong>C/C++</strong></td>
          <td>PossÃ­vel â†’ <strong>UB</strong> ğŸ’£</td>
          <td>Nenhuma verificaÃ§Ã£o estÃ¡tica (precisa de ferramentas como TSAN em runtime)</td>
          <td>NÃ£o</td>
          <td>MÃ¡ximo desempenho, porÃ©m <strong>qualquer data race invalida o programa</strong>; responsabilidade toda do programador</td>
      </tr>
      <tr>
          <td><strong>Go</strong></td>
          <td>PossÃ­vel âš ï¸</td>
          <td>DetectÃ¡vel em runtime com opÃ§Ã£o <code>-race</code> (nÃ£o obrigatÃ³rio)</td>
          <td>Sim</td>
          <td>Goroutines + canais incentivam evitar compartilhamento, mas nÃ£o impedem â€“ data races produzem comportamento indefinido no modelo de memÃ³ria Go tambÃ©m (embora com consequÃªncias limitadas)</td>
      </tr>
      <tr>
          <td><strong>Java</strong></td>
          <td>PossÃ­vel âš ï¸</td>
          <td>Nenhuma verificaÃ§Ã£o estÃ¡tica (depende de <code>volatile</code>/<code>synchronized</code> corretos)</td>
          <td>Sim</td>
          <td>Modelo de memÃ³ria define que data races produzem resultados imprevisÃ­veis; dev deve usar <code>synchronized</code> para exclusÃ£o mÃºtua. Sem uso correto, condiÃ§Ãµes de corrida ocorrem e sÃ£o bugs de lÃ³gica difÃ­ceis de rastrear</td>
      </tr>
  </tbody>
</table>
<p><strong>Legenda:</strong> ğŸ”’ <em>Data race</em> proibido pelo compilador; ğŸ’£ <em>Data race</em> causa comportamento indefinido explosivo; âš ï¸ <em>Data race</em> possÃ­vel, mas linguagem/plataforma fornece alguma ajuda (ferramentas ou runtime) para detectar ou mitigar.</p>
<blockquote>
<p>Em Go, por exemplo, se vocÃª habilitar o detector de corrida, a runtime pode avisar e atÃ© matar o programa se detectar duas goroutines acessando memÃ³ria compartilhada sem sincronizaÃ§Ã£o. Mas se vocÃª nÃ£o usar a flag <code>-race</code>, o programa roda e pode produzir resultados incorretos de forma sutil. JÃ¡ Java opta por um modelo onde data races nÃ£o quebram a memÃ³ria completamente como em C++, porÃ©m as leituras podem retornar valores desatualizados ou incoerentes. Em ambos os casos, a carga de evitar esses bugs recai sobre o desenvolvedor, enquanto no Rust o compilador nÃ£o te deixa nem comeÃ§ar algo potencialmente problemÃ¡tico.</p></blockquote>
<h2 id="7-conclusÃ£o">7. ConclusÃ£o</h2>
<p>O mesmo compilador que te impede de acessar memÃ³ria liberada <strong>tambÃ©m</strong> impede duas threads de corromperem o mesmo valor ao mesmo tempo. No Rust, <strong>â€œse compila, vocÃª jÃ¡ eliminou uma classe inteira de bugsâ€</strong> â€“ e isso sem precisar de <em>sanitizers</em> em runtime nem pagar o preÃ§o de um coletor de lixo para gerenciar memÃ³ria compartilhada. A linguagem, atravÃ©s do seu sistema de tipos e ownership, consegue encapsular invariantes matemÃ¡ticos que garantem seguranÃ§a em cenÃ¡rios onde, historicamente, era muito fÃ¡cil errar.</p>
<p>Claro, isso nÃ£o significa que escrever cÃ³digo concorrente em Rust Ã© <strong>fÃ¡cil</strong>. ConcorrÃªncia continua sendo concorrÃªncia: vocÃª ainda precisa pensar em possÃ­veis interleavings, planejar comunicaÃ§Ã£o entre threads ou tasks, escolher entre usar threads do SO ou async (ou ambas), evitar deadlocks, etc. O que muda drasticamente Ã© o nÃ­vel de confianÃ§a e tranquilidade: aquele medo crÃ´nico de <em>data race</em> simplesmente desaparece. VocÃª pode focar nos desafios de alto nÃ­vel (dividir bem o trabalho, evitar condiÃ§Ãµes de disputa lÃ³gicas), certo de que o compilador cobre suas costas nos punhos de ferro (ou melhor, punhos de compilaÃ§Ã£o) no que tange a integridade de memÃ³ria.</p>
<p>Em suma, <strong>concorrÃªncia continua difÃ­cil, mas nÃ£o Ã© mais uma roleta-russa</strong>. Com Rust, nÃ³s desenvolvedores ganhamos um parceiro que diz â€œpode ir sem medo que eu garanto que duas threads nÃ£o vÃ£o pisar no mesmo calo de memÃ³riaâ€. E essa garantia â€“ <em>fearless concurrency</em> â€“ muda completamente o jogo de escrever sistemas paralelos seguros e eficientes.</p>
<hr>
<h2 id="referÃªncias">REFERÃŠNCIAS</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">The Rust Programming Language (Rust Book) â€” <strong>Fearless Concurrency</strong></a> â€“ CapÃ­tulo do livro oficial do Rust sobre concorrÃªncia segura e paradigmas suportados.</li>
<li><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#data-races">Rust Reference â€” <strong>Behavior considered undefined: Data Races</strong></a> â€“ ReferÃªncia formal: <em>data race</em> em Rust Ã© considerado <em>undefined behavior</em> (por isso Ã© proibido em cÃ³digo seguro).</li>
<li><a href="https://doc.rust-lang.org/std/marker/index.html">DocumentaÃ§Ã£o Rust â€“ <strong>Send e Sync</strong> (std::marker)</a> â€“ ExplicaÃ§Ã£o das marker traits <code>Send</code> e <code>Sync</code> na biblioteca padrÃ£o (o compilador implementa automaticamente para a maioria dos tipos).</li>
<li><a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Aaron Turon â€“ <strong>Fearless Concurrency in Rust</strong> (Rust Blog, 2015)</a> â€“ Post no blog oficial introduzindo o slogan <em>concorrÃªncia sem medo</em> e discutindo como o modelo de ownership do Rust previne bugs comuns.</li>
<li><a href="https://doc.rust-lang.org/nomicon/shared-mutatability.html">The Rustonomicon â€“ <strong>Sharing &amp; Mutation</strong></a> â€“ CapÃ­tulo do â€œRustonomiconâ€ detalhando como Rust lida com mutabilidade compartilhada de forma segura, incluindo o papel de <code>UnsafeCell</code>, <code>Send</code> e <code>Sync</code>.</li>
<li><a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html">Async in Rust â€“ <strong>Pinning and <code>Send</code> in Futures</strong></a> â€“ DocumentaÃ§Ã£o do Async Book enfatizando que futures precisam ser <code>Send</code> para uso em executores multi-thread, e como o compilador verifica isso.</li>
<li><a href="https://go.dev/ref/mem">Go Language Spec â€“ <strong>The Go Memory Model</strong></a> â€“ Documento oficial do Go descrevendo o modelo de memÃ³ria. Ressalta que data races sÃ£o erros e que programas sem data race se comportam como se fossem sequenciais (DRF-SC).</li>
<li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-avoid-data-races">C++ Core Guidelines â€“ <strong>CP.2: Avoid data races</strong></a> â€“ Guia de melhores prÃ¡ticas de C++: <em>â€œUnless you do, nothing is guaranteed to work.â€</em> Discute o perigo extremo de data races em C/C++.</li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2022-49443">2348240 â€“ (CVE-2022-49443) CVE-2022-49443 kernel: list: fix a data-race around ep-&gt;rdllist</a> â€“ Bugzilla do Red Hat com relatÃ³rio de data race no kernel Linux.</li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2022-49443&amp;utm_source=chatgpt.com">list: fix a data-race around ep-&gt;rdllist - Red Hat Bugzilla</a> â€“ Bugzilla do Red Hat com relatÃ³rio de data race no kernel Linux.</li>
<li><a href="https://www.chromium.org/developers/testing/threadsanitizer-tsan-v2/?utm_source=chatgpt.com">ThreadSanitizer (TSan) v. 2 - The Chromium Projects</a> â€“ DocumentaÃ§Ã£o do ThreadSanitizer (TSan) v. 2.</li>
<li><a href="https://research.google.com/pubs/archive/35604.pdf?utm_source=chatgpt.com">PDF ThreadSanitizer: data race detection in practice - Google Research</a> â€“ Artigo do Google Research sobre detecÃ§Ã£o de data races com ThreadSanitizer.</li>
<li><a href="https://github.com/curl/curl/issues/4915?utm_source=chatgpt.com">tsan: data race in multi.c when shared connection cache Â· Issue #4915</a> â€“ Issue do GitHub com relatÃ³rio de data race no cURL.</li>
<li><a href="https://github.com/grpc/grpc/issues/21729?utm_source=chatgpt.com">Data race in C++ example greeter_async_client2 #21729 - GitHub</a> â€“ Issue do GitHub com relatÃ³rio de data race no gRPC.</li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1704227&amp;utm_source=chatgpt.com">CVE-2021-29952) ThreadSanitizer: data race @ mozilla::layers &hellip;</a> â€“ Issue do Bugzilla do Mozilla com relatÃ³rio de data race no Firefox.</li>
<li><a href="https://github.com/ClickHouse/ClickHouse/issues/69520?utm_source=chatgpt.com">Data race in <code>WriteBufferFromHTTPServerResponse</code> Â· Issue #69520 &hellip;</a> â€“ Issue do GitHub com relatÃ³rio de data race no ClickHouse.</li>
<li><a href="https://stackoverflow.com/questions/72987598/rust-why-is-rc-not-send-in-the-following-scenario?utm_source=chatgpt.com">Rust - Why is Rc not Send in the following scenario? - Stack Overflow</a></li>
<li><a href="https://github.com/jonhoo/evmap/issues/1">Current implementation is unsound. Segfault and double free are possible with out-of-sync maps from a bad <code>PartialEq</code> implementation. Â· Issue #1 Â· jonhoo/evmap Â· GitHub</a></li>
</ul>

    </div>
    
    


<div class="post-comments">
    <h3>ComentÃ¡rios</h3>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = 'https:\/\/scovl.github.io\/2025\/07\/23\/rustconc\/';
            this.page.identifier = '\/2025\/07\/23\/rustconc\/';
            this.page.title = 'Compreendendo a concorrÃªncia em Rust';
        };
        (function() {
            var d = document, s = d.createElement('script');
            s.src = 'https://lobocode.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Por favor, habilite JavaScript para ver os comentÃ¡rios do <a href="https://disqus.com/?ref_noscript">Disqus</a>.</noscript>
</div>
 
</article>

        </div>
    </main>
    
    
    
    <footer class="footer">
    <div class="container">
        <div class="footer-content">
            <div class="footer-links">
                
                <a href="https://github.com/scovl" target="_blank" rel="noopener noreferrer" class="footer-link">
                    GitHub
                </a>
                
                
                
                <a href="https://linkedin.com/in/vitor-lobo" target="_blank" rel="noopener noreferrer" class="footer-link">
                    LinkedIn
                </a>
                
                
                
                <a href="mailto:lobocode@gmail.com" class="footer-link">
                    Email
                </a>
                

                
                <a href="https://hachyderm.io/@lobocode" target="_blank" rel="noopener noreferrer" class="footer-link">
                    Mastodon
                </a>
                

                
                <a href="https://scovl.github.io/index.xml" target="_blank" rel="noopener noreferrer" class="footer-link">
                    RSS
                </a>
                
            </div>
            
            <div class="copyright">
                &copy; 2025 Vitor Lobo
            </div>
        </div>
    </div>
</footer> 
    
    
    
    <script src="/js/main-minimal.js"></script>
    
    
    
</body>
</html> 