<!DOCTYPE html>
<html lang="pt">
<head>
    <title>Prometheus e PromQL | scovl</title>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Guia completo">



<link rel="preload" href="/vendor/fonts/inter/Inter-400.ttf" as="font" type="font/ttf" crossorigin>
<link rel="preload" href="/vendor/fonts/inter/Inter-600.ttf" as="font" type="font/ttf" crossorigin>
<link rel="preload" href="/vendor/fonts/jetbrains-mono/JetBrainsMono-400.ttf" as="font" type="font/ttf" crossorigin>



<link rel="dns-prefetch" href="//giscus.app">
<link rel="preconnect" href="//giscus.app">



<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="format-detection" content="telephone=no"> 


<link rel="stylesheet" href="/css/main.css?v=1757088371">


<link rel="stylesheet" href="/vendor/fonts/fonts.css?v=1757088371">


<link rel="preload" href="/fonts/abril-fatface.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/rokkitt.woff2" as="font" type="font/woff2" crossorigin>


<link rel="stylesheet" href="/vendor/prism/prism-tomorrow.min.css?v=1757088371">



<script src="/vendor/mermaid/mermaid.min.js?v=1757088371"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        mermaid.initialize({
            startOnLoad: true,
            theme: 'light',
            align: 'center'
        });SS
    });
</script>












<script>

const I18n = {
    currentLang: 'pt',
    isRTL:  false ,
    
    
    formatDate(date, options = {}) {
        const defaultOptions = {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        };
        
        const locale = this.getLocale();
        const finalOptions = { ...defaultOptions, ...options };
        
        return new Intl.DateTimeFormat(locale, finalOptions).format(date);
    },
    
    
    formatNumber(number, options = {}) {
        const defaultOptions = {
            style: 'decimal',
            minimumFractionDigits: 0,
            maximumFractionDigits: 2
        };
        
        const locale = this.getLocale();
        const finalOptions = { ...defaultOptions, ...options };
        
        return new Intl.NumberFormat(locale, finalOptions).format(number);
    },
    
    
    formatCurrency(amount, currency = 'USD') {
        const locale = this.getLocale();
        return new Intl.NumberFormat(locale, {
            style: 'currency',
            currency: currency
        }).format(amount);
    },
    
    
    formatRelativeTime(date) {
        const locale = this.getLocale();
        const now = new Date();
        const diff = now - date;
        const diffInMinutes = Math.floor(diff / (1000 * 60));
        const diffInHours = Math.floor(diff / (1000 * 60 * 60));
        const diffInDays = Math.floor(diff / (1000 * 60 * 60 * 24));
        
        if (diffInMinutes < 1) {
            return new Intl.RelativeTimeFormat(locale).format(0, 'minute');
        } else if (diffInMinutes < 60) {
            return new Intl.RelativeTimeFormat(locale).format(-diffInMinutes, 'minute');
        } else if (diffInHours < 24) {
            return new Intl.RelativeTimeFormat(locale).format(-diffInHours, 'hour');
        } else {
            return new Intl.RelativeTimeFormat(locale).format(-diffInDays, 'day');
        }
    },
    
    
    getLocale() {
        const localeMap = {
            'en': 'en-US',
            'pt': 'pt-BR',
            'es': 'es-ES',
            'fr': 'fr-FR',
            'de': 'de-DE',
            'it': 'it-IT',
            'ar': 'ar-SA',
            'he': 'he-IL',
            'fa': 'fa-IR',
            'ur': 'ur-PK',
            'zh': 'zh-CN',
            'ja': 'ja-JP',
            'ko': 'ko-KR'
        };
        
        return localeMap[this.currentLang] || 'en-US';
    },
    
    
    t(key, params = {}) {
        const translations = {
            'en': {
                'read_more': 'Read more',
                'back_to_top': 'Back to top',
                'loading': 'Loading...',
                'error': 'Error',
                'success': 'Success',
                'warning': 'Warning',
                'info': 'Information',
                'comments': 'Comments',
                'related_posts': 'Related Posts',
                'tags': 'Tags',
                'categories': 'Categories',
                'search': 'Search',
                'menu': 'Menu',
                'close': 'Close',
                'language': 'Language',
                'theme': 'Theme',
                'dark_mode': 'Dark Mode',
                'light_mode': 'Light Mode'
            },
            'pt': {
                'read_more': 'Ler mais',
                'back_to_top': 'Voltar ao topo',
                'loading': 'Carregando...',
                'error': 'Erro',
                'success': 'Sucesso',
                'warning': 'Aviso',
                'info': 'Informa√ß√£o',
                'comments': 'Coment√°rios',
                'related_posts': 'Posts Relacionados',
                'tags': 'Tags',
                'categories': 'Categorias',
                'search': 'Pesquisar',
                'menu': 'Menu',
                'close': 'Fechar',
                'language': 'Idioma',
                'theme': 'Tema',
                'dark_mode': 'Modo Escuro',
                'light_mode': 'Modo Claro'
            },
            'es': {
                'read_more': 'Leer m√°s',
                'back_to_top': 'Volver arriba',
                'loading': 'Cargando...',
                'error': 'Error',
                'success': '√âxito',
                'warning': 'Advertencia',
                'info': 'Informaci√≥n',
                'comments': 'Comentarios',
                'related_posts': 'Posts Relacionados',
                'tags': 'Etiquetas',
                'categories': 'Categor√≠as',
                'search': 'Buscar',
                'menu': 'Men√∫',
                'close': 'Cerrar',
                'language': 'Idioma',
                'theme': 'Tema',
                'dark_mode': 'Modo Oscuro',
                'light_mode': 'Modo Claro'
            },
            'ar': {
                'read_more': 'ÿßŸÇÿ±ÿ£ ÿßŸÑŸÖÿ≤ŸäÿØ',
                'back_to_top': 'ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ£ÿπŸÑŸâ',
                'loading': 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...',
                'error': 'ÿÆÿ∑ÿ£',
                'success': 'ŸÜÿ¨ÿ≠',
                'warning': 'ÿ™ÿ≠ÿ∞Ÿäÿ±',
                'info': 'ŸÖÿπŸÑŸàŸÖÿßÿ™',
                'comments': 'ÿßŸÑÿ™ÿπŸÑŸäŸÇÿßÿ™',
                'related_posts': 'ÿßŸÑŸÖŸÇÿßŸÑÿßÿ™ ÿ∞ÿßÿ™ ÿßŸÑÿµŸÑÿ©',
                'tags': 'ÿßŸÑÿπŸÑÿßŸÖÿßÿ™',
                'categories': 'ÿßŸÑŸÅÿ¶ÿßÿ™',
                'search': 'ÿ®ÿ≠ÿ´',
                'menu': 'ÿßŸÑŸÇÿßÿ¶ŸÖÿ©',
                'close': 'ÿ•ÿ∫ŸÑÿßŸÇ',
                'language': 'ÿßŸÑŸÑÿ∫ÿ©',
                'theme': 'ÿßŸÑŸÖÿ∏Ÿáÿ±',
                'dark_mode': 'ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÖÿ∏ŸÑŸÖ',
                'light_mode': 'ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÅÿßÿ™ÿ≠'
            }
        };
        
        const langTranslations = translations[this.currentLang] || translations['en'];
        let text = langTranslations[key] || key;
        
        
        Object.keys(params).forEach(param => {
            text = text.replace(`{${param}}`, params[param]);
        });
        
        return text;
    },
    
    
    init() {
        this.updatePageDirection();
        this.updateDateFormats();
        this.updateNumberFormats();
        this.updateTranslations();
    },
    
    
    updatePageDirection() {
        if (this.isRTL) {
            document.documentElement.setAttribute('dir', 'rtl');
            document.documentElement.setAttribute('lang', this.currentLang);
        }
    },
    
    
    updateDateFormats() {
        const dateElements = document.querySelectorAll('[data-date]');
        dateElements.forEach(element => {
            const date = new Date(element.getAttribute('data-date'));
            const format = element.getAttribute('data-date-format') || 'default';
            
            let formattedDate;
            switch (format) {
                case 'relative':
                    formattedDate = this.formatRelativeTime(date);
                    break;
                case 'short':
                    formattedDate = this.formatDate(date, { month: 'short', day: 'numeric' });
                    break;
                case 'long':
                    formattedDate = this.formatDate(date, { 
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    break;
                default:
                    formattedDate = this.formatDate(date);
            }
            
            element.textContent = formattedDate;
        });
    },
    
    
    updateNumberFormats() {
        const numberElements = document.querySelectorAll('[data-number]');
        numberElements.forEach(element => {
            const number = parseFloat(element.getAttribute('data-number'));
            const format = element.getAttribute('data-number-format') || 'decimal';
            
            let formattedNumber;
            switch (format) {
                case 'currency':
                    const currency = element.getAttribute('data-currency') || 'USD';
                    formattedNumber = this.formatCurrency(number, currency);
                    break;
                case 'percent':
                    formattedNumber = this.formatNumber(number / 100, { style: 'percent' });
                    break;
                default:
                    formattedNumber = this.formatNumber(number);
            }
            
            element.textContent = formattedNumber;
        });
    },
    
    
    updateTranslations() {
        const translationElements = document.querySelectorAll('[data-i18n]');
        translationElements.forEach(element => {
            const key = element.getAttribute('data-i18n');
            const params = {};
            
            
            const paramAttributes = element.getAttribute('data-i18n-params');
            if (paramAttributes) {
                try {
                    Object.assign(params, JSON.parse(paramAttributes));
                } catch (e) {
                    console.warn('Invalid i18n params:', paramAttributes);
                }
            }
            
            element.textContent = this.t(key, params);
        });
    }
};


window.I18n = I18n;
</script>


<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('\/sw.js')
                .then(function(registration) {
                    console.log('Service Worker registrado com sucesso:', registration.scope);
                })
                .catch(function(error) {
                    console.log('Falha no registro do Service Worker:', error);
                });
        });
    }
</script> 
</head>
<body>
    
    
    <header class="header">
    <div class="container">
        <div class="header-content">
            <a href="https://scovl.github.io/" class="site-title">scovl</a>
            
            <div class="header-actions">
                
                <nav class="nav-menu">
                    <ul>
                        
                        <li><a href="/page/about/">About</a></li>
                        
                        <li><a href="/page/contact/">Contact</a></li>
                        
                    </ul>
                </nav>
                
                
                



<div class="language-switcher" id="language-switcher">
    <button class="language-btn" onclick="toggleLanguageMenu()">
        <span class="current-lang">Portugu√™s</span>
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6,9 12,15 18,9"></polyline>
        </svg>
    </button>
    <div class="language-menu" id="language-menu">
        
            
                <a href="https://scovl.github.io/" class="language-option active">
                    Portugu√™s
                </a>
            
        
            
                <a href="https://scovl.github.io/en/" class="language-option ">
                    English
                </a>
            
        
    </div>
</div>
                
                
                <button id="dark-mode-toggle" class="theme-toggle" aria-label="Toggle dark mode">
                    <svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
</header> 
    
    
    
    <main>
        <div class="container">
            
<article class="post">
    <header class="post-header">
        <h1 class="post-title">Prometheus e PromQL</h1>
        
        <div class="post-meta">
            <time datetime="2025-07-27T23:10:18-03:00">
                üìÖ 27/07/2025
            </time>
            
            
            
            <div class="post-tags">
                
                <a href="/tags/prometheus" class="tag">Prometheus</a>
                
                <a href="/tags/grafana" class="tag">Grafana</a>
                
                <a href="/tags/monitoring" class="tag">Monitoring</a>
                
                <a href="/tags/tsdb" class="tag">TSDB</a>
                
                <a href="/tags/devops" class="tag">DevOps</a>
                
                <a href="/tags/observability" class="tag">Observability</a>
                
                <a href="/tags/promql" class="tag">PromQL</a>
                
            </div>
            
        </div>
        
    </header>
    
    
    















  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  



<aside class="toc" id="toc" aria-labelledby="toc-title">
    <div class="toc-container">
        <div class="toc-header">
            <h3 id="toc-title" class="toc-title">
                <svg class="toc-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18M3 12h18M3 18h18"/>
                </svg>
                Sum√°rio
            </h3>
            <button class="toc-toggle" id="toc-toggle" aria-expanded="true" aria-controls="toc-content" aria-label="Mostrar/Ocultar Sum√°rio">
                <svg class="toc-toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="m6 9 6 6 6-6"/>
                </svg>
            </button>
        </div>
        <div class="toc-content" id="toc-content">
            <div class="toc-progress">
                <div class="toc-progress-bar" id="toc-progress-bar"></div>
            </div>
            <nav class="toc-nav">
                <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#tipos-de-m√©tricas">Tipos de m√©tricas</a></li>
        <li><a href="#monitoramento-pull-vs-push">Monitoramento pull vs push</a></li>
        <li><a href="#arquitetura-do-prometheus">Arquitetura do Prometheus</a></li>
        <li><a href="#labels-e-samples">Labels e Samples</a></li>
        <li><a href="#instala√ß√£o">Instala√ß√£o</a>
          <ul>
            <li><a href="#configura√ß√£o">Configura√ß√£o</a></li>
          </ul>
        </li>
        <li><a href="#-instrumenta√ß√£o">üîç Instrumenta√ß√£o</a>
          <ul>
            <li><a href="#-instrumenta√ß√£o-direta-na-aplica√ß√£o">üìä Instrumenta√ß√£o direta (na aplica√ß√£o)</a></li>
            <li><a href="#-instrumenta√ß√£o-indireta-via-exporters">üîÑ Instrumenta√ß√£o indireta (via exporters)</a></li>
            <li><a href="#instrumenta√ß√£o-indireta-exporters">Instrumenta√ß√£o indireta: Exporters</a></li>
          </ul>
        </li>
        <li><a href="#configura√ß√£o-avan√ßada">Configura√ß√£o Avan√ßada</a>
          <ul>
            <li><a href="#discovery-din√¢mico-e-relabeling">Discovery Din√¢mico e Relabeling</a>
              <ul>
                <li><a href="#service-discovery">Service Discovery</a></li>
                <li><a href="#relabeling">Relabeling</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#promql-os-fundamentos">PromQL: Os Fundamentos</a>
          <ul>
            <li><a href="#time-series-database-tsdb">Time Series Database (TSDB)</a></li>
            <li><a href="#seletores-de-m√©tricas">Seletores de m√©tricas</a></li>
            <li><a href="#tipos-de-express√µes-em-promql">Tipos de express√µes em PromQL</a></li>
            <li><a href="#vector-vs-range-vector">Vector vs. Range Vector</a></li>
            <li><a href="#seguran√ßa-do-seletor-seletores-seguros-vs-inseguros">Seguran√ßa do seletor (Seletores seguros vs inseguros)</a></li>
            <li><a href="#obsolesc√™ncia-do-vetor-instant√¢neo-staleness">Obsolesc√™ncia do vetor instant√¢neo (Staleness)</a></li>
            <li><a href="#fun√ß√µes-matem√°ticas-e-clamping">Fun√ß√µes Matem√°ticas e Clamping</a></li>
            <li><a href="#timestamps-e-fun√ß√µes-de-tempo-e-data">Timestamps e Fun√ß√µes de Tempo e Data</a></li>
            <li><a href="#counter-range-vectors-agrega√ß√£o-temporal-e-subconsultas">Counter Range Vectors, Agrega√ß√£o Temporal e Subconsultas</a></li>
            <li><a href="#histogramas-mudan√ßa-de-tipo-altera√ß√£o-de-labels-e-ordena√ß√£o">Histogramas, Mudan√ßa de Tipo, Altera√ß√£o de Labels e Ordena√ß√£o</a></li>
            <li><a href="#valores-ausentes-absent--missing-values">Valores ausentes (Absent / Missing Values)</a></li>
            <li><a href="#fun√ß√µes-avan√ßadas-e-menos-conhecidas">Fun√ß√µes avan√ßadas e menos conhecidas</a></li>
            <li><a href="#operadores-aritm√©ticos-e-correspond√™ncia-de-vetores-simples">Operadores Aritm√©ticos e Correspond√™ncia de Vetores Simples</a></li>
            <li><a href="#correspond√™ncia-de-s√©ries-temporais-on-ignoring-group_left-group_right">Correspond√™ncia de S√©ries Temporais: <code>on()</code>, <code>ignoring()</code>, <code>group_left</code>, <code>group_right</code></a></li>
            <li><a href="#operadores-l√≥gicos-and-or-unless">Operadores L√≥gicos: <code>and</code>, <code>or</code>, <code>unless</code></a></li>
            <li><a href="#resumo-de-operadores-de-conjunto-conjuntos-de-s√©ries">Resumo de operadores de conjunto (conjuntos de s√©ries)</a></li>
          </ul>
        </li>
        <li><a href="#fun√ß√µes-essenciais-do-promql">Fun√ß√µes Essenciais do PromQL</a>
          <ul>
            <li><a href="#fun√ß√µes-de-taxa-e-incremento">Fun√ß√µes de Taxa e Incremento</a></li>
            <li><a href="#fun√ß√µes-de-agrega√ß√£o">Fun√ß√µes de Agrega√ß√£o</a></li>
            <li><a href="#fun√ß√µes-de-percentil-e-histograma">Fun√ß√µes de Percentil e Histograma</a></li>
            <li><a href="#fun√ß√µes-de-filtro-e-sele√ß√£o">Fun√ß√µes de Filtro e Sele√ß√£o</a></li>
            <li><a href="#fun√ß√µes-de-tempo">Fun√ß√µes de Tempo</a></li>
            <li><a href="#fun√ß√µes-de-detec√ß√£o-de-aus√™ncia">Fun√ß√µes de Detec√ß√£o de Aus√™ncia</a></li>
          </ul>
        </li>
        <li><a href="#promql-avan√ßado">PromQL Avan√ßado</a>
          <ul>
            <li><a href="#correspond√™ncia-de-s√©ries-temporais-on-ignoring-group_left-group_right-1">Correspond√™ncia de S√©ries Temporais: <code>on()</code>, <code>ignoring()</code>, <code>group_left</code>, <code>group_right</code></a></li>
            <li><a href="#operadores-l√≥gicos-and-or-unless-1">Operadores L√≥gicos: <code>and</code>, <code>or</code>, <code>unless</code></a></li>
            <li><a href="#subconsultas-e-an√°lise-temporal-avan√ßada">Subconsultas e An√°lise Temporal Avan√ßada</a></li>
            <li><a href="#fun√ß√µes-avan√ßadas-e-especializadas">Fun√ß√µes Avan√ßadas e Especializadas</a></li>
          </ul>
        </li>
        <li><a href="#promql-na-pr√°tica">PromQL na Pr√°tica</a>
          <ul>
            <li><a href="#consultas-b√°sicas-de-disponibilidade">Consultas B√°sicas de Disponibilidade</a></li>
            <li><a href="#m√©tricas-de-sistema-node-exporter">M√©tricas de Sistema (Node Exporter)</a></li>
            <li><a href="#m√©tricas-de-aplica√ß√£o-web">M√©tricas de Aplica√ß√£o Web</a></li>
            <li><a href="#m√©tricas-de-banco-de-dados">M√©tricas de Banco de Dados</a></li>
            <li><a href="#m√©tricas-de-containerkubernetes">M√©tricas de Container/Kubernetes</a></li>
            <li><a href="#alertas-comuns">Alertas Comuns</a></li>
            <li><a href="#consultas-avan√ßadas">Consultas Avan√ßadas</a></li>
            <li><a href="#dicas-de-performance">Dicas de Performance</a></li>
            <li><a href="#exemplos-de-recording-rules">Exemplos de Recording Rules</a></li>
            <li><a href="#instrumenta√ß√£o-direta-exemplos-por-linguagem">Instrumenta√ß√£o direta: exemplos por linguagem</a>
              <ul>
                <li><a href="#java-micrometer--cliente-java-do-prometheus">Java (Micrometer / Cliente Java do Prometheus)</a></li>
                <li><a href="#javascriptnodejs">JavaScript/Node.js</a></li>
                <li><a href="#python-flask-etc">Python (Flask, etc.)</a></li>
              </ul>
            </li>
            <li><a href="#ferramentas-legadas-e-fechadas">Ferramentas legadas e fechadas</a></li>
          </ul>
        </li>
        <li><a href="#alertmanager">Alertmanager</a>
          <ul>
            <li><a href="#alertmanager-avan√ßado-silencing-e-inhibition">Alertmanager Avan√ßado: Silencing e Inhibition</a>
              <ul>
                <li><a href="#silencing">Silencing</a></li>
                <li><a href="#inhibition">Inhibition</a></li>
                <li><a href="#routing-avan√ßado">Routing Avan√ßado</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#pushgateway">PushGateway</a></li>
        <li><a href="#federa√ß√£o">Federa√ß√£o</a></li>
        <li><a href="#remote-write-e-remote-read">Remote Write e Remote Read</a>
          <ul>
            <li><a href="#remote-write">Remote Write</a></li>
            <li><a href="#remote-read">Remote Read</a></li>
            <li><a href="#casos-de-uso-t√≠picos">Casos de Uso T√≠picos</a></li>
          </ul>
        </li>
        <li><a href="#under-the-hood">Under the Hood</a>
          <ul>
            <li><a href="#gerenciamento-de-mem√≥ria-pelo-prometheus">Gerenciamento de mem√≥ria pelo Prometheus</a></li>
            <li><a href="#native-histograms-recurso-experimental">Native Histograms (Recurso Experimental)</a>
              <ul>
                <li><a href="#diferen√ßas-dos-histogramas-tradicionais">Diferen√ßas dos Histogramas Tradicionais</a></li>
                <li><a href="#configura√ß√£o-1">Configura√ß√£o</a></li>
                <li><a href="#exemplo-de-uso">Exemplo de Uso</a></li>
                <li><a href="#vantagens">Vantagens</a></li>
                <li><a href="#considera√ß√µes">Considera√ß√µes</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#melhores-pr√°ticas">Melhores Pr√°ticas</a>
          <ul>
            <li><a href="#planejamento-de-capacidade">Planejamento de Capacidade</a></li>
            <li><a href="#organiza√ß√£o-de-m√©tricas-e-labels">Organiza√ß√£o de M√©tricas e Labels</a>
              <ul>
                <li><a href="#o-inimigo-n¬∫-1-explos√£o-de-cardinalidade">O Inimigo n¬∫ 1: Explos√£o de Cardinalidade</a></li>
              </ul>
            </li>
            <li><a href="#consultas-promql-eficientes">Consultas (PromQL) Eficientes</a></li>
            <li><a href="#arquitetura-e-escalabilidade">Arquitetura e Escalabilidade</a></li>
            <li><a href="#seguran√ßa">Seguran√ßa</a></li>
            <li><a href="#backup-recovery-e-upgrade">Backup, Recovery e Upgrade</a>
              <ul>
                <li><a href="#backup-de-dados">Backup de Dados</a></li>
                <li><a href="#recupera√ß√£o-de-falhas">Recupera√ß√£o de Falhas</a></li>
                <li><a href="#estrat√©gias-de-upgrade">Estrat√©gias de Upgrade</a></li>
                <li><a href="#considera√ß√µes-importantes">Considera√ß√µes Importantes</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#opera√ß√£o-e-manuten√ß√£o">Opera√ß√£o e Manuten√ß√£o</a>
          <ul>
            <li><a href="#promtool">Promtool</a></li>
          </ul>
        </li>
        <li><a href="#conclus√£o">Conclus√£o</a></li>
        <li><a href="#refer√™ncias">Refer√™ncias</a></li>
      </ul>
    </li>
  </ul>
</nav>
            </nav>
        </div>
    </div>
    
    
    <button class="toc-mobile-toggle" id="toc-mobile-toggle" aria-label="Mostrar Sum√°rio">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 6h18M3 12h18M3 18h18"/>
        </svg>
    </button>
</aside>



    
    <div class="post-content">
        <p>O <strong><a href="https://prometheus.io/">Prometheus</a></strong> √© uma ferramenta open-source de monitoramento de sistemas e aplica√ß√µes que revolucionou a forma de pensar observabilidade em ambientes distribu√≠dos. Ele coleta e armazena m√©tricas como s√©ries temporais, ou seja, valores num√©ricos associados a um carimbo de tempo e a pares chave-valor chamados <strong><a href="https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels">labels</a></strong>.</p>
<blockquote>
<p>A pot√™ncia do Prometheus vem, em parte, da sua linguagem de consulta pr√≥pria, <strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">PromQL</a></strong>, que permite criar consultas complexas para analisar os dados coletados em tempo real. A interface web integrada (Expression browser) facilita visualizar e explorar m√©tricas, possibilitando an√°lises r√°pidas para identificar tend√™ncias e anomalias.</p></blockquote>
<p>Desenvolvido inicialmente na SoundCloud em 2012 por <a href="https://github.com/juliusv">Julius Volz</a> e equipe, o Prometheus foi projetado para ser simples, eficiente e altamente dimension√°vel. Em 2016, o projeto foi adotado pela <strong><a href="https://www.cncf.io/">Cloud Native Computing Foundation (CNCF)</a></strong> como o segundo projeto hospedado (logo ap√≥s o <a href="https://kubernetes.io/">Kubernetes</a>), refor√ßando sua maturidade e ampla ado√ß√£o pela comunidade.</p>
<blockquote>
<p>Hoje, o Prometheus √© um pilar no ecossistema de observabilidade cloud-native, frequentemente usado em conjunto com o Grafana para visualiza√ß√µes avan√ßadas, formando uma poderosa stack de monitoramento.</p></blockquote>
<h2 id="tipos-de-m√©tricas">Tipos de m√©tricas</h2>
<p>O Prometheus suporta quatro tipos principais de m√©tricas:</p>
<ul>
<li>
<p><strong><a href="https://prometheus.io/docs/concepts/metric_types/#counter">Counter (Contador)</a></strong>: M√©trica cumulativa que apenas aumenta (ou zera). Indicada para quantificar eventos, como n√∫mero de requisi√ß√µes ou erros. Por exemplo, um contador <code>http_requests_total</code> incrementa a cada requisi√ß√£o recebida. Contadores nunca diminuem, exceto quando reiniciados. Consultas comuns envolvem a taxa de aumento usando fun√ß√µes como <code>rate()</code> ou <code>increase()</code>, calculando, por exemplo, quantas requisi√ß√µes por segundo ocorreram em determinado intervalo.</p>
</li>
<li>
<p><strong><a href="https://prometheus.io/docs/concepts/metric_types/#gauge">Gauge (Indicador)</a></strong>: M√©trica que representa um valor em um instante, podendo tanto aumentar quanto diminuir. Indicado para valores como utiliza√ß√£o de CPU, mem√≥ria ou tamanho de fila ‚Äì que sobem e descem livremente. N√£o possui limite m√≠nimo ou m√°ximo fixo. Fun√ß√µes como <code>avg_over_time()</code>, <code>min()</code>, <code>max()</code> e <code>sum()</code> s√£o frequentemente aplicadas sobre gauges para obter m√©dias, m√≠nimos, m√°ximos ou somas ao longo do tempo.</p>
</li>
<li>
<p><strong><a href="https://prometheus.io/docs/concepts/metric_types/#histogram">Histogram (Histograma)</a></strong>: M√©trica que contabiliza a distribui√ß√£o de valores observados em <em>buckets</em> (faixas) predefinidos. √â muito utilizada para medir lat√™ncias (e.g., dura√ß√£o de requisi√µes) ou outros valores cuja distribui√ß√£o importa. O Prometheus implementa histogramas atrav√©s de v√°rios contadores ‚Äì um por bucket ‚Äì al√©m de contadores especiais para total de observa√ß√µes (<code>_count</code>) e soma dos valores (<code>_sum</code>). Consultas tipicamente usam <code>histogram_quantile()</code> para extrair percentis a partir dos buckets e fun√ß√µes como <code>rate()</code> ou <code>increase()</code> nos contadores para ver taxas.</p>
</li>
<li>
<p><strong><a href="https://prometheus.io/docs/concepts/metric_types/#summary">Summary (Sum√°rio)</a></strong>: M√©trica similar ao histograma, mas os c√°lculos de percentis e m√©dias s√£o feitos pelo pr√≥prio alvo instrumentado. O summary fornece diretamente percentis (por exemplo, lat√™ncia p95) e contagens/agregados para um conjunto de observa√ß√µes. Entretanto, summaries t√™m a limita√ß√£o de n√£o poderem ser agregados facilmente entre m√∫ltiplas inst√¢ncias (diferente dos histogramas). Em geral, histogramas s√£o preferidos para m√©tricas de lat√™ncia quando se quer combinar valores de v√°rias fontes, enquanto summaries podem ser √∫teis para percentis muito espec√≠ficos em inst√¢ncias isoladas.</p>
</li>
</ul>
<blockquote>
<p>Use Histogramas quando precisar agregar lat√™ncias de m√∫ltiplas inst√¢ncias e calcular percentis globais. Use Sum√°rios quando os percentis calculados no cliente s√£o suficientes e a agrega√ß√£o n√£o √© necess√°ria.</p></blockquote>
<p>Al√©m desses tipos principais, o Prometheus exp√µe m√©tricas especiais de estado ‚Äì por exemplo, a m√©trica interna <code>up</code> indica se um determinado alvo foi coletado com sucesso (valor 1) ou n√£o (0). Essa m√©trica √© muito √∫til para monitorar disponibilidade de servi√ßos: se um <strong>endpoint</strong> monitorado ficar indispon√≠vel, <code>up{instance=&quot;endpoint:porta&quot;} == 0</code> sinaliza falha. Vale notar que n√£o existe um &ldquo;tipo&rdquo; separado para essas m√©tricas de sa√∫de; elas normalmente s√£o gauges (0 ou 1) usadas para esse prop√≥sito.</p>
<h2 id="monitoramento-pull-vs-push">Monitoramento pull vs push</h2>
<p>Para entender <strong>pull</strong> vs <strong>push</strong>, imagine cuidar de plantas: no modelo <strong>pull</strong> voc√™ vai todo dia verificar se precisam de √°gua; no modelo <strong>push</strong> as pr√≥prias plantas enviam um sinal quando precisam ser regadas. Tecnicamente, no monitoramento <strong>pull</strong> um sistema central (como o Prometheus) consulta periodicamente os alvos para coletar m√©tricas ‚Äì ele &ldquo;puxa&rdquo; as informa√ß√µes. J√° no monitoramento <strong>push</strong>, os pr√≥prios alvos enviam (<em>empurram</em>) as m√©tricas para um coletor central sem serem solicitados.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/main/post/images/tsdb/prom-pullvspush.png" alt=""></p>
<p>No Prometheus, prevalece o modelo pull. O servidor Prometheus periodicamente faz <strong>scrape</strong> (raspagem) dos dados de cada alvo exportador via HTTP, no endpoint padr√£o <code>/metrics</code>. Cada scrape coleta o valor atual de todas as s√©ries expostas naquele alvo.</p>
<p>Os alvos podem ser aplica√ß√µes instrumentadas que exp√µem suas m√©tricas diretamente, ou <strong>exporters</strong> (exportadores) que traduzem m√©tricas de sistemas externos para o formato do Prometheus.</p>
<p>Assim, o Prometheus obt√©m em intervalos regulares (por padr√£o a cada 15s) as m√©tricas atuais de cada servi√ßo, armazenando-as localmente.</p>
<p>Na imagem acima, a compara√ß√£o dos modelos de coleta: √† esquerda, no modo push os clientes enviam suas m√©tricas proativamente a um gateway; √† direita, no modo pull o Prometheus consulta cada cliente periodicamente. O modelo pull tem vantagens em simplicidade e confiabilidade ‚Äì se um servi√ßo cair, o Prometheus sabe (a m√©trica <code>up</code> fica 0) e n√£o depende de buffers intermedi√°rios.</p>
<p>J√° o modelo push pode ser √∫til para casos espec√≠ficos, como <em>jobs</em> de curta dura√ß√£o ou ambientes onde n√£o √© poss√≠vel expor um endpoint (nesses casos usa-se o <strong>Pushgateway</strong>, discutido adiante). Em suma, o Prometheus, por padr√£o, <strong>n√£o</strong> recebe m√©tricas ativamente; ele mesmo vai colet√°-las, evitando sobrecarga nos aplicativos monitorados e detectando automaticamente indisponibilidades.</p>
<h2 id="arquitetura-do-prometheus">Arquitetura do Prometheus</h2>
<p>A arquitetura do Prometheus foi concebida para facilitar a coleta de dados de m√∫ltiplas fontes de forma confi√°vel e distribu√≠da. O cora√ß√£o do sistema √© o <strong><a href="https://prometheus.io/docs/prometheus/latest/components/prometheus/">Prometheus Server</a></strong> principal, respons√°vel por agendar e realizar as coletas (<em>scrapes</em>) de cada alvo monitorado e armazenar as s√©ries temporais resultantes localmente.</p>
<p>A configura√ß√£o dessas coletas √© definida em um arquivo YAML (geralmente <code>prometheus.yml</code>), especificando <strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#job_name">jobs</a></strong> e <strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_configs">targets</a></strong> ‚Äì por exemplo, &ldquo;coletar m√©tricas do servi√ßo X na URL Y a cada 15 segundos&rdquo;. A figura abaixo (extra√≠da da documenta√ß√£o oficial) ilustra a arquitetura e os componentes do ecossistema Prometheus:</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/refs/heads/main/blog/content/post/images/tsdb/arch.png" alt=""></p>
<p>Em resumo, o fluxo √©: o Prometheus <strong>coleta (pull)</strong> m√©tricas dos jobs instrumentados, diretamente dos servi√ßos ou via um componente intermedi√°rio de push para jobs ef√™meros. Todos os samples coletados s√£o armazenados localmente no banco de dados de s√©ries temporais embutido (<a href="https://prometheus.io/docs/prometheus/latest/storage/tsdb/">TSDB</a>).</p>
<p>Regras definidas podem ser executadas continuamente sobre esses dados ‚Äì seja para gravar novas s√©ries agregadas (<a href="https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/">recording rules</a>) ou para acionar <strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">alertas</a></strong>. Os alertas gerados pelo Prometheus s√£o ent√£o enviados para o <strong><a href="https://prometheus.io/docs/alerting/latest/alertmanager/">Alertmanager</a></strong> processar. Por fim, ferramentas de visualiza√ß√£o como o <strong><a href="https://grafana.com/">Grafana</a></strong> podem consultar o Prometheus para exibir dashboards das m√©tricas coletadas.</p>
<p>O ecossistema Prometheus possui diversos componentes (muitos opcionais) que interagem nessa arquitetura:</p>
<ul>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/components/prometheus/">Servidor Prometheus</a></strong> ‚Äì o servidor principal que coleta e armazena as m√©tricas e processa consultas PromQL.</li>
<li><strong><a href="https://prometheus.io/docs/instrumenting/clientlibs/">Bibliotecas cliente</a></strong> ‚Äì usadas para instrumentar c√≥digo de aplica√ß√µes (expondo m√©tricas via /metrics). H√° libs oficiais em Go, Java, Ruby, Python, etc.</li>
<li><strong><a href="https://prometheus.io/docs/instrumenting/exporters/">Exporters</a></strong> ‚Äì programas externos que coletam m√©tricas de servi√ßos ou sistemas terceiros (bancos de dados, servidores web, sistemas operacionais) e as exp√µem no formato Prometheus. Exemplos: Node Exporter (m√©tricas de sistema Linux), Blackbox Exporter (monitoramento de endpoints externos), etc.</li>
<li><strong><a href="https://prometheus.io/docs/instrumenting/pushing/">Pushgateway</a></strong> ‚Äì gateway para receber m√©tricas <em>pushed</em> por aplicativos de curta dura√ß√£o ou ambientes onde n√£o d√° para o Prometheus puxar diretamente.</li>
<li><strong><a href="https://prometheus.io/docs/alerting/latest/alertmanager/">Alertmanager</a></strong> ‚Äì componente respons√°vel por receber alertas enviados pelo Prometheus e gerenciar o envio de notifica√ß√µes (email, Slack, PagerDuty etc.), realizando agrupamento, deduplica√ß√£o e silenciamento conforme configurado.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/tools/">Ferramentas de suporte</a></strong> ‚Äì englobam utilit√°rios de linha de comando (como o promtool), exportadores de terceiros, dashboards pr√©-configurados, entre outros, que facilitam operar e integrar o Prometheus.</li>
</ul>
<p>Essa arquitetura descentralizada (com coleta <strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#pull_interval">pull</a></strong> e componentes distintos) torna o Prometheus especialmente adequado a ambientes modernos com microsservi√ßos e orquestra√ß√£o de cont√™ineres (<a href="https://www.docker.com/">Docker</a>, <a href="https://kubernetes.io/">Kubernetes</a>).</p>
<p>Ele foi projetado para funcionar de forma aut√¥noma em cada n√≥ (cada servidor Prometheus √© independente, sem depend√™ncia de armazenamento distribu√≠do), privilegiando confiabilidade mesmo durante falhas de rede ou de outros servi√ßos. Em caso de problemas graves na infraestrutura, voc√™ ainda consegue acessar m√©tricas recentes localmente no Prometheus, que atua como fonte de verdade para diagnosticar incidentes.</p>
<h2 id="labels-e-samples">Labels e Samples</h2>
<p>No Prometheus, <strong><a href="https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels">labels</a></strong> (r√≥tulos) e <strong><a href="https://prometheus.io/docs/concepts/data_model/#samples-and-series">samples</a></strong> (amostras) s√£o conceitos-chave para organizar os dados monitorados.</p>
<p>Uma analogia simples: imagine um guarda-roupa onde cada roupa tem etiquetas indicando cor, tamanho e tipo. Essas etiquetas ajudam a encontrar rapidamente, por exemplo, &ldquo;camisetas verdes tamanho M&rdquo;.</p>
<p>Da mesma forma, no Prometheus cada m√©trica pode ter v√°rios <strong><a href="https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels">labels</a></strong> (chave=valor) que a qualificam.</p>
<p>Por exemplo, uma m√©trica <code>app_memory_usage_bytes</code> poderia ter labels como <code>host=&quot;servidor1&quot;</code> e <code>region=&quot;us-east&quot;</code>. Assim podemos filtrar/consultar &ldquo;uso de mem√≥ria no servidor1&rdquo; apenas buscando por <code>host=&quot;servidor1&quot;</code>.</p>
<p>Os <strong><a href="https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels">labels</a></strong> permitem um modelo de dados multidimensional ‚Äì ou seja, uma mesma m√©trica (ex: <code>http_requests_total</code>) √© armazenada separadamente para cada combina√ß√£o de labels (rota=&quot;/login&quot;, m√©todo=&ldquo;GET&rdquo;, c√≥digo=&ldquo;200&rdquo;, etc.). Isso enriquece as an√°lises, pois podemos agregar ou dividir m√©tricas por essas dimens√µes conforme necess√°rio.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/master/post/images/tsdb/samples01.png" alt=""></p>
<p>J√° os <strong><a href="https://prometheus.io/docs/concepts/data_model/#samples-and-series">samples</a></strong> s√£o as unidades de dado coletadas ao longo do tempo ‚Äì cada medi√ß√£o individual de uma m√©trica em um determinado instante.</p>
<p>Voltando √† analogia, se ped√≠ssemos a cada crian√ßa numa pesquisa que escolhesse 3 balas, as balas escolhidas por cada crian√ßa seriam uma <strong>amostra</strong> da prefer√™ncia de balas.</p>
<p>No contexto do Prometheus, a cada scrape o valor de cada m√©trica coletada √© um sample (com timestamp e valor). Esses samples ficam armazenados como uma s√©rie temporal etiquetada, permitindo ver a evolu√ß√£o daquele valor no tempo.</p>
<p>Por exemplo, considere a m√©trica gauge <code>node_cpu_usage</code> com label <code>host</code>. Para cada host monitorado, teremos uma s√©rie separada, e a cada intervalo de coleta obtemos um sample novo do uso de CPU daquele host. Assim, podemos consultar a s√©rie para ver como a CPU variou ao longo de um dia inteiro para cada m√°quina.</p>
<blockquote>
<p><strong>Exemplo de s√©ries temporais no Prometheus</strong>: cada ponto representa um sample (valor observado) etiquetado por inst√¢ncia ou outra dimens√£o, armazenado em sequ√™ncia temporal.</p></blockquote>
<p>Em resumo, <strong><a href="https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels">labels</a></strong> fornecem contexto (quem, onde, o qu√™) e <strong><a href="https://prometheus.io/docs/concepts/data_model/#samples-and-series">samples</a></strong> fornecem o valor num√©rico no tempo. Essa combina√ß√£o √© o que torna o Prometheus poderoso para agregar m√©tricas semelhantes e, ao mesmo tempo, permitir recortes por dimens√£o. Vale ressaltar a import√¢ncia de escolher labels com cardinalidade controlada ‚Äì ou seja, evitar labels que possam assumir valores extremamente variados (como IDs √∫nicos, URLs completas ou timestamps).</p>
<blockquote>
<p><strong>Nota:</strong> Labels com varia√ß√£o descontrolada podem causar uma explos√£o de s√©ries e sobrecarregar o Prometheus, conforme discutiremos em melhores pr√°ticas.</p></blockquote>
<h2 id="instala√ß√£o">Instala√ß√£o</h2>
<p>Existem diversas maneiras de instalar e executar o Prometheus. Aqui vou demonstrar uma configura√ß√£o simples usando <strong><a href="https://www.docker.com/">Docker</a></strong> e <strong><a href="https://docs.docker.com/compose/">Docker Compose</a></strong>, incluindo o Grafana e uma ferramenta de simula√ß√£o de m√©tricas chamada <strong><a href="https://github.com/dmitsh/promsim">PromSim</a></strong> (√∫til para testes). Essa stack de exemplo traz:</p>
<ul>
<li><strong><a href="https://prometheus.io/">Prometheus</a></strong> ‚Äì servidor de m√©tricas.</li>
<li><strong><a href="https://grafana.com/">Grafana</a></strong> ‚Äì para dashboards e visualiza√ß√£o.</li>
<li><strong><a href="https://github.com/dmitsh/promsim">PromSim</a></strong> ‚Äì um simulador que exp√µe m√©tricas aleat√≥rias para exercitar o Prometheus.</li>
</ul>
<p>Comece criando um arquivo <code>docker-compose.yml</code> com o seguinte conte√∫do:</p>


  <pre><code class="language-yaml">version: &#34;3&#34;
services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - &#34;9090:9090&#34;
    volumes:
      - &#34;./prometheus.yml:/etc/prometheus/prometheus.yml&#34;
    depends_on:
      - promsim

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - &#34;3000:3000&#34;

  promsim:
    image: sysdigtraining/promsim:latest
    container_name: promsim
    ports:
      - &#34;8080:8080&#34;</code></pre>
 <p>No mesmo diret√≥rio, crie o arquivo de configura√ß√£o <code>prometheus.yml</code> para o Prometheus:</p>


  <pre><code class="language-yaml">global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: &#34;promsim&#34;
    static_configs:
      - targets: [&#34;promsim:8080&#34;]</code></pre>
 <p>Esse arquivo define que o Prometheus far√° scrape a cada 15s (<code>scrape_interval</code>) e avalia regras na mesma frequ√™ncia (<code>evaluation_interval</code>). Em <code>scrape_configs</code>, temos um job chamado &ldquo;promsim&rdquo; que coleta m√©tricas do endere√ßo <code>promsim:8080</code> (nosso container PromSim simulando um alvo de m√©tricas). Agora suba os servi√ßos:</p>


  <pre><code class="language-bash">docker-compose up -d</code></pre>
 <p>Isso iniciar√° os containers Prometheus, Grafana e PromSim em segundo plano. Ap√≥s o start, acesse o Grafana em <strong><a href="http://localhost:3000">http://localhost:3000</a></strong> (usu√°rio <strong>admin</strong>, senha <strong>admin</strong> padr√£o). No Grafana, adicione o Prometheus como fonte de dados: v√° em <em>Configuration (engrenagem) &gt; Data Sources</em>, adicione nova fonte do tipo Prometheus com URL <strong><a href="http://prometheus:9090">http://prometheus:9090</a></strong> (que, devido ao Docker Compose, resolve para o container do Prometheus).</p>
<p>Feito isso, voc√™ j√° pode importar ou criar pain√©is Grafana usando as m√©tricas do Prometheus (inclusive as geradas pelo PromSim). O PromSim estar√° expondo v√°rias m√©tricas aleat√≥rias ‚Äì por exemplo, simulando CPU, mem√≥ria, requisi√ß√µes ‚Äì permitindo testar consultas e alertas sem precisar de uma aplica√ß√£o real por tr√°s. Para mais detalhes do PromSim, veja <strong><a href="https://github.com/dmitsh/promsim">a documenta√ß√£o oficial</a></strong>.</p>
<p>Caso queira rodar apenas o Prometheus isoladamente, basta executar o container oficial: <code>docker run -p 9090:9090 prom/prometheus</code>. Depois acesse <strong><a href="http://localhost:9090">http://localhost:9090</a></strong> para abrir a UI nativa do Prometheus:</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/master/post/images/tsdb/ui01.png" alt=""></p>
<p>A interface web padr√£o do Prometheus inclui os seguintes menus no topo:</p>
<ul>
<li><strong><a href="/alerts">Alerts</a></strong>: lista os alertas ativos e suas informa√ß√µes. Mostra tamb√©m alertas pendentes e silenciados.</li>
<li><strong><a href="/graph">Graph</a></strong>: permite rodar consultas PromQL e visualizar o resultado em formato gr√°fico (ou tabela). √â √∫til para explorar interativamente as m√©tricas.</li>
<li><strong><a href="/status">Status</a></strong>: informa√ß√µes sobre o status do servidor Prometheus ‚Äì mem√≥ria usada, n√∫mero de s√©ries ativas, status das coletas, etc.
<ul>
<li><strong><a href="/targets">Targets</a></strong> (na se√ß√£o Status): mostra todos os alvos configurados e se a coleta est√° OK (up) ou falhou.</li>
<li><strong><a href="/service-discovery">Service Discovery</a></strong> (tamb√©m em Status): lista os servi√ßos descobertos via mecanismos din√¢micos (Kubernetes, DNS, etc.).</li>
</ul>
</li>
<li><strong><a href="/classic/targets">Help</a></strong>: link para documenta√ß√£o e ajuda do Prometheus.</li>
</ul>
<p>Al√©m disso, logo abaixo dos menus, a UI oferece algumas op√ß√µes e campos importantes:</p>
<ul>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#time-range-and-resolution-selection">Time range e refresh</a></strong>: controles para selecionar o intervalo de tempo da consulta e atualizar automaticamente.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#time-range-and-resolution-selection">Use local time</a></strong>: alterna entre exibir os timestamps no seu fuso hor√°rio local ou em UTC.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#query-history">Query history</a></strong>: op√ß√£o para habilitar hist√≥rico das consultas feitas (facilita repetir queries recentes).</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#autocomplete">Autocomplete</a></strong>: op√ß√£o para habilitar auto-completar de m√©tricas e fun√ß√µes no campo de consulta.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#expression-language-promql">Campo de consulta PromQL</a></strong>: onde voc√™ escreve a express√£o a ser consultada. O Prometheus traz sugest√µes enquanto voc√™ digita (se autocomplete ligado).</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#execute-and-reset">Bot√µes Execute / Reset</a></strong>: para executar a consulta ou limpar o campo.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#graph-and-table">Aba Graph / Table</a></strong>: seleciona se o resultado ser√° plotado em um gr√°fico ou mostrado como tabela bruta de valores.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#evaluation-time">Evaluation time</a></strong>: permite fixar um timestamp espec√≠fico para avaliar a query (por padr√£o √© &ldquo;now&rdquo;, mas voc√™ pode ver valores hist√≥ricos escolhendo um hor√°rio passado).</li>
</ul>
<blockquote>
<p><strong>Dica:</strong> a UI do Prometheus √© √≥tima para explorar e depurar m√©tricas rapidamente, mas para dashboards permanentes e mais bonitos geralmente usamos o Grafana. O Grafana se conecta ao Prometheus via API e permite combinar m√∫ltiplas consultas em gr√°ficos customizados.</p></blockquote>
<h3 id="configura√ß√£o">Configura√ß√£o</h3>
<p>Ap√≥s instalar, o principal arquivo a ajustar √© o de <strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">configura√ß√£o do Prometheus</a></strong> (<code>prometheus.yml</code>). Nele definimos os par√¢metros globais, jobs de scrape, regras de alerta, etc. Vamos examinar a estrutura b√°sica e algumas customiza√ß√µes comuns. Um exemplo m√≠nimo de <code>prometheus.yml</code> poderia ser:</p>


  <pre><code class="language-yaml">global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;prometheus&#39;
    static_configs:
      - targets: [&#39;localhost:9090&#39;]</code></pre>
 <p>Nesse caso, definimos um intervalo global de scrape de 15s e um job para monitorar o pr√≥prio Prometheus (expondo m√©tricas em <a href="http://localhost:9090">localhost:9090</a>). Para monitorar outras aplica√ß√µes, adicionamos novos blocos em <code>scrape_configs</code>. Por exemplo, para monitorar uma aplica√ß√£o web rodando na porta 8080 de um host chamado <code>my-app</code>:</p>


  <pre><code class="language-yaml">scrape_configs:
  - job_name: &#39;my-app&#39;
    static_configs:
      - targets: [&#39;my-app:8080&#39;]</code></pre>
 <p>Isso instruir√° o Prometheus a coletar periodicamente m√©tricas em <strong><a href="http://my-app:8080/metrics">http://my-app:8080/metrics</a></strong>. Podemos repetir o processo para cada servi√ßo ou componente que queremos incluir, definindo um <code>job_name</code> descritivo e a lista de endpoints (targets).</p>
<p>Para ambientes com muitos alvos ou infraestrutura din√¢mica, √© invi√°vel gerenciar esses targets manualmente. Nesses casos, o Prometheus oferece integra√ß√µes de <strong>Service Discovery</strong> (<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config">Kubernetes</a>, <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ec2_sd_config">AWS EC2</a>, <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config">Consul</a>, <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config">DNS</a>, etc.) e tamb√©m o <strong>file-based discovery</strong> (descoberta via arquivos).</p>
<blockquote>
<p>Este √∫ltimo permite apontar para um ou mais arquivos JSON externos contendo a lista de targets. Assim, ferramentas externas ou scripts podem atualizar esses arquivos conforme os servi√ßos mudam, e o Prometheus percebe as altera√ß√µes automaticamente. Por exemplo, poder√≠amos alterar o job acima para usar arquivo:</p></blockquote>


  <pre><code class="language-yaml">scrape_configs:
  - job_name: &#39;my-app&#39;
    file_sd_configs:
      - files:
          - /etc/prometheus/targets/my-app.json</code></pre>
 <p>E no arquivo <code>/etc/prometheus/targets/my-app.json</code> colocar algo como:</p>


  <pre><code class="language-json">[
  {
    &#34;labels&#34;: {
      &#34;job&#34;: &#34;my-app&#34;,
      &#34;env&#34;: &#34;production&#34;
    },
    &#34;targets&#34;: [
      &#34;my-app1:8080&#34;,
      &#34;my-app2:8080&#34;
    ]
  }
]</code></pre>
 <p>Nesse JSON, especificamos dois targets (dois inst√¢ncias da aplica√ß√£o <code>my-app</code>) e tamb√©m atribu√≠mos labels adicionais a essas inst√¢ncias (<code>env: production</code>, por exemplo). Assim, se futuramente adicionarmos <code>my-app3:8080</code>, basta atualizar o JSON ‚Äì o Prometheus recarrega periodicamente ou quando o arquivo muda. Esse m√©todo facilita escalabilidade e automa√ß√£o da configura√ß√£o de alvos.</p>
<p>Outro ponto de configura√ß√£o importante √© a <strong>reten√ß√£o de dados</strong>. Por padr√£o, o Prometheus guarda as s√©ries temporais localmente por 15 dias. Em ambientes de produ√ß√£o, pode ser necess√°rio ajustar esse per√≠odo.</p>
<p>Voc√™ pode definir a flag de inicializa√ß√£o <code>--storage.tsdb.retention.time</code> (ou configurar no servi√ßo) para algo maior, por exemplo <code>30d</code> para reter ~1 m√™s de m√©tricas. Tenha em mente que aumentar a reten√ß√£o aumenta proporcionalmente o consumo de disco e mem√≥ria.</p>
<p>Tamb√©m √© poss√≠vel limitar por tamanho de disco (<code>--storage.tsdb.retention.size</code>), se preferir. Caso precise de reten√ß√£o muito longa (meses/anos), √© recomend√°vel integrar com solu√ß√µes de armazenamento remoto em vez de manter tudo no Prometheus (falaremos disso em <em>Melhores Pr√°ticas</em>).</p>
<p>Exemplo de defini√ß√£o de reten√ß√£o no <strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#configuration-file">systemd</a></strong> (ExecStart):</p>


  <pre><code class="language-bash">/opt/prometheus/prometheus \
  --config.file=/opt/prometheus/prometheus.yml \
  --storage.tsdb.retention.time=30d</code></pre>
 <blockquote>
<p><strong>Nota:</strong> O formato aceita unidades como <code>h</code>, <code>d</code>, <code>w</code>, <code>y</code>. Voc√™ tamb√©m pode usar a op√ß√£o <code>--storage.tsdb.retention.size</code> para definir um tamanho m√°ximo (por ex: <code>50GB</code>), o que ocorrer primeiro (tempo ou tamanho) aciona a limpeza de dados antigos.</p></blockquote>
<p>Em instala√ß√µes via pacote ou container, normalmente a estrutura de diret√≥rios do Prometheus √© assim:</p>


  <pre><code class="language-">/opt/prometheus/
‚îú‚îÄ‚îÄ prometheus (bin√°rio)
‚îú‚îÄ‚îÄ promtool   (bin√°rio utilit√°rio)
‚îú‚îÄ‚îÄ prometheus.yml (configura√ß√£o)
‚îú‚îÄ‚îÄ consoles/  (arquivos HTML da UI &#34;classic&#34;)
‚îú‚îÄ‚îÄ console_libraries/ (bibliotecas JS para consoles)
‚îî‚îÄ‚îÄ data/      (armazenamento local das s√©ries temporais)</code></pre>
 <p>A pasta <code>data/</code> merece destaque ‚Äì ali ficam todos os dados das m√©tricas coletadas. Abordaremos sua estrutura interna na se√ß√£o &ldquo;Under the Hood&rdquo;.</p>
<blockquote>
<p>Em resumo, ap√≥s instalar, voc√™ deve editar o <code>prometheus.yml</code> para incluir todos os targets que deseja monitorar (seja listando estaticamente ou via mecanismos din√¢micos) e ajustar par√¢metros globais (intervalos, regras, reten√ß√£o).</p></blockquote>
<p>Depois reinicie o servi√ßo/container do Prometheus para aplicar as altera√ß√µes. Para validar se a sintaxe do arquivo est√° correta antes de reiniciar, podemos usar o <strong><a href="https://prometheus.io/docs/prometheus/latest/tools/promtool/">promtool</a></strong> conforme abaixo.</p>
<h2 id="-instrumenta√ß√£o">üîç Instrumenta√ß√£o</h2>
<p>A <strong>instrumenta√ß√£o</strong> √© o processo de inserir coleta de m√©tricas em sistemas e aplica√ß√µes. No contexto Prometheus, podemos dividir em dois tipos:</p>
<h3 id="-instrumenta√ß√£o-direta-na-aplica√ß√£o">üìä Instrumenta√ß√£o direta (na aplica√ß√£o)</h3>
<p>Significa instrumentar o pr√≥prio c√≥digo da aplica√ß√£o ou servi√ßo para expor m√©tricas de neg√≥cio ou de desempenho relevantes. Voc√™ adiciona pontos de m√©trica no c√≥digo (<a href="https://prometheus.io/docs/concepts/metric_types/#counter">counters</a>, <a href="https://prometheus.io/docs/concepts/metric_types/#gauge">gauges</a>, etc.) usando uma biblioteca cliente do Prometheus.</p>
<p>Assim, a pr√≥pria aplica√ß√£o passa a expor um endpoint <code>/metrics</code> com dados em tempo real sobre si mesma (lat√™ncia de requisi√ß√µes, uso de mem√≥ria interno, tamanho de fila, etc.).</p>
<p>Essa abordagem d√° controle granular ‚Äì os desenvolvedores escolhem o que medir ‚Äì e tende a fornecer m√©tricas altamente espec√≠ficas e √∫teis para diagnosticar o comportamento da aplica√ß√£o.</p>
<h3 id="-instrumenta√ß√£o-indireta-via-exporters">üîÑ Instrumenta√ß√£o indireta (via exporters)</h3>
<p>Refere-se a coletar m√©tricas de sistemas externos ou legados atrav√©s de componentes intermedi√°rios chamados <strong><a href="https://prometheus.io/docs/instrumenting/exporters/">exporters</a></strong>. Em vez de modificar o sistema alvo, voc√™ roda um exporter que coleta informa√ß√µes daquele sistema (geralmente via APIs existentes, comandos ou leitura de arquivos) e as exp√µe no formato Prometheus.</p>
<p>O Prometheus ent√£o faz scrape nesse exporter. Essa abordagem √© comum para: sistemas operacionais, bancos de dados, servidores web, ou qualquer software que n√£o tenha suporte nativo ao Prometheus.</p>
<p>Por exemplo, h√° exporters para <strong><a href="https://github.com/prometheus/mysqld_exporter">MySQL</a></strong>, <strong><a href="https://github.com/prometheus/postgres_exporter">PostgreSQL</a></strong>, <strong><a href="https://github.com/nginxinc/nginx-prometheus-exporter">Apache/Nginx</a></strong>, <strong><a href="https://github.com/oliver006/redis_exporter">Redis</a></strong>, entre muitos outros, que traduzem m√©tricas desses sistemas para o formato esperado.</p>
<p>Ambos os tipos s√£o importantes. A instrumenta√ß√£o direta fornece m√©tricas sob medida da aplica√ß√£o (por exemplo, quantas transa√ß√µes processou, quantos usu√°rios ativos, etc.), enquanto a indireta garante visibilidade de componentes de infraestrutura e softwares de terceiros sem precisar alterar eles.</p>
<p>A seguir, veremos exemplos de instrumenta√ß√£o indireta (principais exporters) e de instrumenta√ß√£o direta em algumas linguagens.</p>
<h3 id="instrumenta√ß√£o-indireta-exporters">Instrumenta√ß√£o indireta: Exporters</h3>
<p><strong>Ecossistema nativo:</strong> O Prometheus j√° oferece diversos exporters oficiais ou mantidos pela comunidade para sistemas populares. Alguns exemplos:</p>
<ul>
<li>
<p><strong><a href="https://github.com/prometheus/node_exporter">Node Exporter</a></strong> (Linux): Coleta m√©tricas de sistema operacional Linux ‚Äì CPU, mem√≥ria, disco, rede, entropia, stats de kernel, etc. √â imprescind√≠vel para monitorar VMs ou servidores bare metal. Basta executar o bin√°rio do node_exporter no host; ele abre :9100/metrics com dezenas de m√©tricas padronizadas (cpu_seconds_total, node_filesystem_usage_bytes, etc.). Essas m√©tricas d√£o uma visibilidade completa do estado do host, permitindo identificar gargalos de recurso.</p>
</li>
<li>
<p><strong><a href="https://github.com/prometheus/wmic_exporter">Windows Exporter</a></strong> (Windows): Equivalente para plataformas Windows (antigo WMI exporter). Coleta CPU, mem√≥ria, disco, contadores do Windows, etc., expondo em :9182/metrics (porta padr√£o). Assim, ambiente heterog√™neos tamb√©m podem ser monitorados.</p>
</li>
<li>
<p><strong><a href="https://github.com/prometheus/blackbox_exporter">Blackbox Exporter</a></strong>: √ötil para monitorar <em>externamente</em> a disponibilidade de servi√ßos. Ele executa <em>probes</em> do tipo ICMP (ping), HTTP(S), DNS, TCP, etc., simulando a experi√™ncia do usu√°rio externo. Voc√™ configura m√≥dulos de probe (ex: checar HTTP 200 em determinada URL dentro de 2s) e o Prometheus chama o Blackbox passando o alvo a testar. Se a resposta falha ou excede tempo, m√©tricas como <code>probe_success</code>=0 ou <code>probe_duration_seconds</code> indicam problema. √â excelente para monitorar uptime de sites e endpoints de fora para dentro.</p>
</li>
<li>
<p><strong><a href="https://prometheus.io/docs/instrumenting/exporters/">Exporters de aplica√ß√µes</a></strong>: H√° muitos: PostgreSQL exporter, Redis exporter, JMX exporter (Java), SNMP exporter (equipamentos de rede), etc. Em geral, se voc√™ usar alguma tecnologia popular, provavelmente j√° existe um exporter pronto (a documenta√ß√£o oficial lista dezenas: <strong><a href="https://prometheus.io/docs/instrumenting/exporters/">Exporters e integra√ß√µes</a></strong>).</p>
</li>
</ul>
<blockquote>
<p><strong>Como usar exporters?</strong> Normalmente √© executar o bin√°rio do exporter pr√≥ximo do servi√ßo alvo, e ent√£o adicionar um job no <code>prometheus.yml</code> apontando para o endpoint do exporter. Por exemplo, para Node Exporter em v√°rias m√°quinas, voc√™ rodaria node_exporter em cada host (porta 9100) e adicionaria algo como:</p></blockquote>


  <pre><code class="language-yaml">scrape_configs:
  - job_name: &#39;node&#39;
    static_configs:
      - targets: [&#39;host1:9100&#39;, &#39;host2:9100&#39;, ...]</code></pre>
 <p>Assim o Prometheus coletar√° as m√©tricas de cada m√°quina. Cada m√©trica vir√° automaticamente com labels como <code>instance=&quot;host1:9100&quot;</code> e outras espec√≠ficas (o Node Exporter adiciona label <code>job=&quot;node&quot;</code> e por vezes labels como <code>cpu=&quot;0&quot;</code> para m√©tricas por CPU, etc.).</p>
<blockquote>
<p>Em resumo, a instrumenta√ß√£o indireta via exporters √© fundamental para trazer para o Prometheus dados de componentes que n√£o exp√µem nativamente as m√©tricas. √â um jeito de <em>bridge</em> (ponte) entre sistemas legados e o moderno mundo do Prometheus.</p></blockquote>
<h2 id="configura√ß√£o-avan√ßada">Configura√ß√£o Avan√ßada</h2>
<h3 id="discovery-din√¢mico-e-relabeling">Discovery Din√¢mico e Relabeling</h3>
<p>Em ambientes modernos com infraestrutura din√¢mica (Kubernetes, cloud, microsservi√ßos), configurar targets manualmente no <code>prometheus.yml</code> torna-se invi√°vel. O Prometheus oferece mecanismos de <strong>Service Discovery</strong> que permitem descobrir automaticamente alvos para monitoramento, e o <strong>Relabeling</strong> permite transformar dinamicamente essas descobertas durante o processo de configura√ß√£o.</p>
<h4 id="service-discovery">Service Discovery</h4>
<p>O Prometheus suporta diversos mecanismos de descoberta autom√°tica:</p>
<ul>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config">Kubernetes</a></strong>: Descobre pods, servi√ßos, endpoints automaticamente baseado em labels e anota√ß√µes.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ec2_sd_config">AWS EC2</a></strong>: Encontra inst√¢ncias EC2 baseado em tags.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config">Consul</a></strong>: Usa o Consul como fonte de verdade para servi√ßos.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config">DNS</a></strong>: Resolve nomes DNS para descobrir alvos.</li>
<li><strong><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config">File-based</a></strong>: L√™ targets de arquivos JSON/YAML que podem ser atualizados externamente.</li>
</ul>
<p><strong>Exemplo de discovery Kubernetes:</strong></p>


  <pre><code class="language-yaml">scrape_configs:
  - job_name: &#39;kubernetes-pods&#39;
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.&#43;)
      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
        action: replace
        regex: ([^:]&#43;)(?::\d&#43;)?;(\d&#43;)
        replacement: $1:$2
        target_label: __address__</code></pre>
 <h4 id="relabeling">Relabeling</h4>
<p>O <strong>relabeling</strong> √© uma funcionalidade poderosa que permite transformar labels, nomes de targets, endere√ßos e outros metadados durante o processo de discovery. √â fundamental para:</p>
<ul>
<li><strong>Filtrar targets indesejados</strong> (ex: excluir pods de teste)</li>
<li><strong>Adicionar/remover labels</strong> dinamicamente</li>
<li><strong>Transformar endere√ßos</strong> (ex: mascarar IPs internos)</li>
<li><strong>Agrupar targets</strong> logicamente</li>
</ul>
<p><strong>Exemplo pr√°tico de relabeling:</strong></p>


  <pre><code class="language-yaml">relabel_configs:
  # Manter apenas pods com annotation prometheus.io/scrape=true
  - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
    action: keep
    regex: true
  
  # Extrair namespace como label
  - source_labels: [__meta_kubernetes_namespace]
    action: replace
    target_label: namespace
  
  # Adicionar label de ambiente baseado no namespace
  - source_labels: [namespace]
    regex: &#39;prod-.*&#39;
    replacement: &#39;production&#39;
    target_label: environment
  
  # Remover porta padr√£o se n√£o especificada
  - source_labels: [__address__]
    regex: &#39;(.&#43;):8080&#39;
    target_label: instance
    replacement: &#39;$1&#39;
  
  # Filtrar targets que come√ßam com &#39;test&#39;
  - action: drop
    source_labels: [__meta_kubernetes_pod_name]
    regex: &#39;test.*&#39;</code></pre>
 <p><strong>Casos de uso comuns:</strong></p>
<ul>
<li><strong>Filtros de ambiente</strong>: Manter apenas pods de produ√ß√£o, excluindo dev/test</li>
<li><strong>Mascaramento de dados sens√≠veis</strong>: Remover IPs internos ou informa√ß√µes de debug</li>
<li><strong>Agrega√ß√£o por labels</strong>: Agrupar targets por regi√£o, datacenter, time</li>
<li><strong>Normaliza√ß√£o de nomes</strong>: Padronizar nomes de inst√¢ncias ou servi√ßos</li>
</ul>
<blockquote>
<p><strong>Importante</strong>: O relabeling √© aplicado <strong>antes</strong> do scrape, ent√£o voc√™ pode usar <code>__meta_*</code> labels (metadados do discovery) para tomar decis√µes sobre quais targets monitorar e como rotul√°-los.</p></blockquote>
<h2 id="promql-os-fundamentos">PromQL: Os Fundamentos</h2>
<p>PromQL √© a linguagem de consulta poderosa usada pelo Prometheus para extrair dados de m√©tricas e configurar alertas. Seu principal objetivo √© possibilitar a an√°lise e monitoramento de m√©tricas (como requisi√ß√µes HTTP por segundo ou a m√©dia de utiliza√ß√£o de CPU por servidor) por meio de express√µes que definem c√°lculos espec√≠ficos.</p>
<p>O PromQL suporta fun√ß√µes matem√°ticas, opera√ß√µes booleanas e de compara√ß√£o, al√©m de agrupamento de dados e agrega√ß√µes. Ela tamb√©m conta com recursos avan√ßados, como subconsultas e fun√ß√µes de an√°lise temporal.</p>
<p>As consultas PromQL podem ser executadas atrav√©s da interface web do Prometheus, de APIs ou de bibliotecas de clientes. Em resumo, a PromQL √© essencial para monitorar e analisar o desempenho de sistemas com efici√™ncia e precis√£o.</p>
<p>A linguagem tamb√©m possibilita a cria√ß√£o de gr√°ficos e pain√©is de visualiza√ß√£o para m√©tricas, utilizando ferramentas como o Grafana. Desta forma, a PromQL se mostra fundamental para obter insights r√°pidos sobre o comportamento de aplica√ß√µes e infraestruturas.</p>
<p>Nesta se√ß√£o, vamos explorar os fundamentos da PromQL ‚Äî incluindo seletores, tipos de vetores e operadores b√°sicos ‚Äî e demonstrar como criar consultas simples para analisar dados de m√©tricas.</p>
<h3 id="time-series-database-tsdb">Time Series Database (TSDB)</h3>
<p>O Prometheus armazena os dados em um formato bin√°rio chamado TSDB (Time Series Database). O TSDB √© um banco de dados de s√©ries temporais otimizado para armazenar m√©tricas de forma eficiente.</p>
<p>Para simplificar o entendimento, imagine que voc√™ tem um di√°rio onde registra, todos os dias e nos mesmos hor√°rios, informa√ß√µes como a temperatura do ar, velocidade do vento e press√£o atmosf√©rica.</p>
<blockquote>
<p>Essas informa√ß√µes s√£o armazenadas em ordem cronol√≥gica (por tempo) e podem ser consultadas para ver como variam ao longo do tempo. Essa √© a ess√™ncia de um banco de dados de s√©rie temporal: armazenar e consultar dados que possuem uma dimens√£o temporal.</p></blockquote>
<p>Monitorar m√©tricas a partir de um banco de dados de s√©ries temporais traz v√°rias vantagens:</p>
<ul>
<li><strong>An√°lise hist√≥rica:</strong> Por armazenar dados em ordem cronol√≥gica, √© poss√≠vel analisar tend√™ncias e padr√µes ao longo do tempo. Isso ajuda a entender como o desempenho do sistema evolui e identificar tend√™ncias que possam indicar problemas futuros.</li>
<li><strong>Identifica√ß√£o de problemas:</strong> Com dados hist√≥ricos, podemos investigar incidentes passados para identificar causas raiz de problemas de desempenho ou disponibilidade.</li>
<li><strong>Alertas baseados no tempo:</strong> Dados hist√≥ricos permitem criar alertas que consideram tend√™ncias temporais, como alertar quando um recurso tem desempenho abaixo do normal em hor√°rios espec√≠ficos ou quando h√° tend√™ncias de crescimento preocupantes.</li>
<li><strong>Armazenamento escal√°vel:</strong> Bancos de dados de s√©ries temporais s√£o projetados para lidar com grandes volumes de dados e escalar horizontalmente, permitindo armazenar m√©tricas sem perda de desempenho.</li>
<li><strong>Integra√ß√£o com outras ferramentas:</strong> A maioria das ferramentas de monitoramento suporta a coleta de dados de TSDBs, facilitando a integra√ß√£o com diversos sistemas de an√°lise e observabilidade.</li>
</ul>
<p>Em resumo, usar um banco de dados de s√©rie temporal permite coletar, armazenar e analisar dados de m√©tricas de desempenho ao longo do tempo, possibilitando identificar problemas, tend√™ncias e padr√µes com facilidade.</p>
<p>O PromQL (Prometheus Query Language) √© a linguagem usada para consultar essas m√©tricas armazenadas no Prometheus. Com o PromQL, os usu√°rios criam consultas complexas para extrair informa√ß√µes acion√°veis das m√©tricas. Algumas capacidades importantes do PromQL incluem:</p>
<ul>
<li><strong>Fun√ß√µes de agrega√ß√£o:</strong> Permitem resumir dados ao longo do tempo ou por categorias, como m√©dia, soma, m√°ximo e m√≠nimo. Por exemplo, podemos usar <code>avg()</code> para calcular a m√©dia de uma m√©trica ao longo de um per√≠odo.</li>
<li><strong>Fun√ß√µes de filtragem:</strong> Permitem selecionar subconjuntos das m√©tricas com base em crit√©rios. Por exemplo, podemos usar seletores para filtrar por r√≥tulos (labels) espec√≠ficos, como pegar apenas m√©tricas de um servi√ßo ou data center espec√≠fico.</li>
<li><strong>Fun√ß√µes de transforma√ß√£o:</strong> Permitem transformar os dados brutos em valores mais √∫teis. Por exemplo, a fun√ß√£o <code>rate()</code> calcula a taxa de mudan√ßa de um contador (como n√∫mero de requisi√ß√µes por segundo) a partir da diferen√ßa entre dois pontos no tempo.</li>
</ul>
<p>PromQL tamb√©m suporta opera√ß√µes matem√°ticas b√°sicas (adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o) para combinar m√©tricas ou ajustar seus valores. Al√©m disso, permite o uso de operadores l√≥gicos (como <code>and</code> e <code>or</code>) para combinar express√µes e criar consultas ainda mais complexas.</p>
<p>Recursos avan√ßados, como uso de r√≥tulos (labels) para selecionar s√©ries espec√≠ficas e subconsultas aninhadas, tornam a PromQL uma linguagem poderosa e flex√≠vel. A seguir, exploraremos em detalhes esses conceitos e como utiliz√°-los na pr√°tica.</p>
<h3 id="seletores-de-m√©tricas">Seletores de m√©tricas</h3>
<p>Os seletores em PromQL funcionam como filtros que permitem escolher uma ou mais s√©ries de m√©tricas espec√≠ficas para consulta. Existem dois tipos principais de seletores:</p>
<ul>
<li><strong>Seletor por nome de m√©trica:</strong> Seleciona s√©ries pelo nome da m√©trica. Por exemplo, <code>http_requests_total</code> retorna todas as s√©ries temporais cuja m√©trica tenha esse nome.</li>
<li><strong>Seletor por label:</strong> Seleciona s√©ries com base em um ou mais labels (r√≥tulos) e seus valores. Por exemplo, se uma m√©trica <code>http_requests_total</code> possui os labels <code>method</code> e <code>handler</code>, podemos filtrar pelas s√©ries onde <code>method=&quot;GET&quot;</code> e <code>handler=&quot;/api/v1/users&quot;</code> escrevendo:</li>
</ul>


  <pre><code class="language-promql">http_requests_total{method=&#34;GET&#34;, handler=&#34;/api/v1/users&#34;}</code></pre>
 <p>Para combinar seletores de label, usamos operadores de correspond√™ncia (matchers) como <code>=</code>, <code>!=</code>, <code>=~</code> (regex correspondente) e <code>!~</code> (regex negativa). Esses operadores servem para comparar valores de labels (ou aplicar express√µes regulares) ao selecionar as s√©ries desejadas. Veja alguns exemplos:</p>
<ul>
<li><strong>Selecionar todas as m√©tricas cujo nome come√ßa com &ldquo;http&rdquo;:</strong></li>
</ul>


  <pre><code class="language-promql">{__name__=~&#34;http.*&#34;}</code></pre>
 <p>Aqui, usamos o label especial <code>__name__</code> (que representa o nome da m√©trica) com uma express√£o regular para corresponder qualquer m√©trica cujo nome comece com &ldquo;http&rdquo;.</p>
<ul>
<li><strong>Selecionar s√©ries que possuem o label <code>status</code> com valor exatamente &ldquo;error&rdquo;:</strong></li>
</ul>


  <pre><code class="language-promql">{status=&#34;error&#34;}</code></pre>
 <ul>
<li><strong>Selecionar s√©ries que possuem o label <code>app</code> com valor &ldquo;frontend&rdquo; ou &ldquo;backend&rdquo;:</strong></li>
</ul>


  <pre><code class="language-promql">{app=~&#34;frontend|backend&#34;}</code></pre>
 <p>Nesse caso, o operador regex <code>=~</code> com o padr√£o <code>frontend|backend</code> faz o seletor pegar s√©ries cujo label <code>app</code> seja &ldquo;frontend&rdquo; <strong>ou</strong> &ldquo;backend&rdquo;.</p>
<p>Ao usar express√µes regulares em seletores, √© importante ter cuidado para n√£o selecionar s√©ries indesejadas. Por exemplo, um seletor como <code>{job=~&quot;prom.*&quot;}</code> traria <strong>todas</strong> as s√©ries cujos labels <code>job</code> come√ßam com &ldquo;prom&rdquo; ‚Äî isso poderia incluir s√©ries que n√£o eram o alvo pretendido (como um job auxiliar relacionado).</p>
<p>Portanto, sempre procure ser o mais espec√≠fico poss√≠vel nos seletores para evitar correspond√™ncias acidentais.</p>
<h3 id="tipos-de-express√µes-em-promql">Tipos de express√µes em PromQL</h3>
<p>PromQL oferece v√°rios tipos de express√µes para manipular as s√©ries temporais coletadas pelo Prometheus. As principais incluem:</p>
<ul>
<li><strong>Express√µes aritm√©ticas:</strong> Realizam c√°lculos matem√°ticos entre s√©ries de m√©tricas ou entre s√©ries e constantes. Por exemplo, podemos somar duas m√©tricas (<code>metric_a + metric_b</code>), subtrair (<code>metric_a - metric_b</code>), multiplicar (<code>metric_a * 100</code> para converter em porcentagem), etc. Exemplo:</li>
</ul>


  <pre><code class="language-promql">node_cpu_seconds_total{mode=&#34;system&#34;} / node_cpu_seconds_total{mode=&#34;idle&#34;} * 100</code></pre>
 <p>Aqui calculamos a porcentagem de tempo que a CPU est√° no modo <code>&quot;system&quot;</code> em rela√ß√£o ao tempo no modo <code>&quot;idle&quot;</code>.</p>
<ul>
<li><strong>Fun√ß√µes de agrega√ß√£o:</strong> Agrupam e resumem s√©ries temporais. As fun√ß√µes incluem <code>sum</code> (soma), <code>avg</code> (m√©dia), <code>max</code> (m√°ximo), <code>min</code> (m√≠nimo), <code>count</code> (contagem), entre outras. Por exemplo:</li>
</ul>


  <pre><code class="language-promql">sum(rate(http_requests_total[5m])) by (job)</code></pre>
 <p>Nesta consulta, calculamos a taxa de requisi√ß√µes HTTP nos √∫ltimos 5 minutos (<code>rate(http_requests_total[5m])</code>) e em seguida somamos por <code>job</code>, ou seja, obtemos a taxa total por job.</p>
<ul>
<li><strong>Fun√ß√µes de filtro:</strong> Filtram s√©ries temporais com base em valores ou labels. Por exemplo, a fun√ß√£o <code>topk(5, metric)</code> retorna as 5 s√©ries com os maiores valores para a m√©trica especificada. Exemplo:</li>
</ul>


  <pre><code class="language-promql">topk(5, http_requests_total)</code></pre>
 <p>Isso retornar√° as 5 s√©ries de <code>http_requests_total</code> com os maiores valores.</p>
<ul>
<li>
<p><strong>Fun√ß√µes de transforma√ß√£o:</strong> Transformam s√©ries temporais de maneiras espec√≠ficas. Exemplos incluem:</p>
<ul>
<li><code>rate()</code>: calcula a taxa de aumento por segundo de um contador (derivada primeira) em uma janela de tempo.</li>
<li><code>irate()</code>: similar ao <code>rate()</code>, mas calcula a taxa instant√¢nea entre os dois pontos de dados mais recentes.</li>
<li><code>increase()</code>: calcula o total acumulado que o contador aumentou durante o per√≠odo.</li>
<li><code>delta()</code>: calcula a diferen√ßa absoluta entre o primeiro e o √∫ltimo valor em uma janela de tempo.</li>
<li><code>histogram_quantile()</code>: calcula um quantil (por exemplo, 0.95 para 95¬∫ percentil) a partir de um histograma.</li>
</ul>
<p>Exemplo de transforma√ß√£o com <code>histogram_quantile</code>:</p>


  <pre><code class="language-promql">histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))</code></pre>
 <p>Acima, estamos calculando o 95¬∫ percentil da distribui√ß√£o de dura√ß√£o de requisi√ß√µes HTTP nos √∫ltimos 5 minutos, usando as s√©ries <code>_bucket</code> do histograma de dura√ß√£o.</p>
</li>
<li>
<p><strong>Express√µes booleanas (compara√ß√µes):</strong> Avaliam condi√ß√µes verdadeiras ou falsas sobre os valores de s√©ries temporais. Os operadores de compara√ß√£o incluem <code>==</code> (igual), <code>!=</code> (diferente), <code>&gt;</code> (maior que), <code>&lt;</code> (menor que), <code>&gt;=</code> (maior ou igual) e <code>&lt;=</code> (menor ou igual). Por padr√£o, ao comparar duas s√©ries, o resultado √© uma s√©rie booleana (1 para true, 0 para false) <strong>apenas para as combina√ß√µes de s√©ries que correspondem exatamente nos labels</strong> (veremos mais sobre correspond√™ncia de vetores adiante). Tamb√©m √© poss√≠vel usar o modificador <code>bool</code> para for√ßar o resultado booleano a ser retornado.</p>
<p>Um exemplo de express√£o booleana combinada com c√°lculo:</p>
</li>
</ul>


  <pre><code class="language-promql">rate(http_requests_total{status_code=~&#34;5..&#34;}[1m]) 
  &gt; rate(http_requests_total{status_code=~&#34;2..&#34;}[1m]) * 0.1</code></pre>
 <p>Esta consulta verifica se a taxa de requisi√ß√µes HTTP com c√≥digos de status 5xx no √∫ltimo minuto √© maior que 10% da taxa de requisi√ß√µes 2xx no mesmo per√≠odo. O resultado ser√° uma s√©rie temporal booleana indicando, para cada combina√ß√£o de labels, se a condi√ß√£o √© verdadeira (1) ou falsa (0). Essa abordagem √© √∫til em alertas.</p>
<h3 id="vector-vs-range-vector">Vector vs. Range Vector</h3>
<p>Em PromQL, existem dois tipos principais de vetor que podem ser retornados em consultas: <strong>Instant Vector</strong> (vetor instant√¢neo) e <strong>Range Vector</strong> (vetor de intervalo).</p>
<ul>
<li>
<p><strong>Instant Vector (Vetor Instant√¢neo):</strong> Representa um conjunto de amostras (valor + timestamp) de m√∫ltiplas s√©ries temporais, todas no mesmo instante no tempo. Cada s√©rie temporal no resultado possui os mesmos labels originais e um √∫nico valor correspondente ao momento da avalia√ß√£o. Por exemplo, a express√£o <code>cpu_usage{instance=&quot;webserver-1&quot;}</code> retornaria, no momento atual, o valor mais recente da m√©trica <code>cpu_usage</code> para a inst√¢ncia <code>webserver-1</code>.</p>
</li>
<li>
<p><strong>Range Vector (Vetor de Intervalo):</strong> Representa um conjunto de s√©ries temporais, onde cada s√©rie cont√©m um conjunto de amostras dentro de um intervalo de tempo especificado. Em vez de um √∫nico valor, cada s√©rie traz todos os pontos (timestamp, valor) coletados naquele intervalo. Range vectors s√£o obtidos usando a sintaxe <code>[&lt;dura√ß√£o&gt;]</code> ap√≥s um seletor de m√©trica. Por exemplo, <code>cpu_usage{instance=&quot;webserver-1&quot;}[5m]</code> retorna os √∫ltimos 5 minutos de dados da m√©trica <code>cpu_usage</code> para a inst√¢ncia <code>webserver-1</code>. As fun√ß√µes como <code>rate()</code>, <code>increase()</code> e <code>avg_over_time()</code> tipicamente esperam um range vector como entrada.</p>
</li>
</ul>
<p><strong>Exemplos de uso de Instant e Range vectors:</strong></p>
<ul>
<li>Selecionando o valor <strong>atual</strong> (instant√¢neo) da m√©trica <code>cpu_usage</code> para a inst√¢ncia <code>&quot;webserver-1&quot;</code>:</li>
</ul>


  <pre><code class="language-promql">cpu_usage{instance=&#34;webserver-1&#34;}</code></pre>
 <ul>
<li>Calculando a diferen√ßa instant√¢nea entre duas m√©tricas (Instant Vector resultante):</li>
</ul>


  <pre><code class="language-promql">http_requests_total - http_requests_failed</code></pre>
 <p>Acima, subtra√≠mos, para cada combina√ß√£o de labels correspondente, o valor atual de <code>http_requests_failed</code> do valor atual de <code>http_requests_total</code>.</p>
<ul>
<li>Selecionando uma janela de <strong>5 minutos</strong> de dados da m√©trica <code>cpu_usage</code> para cada inst√¢ncia (Range Vector):</li>
</ul>


  <pre><code class="language-promql">cpu_usage[5m]</code></pre>
 <ul>
<li>Calculando a taxa (por segundo) de <code>cpu_usage</code> nos √∫ltimos 5 minutos para cada inst√¢ncia (note que <code>rate()</code> retorna um Instant Vector, com a taxa calculada para cada s√©rie):</li>
</ul>


  <pre><code class="language-promql">rate(cpu_usage[5m])</code></pre>
 <ul>
<li>Obtendo o valor <strong>m√°ximo</strong> da m√©trica <code>network_traffic</code> em um intervalo de 30 minutos, separado por inst√¢ncia:</li>
</ul>


  <pre><code class="language-promql">max_over_time(network_traffic[30m]) by (instance)</code></pre>
 <blockquote>
<p>Resumindo: um <strong>Instant Vector</strong> √© adequado para consultas que requerem o valor atual (ou de um instante espec√≠fico) de uma m√©trica, enquanto um <strong>Range Vector</strong> √© necess√°rio para consultas que envolvem c√°lculo ao longo do tempo (taxas, m√©dias m√≥veis, etc.). Muitas fun√ß√µes do PromQL, como <code>rate</code> e <code>avg_over_time</code>, s√≥ funcionam com range vectors porque precisam de v√°rios pontos de dados para produzir um resultado.</p></blockquote>
<h3 id="seguran√ßa-do-seletor-seletores-seguros-vs-inseguros">Seguran√ßa do seletor (Seletores seguros vs inseguros)</h3>
<p>Ao escrever consultas PromQL, √© importante construir seletores de m√©tricas que capturem exatamente as s√©ries desejadas, evitando resultados imprecisos ou indesejados. Alguns seletores podem ser considerados &ldquo;inseguros&rdquo; porque podem abranger s√©ries n√£o pretendidas.</p>
<p>Por exemplo, usar uma correspond√™ncia de prefixo muito gen√©rica em um label pode ser problem√°tico. Considere o seletor de label <code>job=~&quot;prom.*&quot;</code>. Ele selecionar√° todas as s√©ries de m√©tricas cujo label <code>job</code> come√ßa com &ldquo;prom&rdquo;.</p>
<p>Isso pode incluir n√£o apenas o job principal &ldquo;prometheus&rdquo;, mas tamb√©m qualquer outro job cujo nome comece com essas letras (por exemplo, um servi√ßo &ldquo;promtail&rdquo; ou &ldquo;prometheus-exporter&rdquo;). O resultado pode ser uma consulta retornando s√©ries inesperadas.</p>
<p>Para garantir seletores &ldquo;seguros&rdquo;, siga algumas pr√°ticas:</p>
<ul>
<li><strong>Seja expl√≠cito nos valores de label:</strong> Prefira usar correspond√™ncia exata (<code>=</code> ou <code>!=</code>) ou regex precisas. Por exemplo, se voc√™ quer m√©tricas do job Prometheus, use <code>job=&quot;prometheus&quot;</code> em vez de um regex gen√©rico.</li>
<li><strong>Evite padr√µes muito abrangentes:</strong> Como regra, s√≥ use regex se realmente precisar capturar m√∫ltiplos valores similares. Mesmo assim, tente restringir o padr√£o. Regex tendem a ser menos eficientes, pois precisam testar o padr√£o contra todos os valores conhecidos de um label, e podem indicar que talvez a configura√ß√£o dos labels deva ser melhorada.</li>
<li><strong>Conhe√ßa seus labels:</strong> Entenda quais labels cada m√©trica possui e quais valores s√£o poss√≠veis. Isso ajuda a criar seletores que n√£o tragam surpresas.</li>
</ul>
<p>Exemplos comparando seletores seguros vs inseguros:</p>
<ul>
<li><strong>Seguro:</strong> <code>http_requests_total{job=&quot;webserver&quot;, status=&quot;error&quot;}</code> ‚Äì seleciona exatamente as s√©ries de requisi√ß√µes HTTP do servi√ßo <code>webserver</code> que possuem o status &ldquo;error&rdquo;.</li>
<li><strong>Inseguro:</strong> <code>http_requests_total{status=~&quot;err.*&quot;}</code> ‚Äì poderia acidentalmente pegar algo como &ldquo;erroneous&rdquo; ou &ldquo;errata&rdquo; se esses fossem valores de status, al√©m de &ldquo;error&rdquo;. Prefira <code>status=&quot;error&quot;</code> se √© esse o valor exato desejado.</li>
<li><strong>Seguro:</strong> <code>{__name__=~&quot;^http_.*_total$&quot;}</code> ‚Äì seleciona m√©tricas cujo nome come√ßa com &ldquo;http_&rdquo; e termina com &ldquo;_total&rdquo;.</li>
<li><strong>Inseguro:</strong> <code>{__name__=~&quot;http&quot;}</code> (sem √¢ncoras ou wildcards definidos) ‚Äì esse seletor est√° incompleto e potencialmente inv√°lido. Sempre especifique padr√µes completos, por exemplo <code>http.*</code> se a inten√ß√£o √© &ldquo;come√ßa com http&rdquo;.</li>
</ul>
<p>Em suma, construa seletores de forma cuidadosa para evitar incluir s√©ries indesejadas. Isso garante que suas consultas retornem dados precisos e tamb√©m evita sobrecarregar o Prometheus com resultados excessivos.</p>
<h3 id="obsolesc√™ncia-do-vetor-instant√¢neo-staleness">Obsolesc√™ncia do vetor instant√¢neo (Staleness)</h3>
<p>Um detalhe importante ao usar vetores instant√¢neos: o Prometheus possui um mecanismo de <em>staleness</em> (obsolesc√™ncia) para lidar com s√©ries temporais que n√£o receberam novos dados em um intervalo de tempo.</p>
<p>Por padr√£o, se uma m√©trica n√£o tiver amostras recentes (normalmente nos √∫ltimos 5 minutos), o PromQL considerar√° essa s√©rie como <strong>ausente</strong> ou retornar√° um valor <code>NaN</code> (not a number) em vez de continuar mostrando um valor antigo. Isso evita apresentar dados &ldquo;velhos&rdquo; como se fossem atuais.</p>
<p>Por√©m, em algumas consultas, especialmente ao criar alertas, queremos detectar explicitamente quando uma m√©trica parou de ser enviada. Existem maneiras de lidar com isso:</p>
<ul>
<li><strong>Aumentar a janela de consulta</strong>: Em vez de consultar apenas o valor instant√¢neo, podemos consultar em uma janela de tempo para ver se h√° dados recentes. Por exemplo, usar uma subconsulta com intervalo:</li>
</ul>


  <pre><code class="language-promql">http_requests_total[5m]</code></pre>
 <p>garante que estamos inspecionando 5 minutos de dados. Ou ent√£o, usar fun√ß√µes como <code>max_over_time(metric[5m])</code> para pegar o √∫ltimo valor nos √∫ltimos 5 minutos.</p>
<ul>
<li><strong>Usar fun√ß√µes de aus√™ncia</strong>: O PromQL oferece a fun√ß√£o <code>absent()</code> que retorna 1 se a express√£o dentro dela n√£o retornar nenhum dado. Por exemplo:</li>
</ul>


  <pre><code class="language-promql">absent(rate(http_requests_total[5m]))</code></pre>
 <p>retornar√° 1 (com um label indicando a s√©rie buscada) se <strong>nenhuma</strong> s√©rie <code>http_requests_total</code> tiver dados nos √∫ltimos 5 minutos ‚Äì ou seja, indicando que possivelmente a coleta parou. Caso exista qualquer dado, <code>absent()</code> retorna uma s√©rie vazia.</p>
<p>Tamb√©m h√° a variante <code>absent_over_time(metric[dura√ß√£o])</code>, que verifica se <em>no intervalo dado</em> a m√©trica esteve ausente o tempo todo.</p>
<ul>
<li><strong>Combinar com condi√ß√µes booleanas</strong>: Podemos filtrar s√©ries pelo timestamp de sua √∫ltima amostra. A fun√ß√£o <code>timestamp(metric)</code> retorna o timestamp da √∫ltima amostra daquela m√©trica. Assim, express√µes como:</li>
</ul>


  <pre><code class="language-promql">timestamp(cpu_usage) &lt; time() - 30</code></pre>
 <p>identificam s√©ries cujo √∫ltimo timestamp √© inferior a 30 segundos atr√°s, ou seja, possivelmente desatualizadas.</p>
<p>Exemplos pr√°ticos:</p>
<ul>
<li><strong>Verificar m√©tricas ausentes</strong>:</li>
</ul>


  <pre><code class="language-promql">http_requests_total unless absent(rate(http_requests_total[5m]))</code></pre>
 <p>Aqui, usamos <code>unless</code> (que retorna a s√©rie da esquerda exceto quando a da direita existe) para s√≥ manter <code>http_requests_total</code> se ela n√£o estiver ausente nos √∫ltimos 5m. Isso efetivamente filtra fora s√©ries que n√£o receberam dados recentes.</p>
<ul>
<li><strong>Filtrar inst√¢ncias inativas (n√£o reportando)</strong>:</li>
</ul>


  <pre><code class="language-promql">cpu_usage unless absent_over_time(cpu_usage[2m])</code></pre>
 <p>Essa consulta retornaria <code>cpu_usage</code> atual apenas para inst√¢ncias que tiveram dados nos √∫ltimos 2 minutos. Se alguma inst√¢ncia parou de reportar (logo, ausente nos √∫ltimos 2m), ela ser√° exclu√≠da do resultado.</p>
<ul>
<li><strong>Combinar timestamp e booleano</strong>:</li>
</ul>


  <pre><code class="language-promql">cpu_usage * on(instance) group_left() ((time() - timestamp(cpu_usage)) &lt; 30)</code></pre>
 <p>Esta express√£o resulta no valor de <code>cpu_usage</code> apenas para inst√¢ncias cujo √∫ltimo timestamp tem menos de 30 segundos de idade. Estamos multiplicando o valor atual de <code>cpu_usage</code> por uma condi√ß√£o booleana que vale 1 apenas para inst√¢ncias atualizadas recentemente (e 0 para inst√¢ncias atrasadas).</p>
<p>O uso de <code>* on(instance) group_left()</code> garante que combinamos corretamente cada inst√¢ncia com sua condi√ß√£o booleana.</p>
<p>Em resumo, devido ao comportamento de <em>staleness</em>, um vetor instant√¢neo pode n√£o mostrar valores de m√©tricas atrasadas. Para contornar isso, podemos usar janelas de tempo maiores ou fun√ß√µes especiais como <code>absent()</code> para tratar casos de aus√™ncia de dados.</p>
<h3 id="fun√ß√µes-matem√°ticas-e-clamping">Fun√ß√µes Matem√°ticas e Clamping</h3>
<p>As fun√ß√µes em PromQL permitem manipular e processar m√©tricas de diversas formas. Dentre as mais comuns est√£o as <strong>fun√ß√µes matem√°ticas</strong>, que realizam opera√ß√µes aritm√©ticas sobre as s√©ries de m√©tricas. Temos desde as opera√ß√µes b√°sicas at√© fun√ß√µes matem√°ticas de biblioteca. Alguns exemplos:</p>
<ul>
<li><code>sqrt(vector)</code>: retorna a raiz quadrada de cada valor no vetor.</li>
<li><code>exp(vector)</code>: retorna o exponencial (e^x) de cada valor.</li>
<li><code>ln(vector)</code>: logaritmo natural.</li>
<li><code>log10(vector)</code>, <code>log2(vector)</code>: logaritmos base 10 e base 2, respectivamente.</li>
<li><code>ceil(vector)</code>, <code>floor(vector)</code>: arredondamento para cima ou baixo.</li>
</ul>
<p>Al√©m disso, PromQL fornece fun√ß√µes para limitar valores extremos (<em>clamping</em>). As fun√ß√µes <code>clamp_min(vector, scalar)</code> e <code>clamp_max(vector, scalar)</code> limitam os valores de um vetor a um m√≠nimo ou m√°ximo especificado. Por exemplo:</p>
<ul>
<li><code>clamp_min(metric, 0)</code>: garante que nenhum valor da s√©rie <code>metric</code> seja menor que 0 (valores negativos seriam substitu√≠dos por 0).</li>
<li><code>clamp_max(usage_ratio, 1)</code>: garante que valores acima de 1 em <code>usage_ratio</code> (por exemplo, 100% de uso) sejam reduzidos para 1.</li>
</ul>
<p>Essas fun√ß√µes de clamping s√£o √∫teis para evitar que ru√≠dos ou anomalias atrapalhem visualiza√ß√µes. Por exemplo, se um c√°lculo produz temporariamente um valor negativo ou um valor absurdamente alto por conta de algum atraso ou jitter, podemos usar clamping para limitar a escala dos gr√°ficos.</p>
<p><strong>Exemplos de uso de fun√ß√µes matem√°ticas e clamping:</strong></p>
<ul>
<li>Calcular a <strong>m√©dia</strong> dos valores de uma m√©trica nos √∫ltimos 5 minutos:</li>
</ul>


  <pre><code class="language-promql">avg_over_time(metric_name[5m])</code></pre>
 <ul>
<li>Calcular a <strong>soma</strong> dos valores de uma m√©trica nos √∫ltimos 10 minutos:</li>
</ul>


  <pre><code class="language-promql">sum_over_time(metric_name[10m])</code></pre>
 <ul>
<li>Calcular o <strong>m√°ximo</strong> valor de uma m√©trica nos √∫ltimos 1 hora, filtrando por um label:</li>
</ul>


  <pre><code class="language-promql">max_over_time(metric_name{label=&#34;value&#34;}[1h])</code></pre>
 <ul>
<li>Limitar o valor de uma m√©trica entre 0 e 100:</li>
</ul>


  <pre><code class="language-promql">clamp_min(clamp_max(metric_name, 100), 0)</code></pre>
 <p><em>(Aplica <code>clamp_max</code> para limitar a 100 e depois <code>clamp_min</code> para garantir m√≠nimo 0.)</em></p>
<ul>
<li>Converter uma fra√ß√£o em porcentagem e garantir que n√£o passe de 100%:</li>
</ul>


  <pre><code class="language-promql">clamp_max(success_ratio * 100, 100)</code></pre>
 <p>Supondo que <code>success_ratio</code> seja uma m√©trica ou express√£o que resulta em um valor entre 0 e 1 (por exemplo, propor√ß√£o de sucesso), multiplicamos por 100 para obter porcentagem e usamos <code>clamp_max</code> para nunca exibir acima de 100%.</p>
<p>Conhecer e utilizar essas fun√ß√µes permite realizar consultas mais avan√ßadas e obter insights mais precisos a partir dos dados coletados.</p>
<h3 id="timestamps-e-fun√ß√µes-de-tempo-e-data">Timestamps e Fun√ß√µes de Tempo e Data</h3>
<p>No PromQL, <em>timestamps</em> (carimbos de tempo) s√£o representados internamente como n√∫meros de ponto flutuante indicando segundos desde a √©poca Unix (1¬∫ de janeiro de 1970, 00:00:00 UTC).</p>
<p>Embora normalmente n√£o precisemos lidar diretamente com o valor num√©rico do timestamp, h√° fun√ß√µes √∫teis relacionadas ao tempo:</p>
<ul>
<li>
<p><code>time()</code>: retorna o timestamp Unix do momento atual (momento da avalia√ß√£o da consulta). Pode ser utilizado, por exemplo, para calcular diferen√ßas de tempo.
<em>Exemplo:</em> <code>time() - 3600</code> produziria um valor de timestamp correspondente a uma hora atr√°s.</p>
</li>
<li>
<p><code>timestamp(vetor)</code>: retorna, para cada s√©rie no vetor dado, o timestamp da √∫ltima amostra daquela s√©rie. √ötil para compara√ß√µes e detec√ß√£o de desatualiza√ß√£o (como visto anteriormente).</p>
</li>
</ul>
<p>Al√©m disso, existem fun√ß√µes para extrair componentes de data/hora do timestamp de cada amostra de uma s√©rie:</p>
<ul>
<li><code>day_of_week(vetor)</code>: retorna o dia da semana (0‚Äì6, onde 0 = domingo, 1 = segunda, etc.) de cada amostra no vetor dado.</li>
<li><code>hour(vetor)</code>: retorna a hora (0‚Äì23) do timestamp de cada amostra.</li>
<li><code>day(vetor)</code>, <code>month(vetor)</code>, <code>year(vetor)</code>: retornam respectivamente o dia do m√™s, o m√™s (1‚Äì12) e o ano do timestamp de cada amostra.</li>
</ul>
<p>Essas fun√ß√µes permitem criar consultas que dependem da hora ou dia. Por exemplo, voc√™ pode querer detectar padr√µes diurnos ou disparar alertas apenas em dias √∫teis.</p>
<p><strong>Exemplos de uso de fun√ß√µes de tempo e data:</strong></p>
<ul>
<li>Obter o timestamp atual (como escalar):</li>
</ul>


  <pre><code class="language-promql">time()</code></pre>
 <ul>
<li>Extrair a hora atual do dia como um valor (0‚Äì23):</li>
</ul>


  <pre><code class="language-promql">hour(vector( time() ))</code></pre>
 <p>Aqui, <code>vector(time())</code> converte o escalar retornado por <code>time()</code> em um vetor (necess√°rio porque <code>hour()</code> espera um vetor). O resultado √© um vetor com um √∫nico valor: a hora do dia.</p>
<ul>
<li>Calcular a m√©dia de uma m√©trica por hora do dia, nos √∫ltimos 24h (usando subconsulta para separar por hora):</li>
</ul>


  <pre><code class="language-promql">avg_over_time(my_metric[1h])[24h:1h]</code></pre>
 <p>Essa express√£o √© uma subconsulta que calcula <code>avg_over_time(my_metric[1h])</code> (m√©dia de <code>my_metric</code> em cada janela de 1h) para cada hora nas √∫ltimas 24 horas. Isso produz uma s√©rie de 24 pontos, um para cada hora, que pode ser √∫til para observar a varia√ß√£o hor√°ria.</p>
<ul>
<li>Selecionar o valor m√©dio da m√©trica <code>my_metric</code> no √∫ltimo dia:</li>
</ul>


  <pre><code class="language-promql">avg_over_time(my_metric[1d])</code></pre>
 <p>(Assumindo que h√° dados suficientes para cobrir o √∫ltimo dia inteiro.)</p>
<ul>
<li><strong>Nota:</strong> Para consultar um per√≠odo espec√≠fico (entre timestamps espec√≠ficos), n√£o h√° uma sintaxe direta dentro do PromQL. Em vez disso, usa-se a API de consulta de intervalos do Prometheus (fornecendo <code>start</code> e <code>end</code> no request) ou ferramentas como Grafana para delimitar visualmente o per√≠odo. Dentro do PromQL, opera√ß√µes de tempo s√£o relativas (como &ldquo;√∫ltimos 5 minutos&rdquo;, &ldquo;√∫ltimas 24h&rdquo;, etc.) em rela√ß√£o ao momento de avalia√ß√£o.</li>
</ul>
<h3 id="counter-range-vectors-agrega√ß√£o-temporal-e-subconsultas">Counter Range Vectors, Agrega√ß√£o Temporal e Subconsultas</h3>
<p><strong>Counter Range Vectors</strong>: Contadores s√£o m√©tricas que apenas aumentam (ou resetam para zero e voltam a aumentar). Exemplos: n√∫mero total de requisi√ß√µes atendidas, bytes transferidos, etc. Quando consultamos diretamente um <em>counter</em> como range vector, obteremos uma s√©rie de pontos que s√≥ crescem (com eventuais resets). Para extrair informa√ß√µes √∫teis (como taxa de eventos por segundo ou aumentos em determinado per√≠odo) usamos fun√ß√µes especiais:</p>
<ul>
<li><code>rate(counter[5m])</code>: Calcula a <strong>taxa m√©dia por segundo</strong> de incremento do contador nos √∫ltimos 5 minutos. Essa fun√ß√£o j√° lida corretamente com resets do contador (ignorando as quedas abruptas devido a resets e calculando a taxa considerando isso).</li>
<li><code>irate(counter[5m])</code>: Calcula a <strong>taxa instant√¢nea</strong> (baseada apenas nos dois pontos mais recentes dentro dos 5 minutos). √â mais ruidosa, mas pode reagir mais rapidamente a mudan√ßas repentinas.</li>
<li><code>increase(counter[1h])</code>: Calcula <strong>quanto o contador aumentou</strong> no √∫ltimo 1 hora. Essencialmente integra a taxa ao longo do per√≠odo.</li>
</ul>
<p><strong>Agrega√ß√£o atrav√©s do tempo (Aggregating Across Time)</strong>: √Äs vezes, queremos primeiro agregar os dados e depois analisar a evolu√ß√£o temporal dessa agrega√ß√£o. As <strong>subconsultas</strong> nos permitem isso. Uma <em>subquery</em> (subconsulta) √© quando temos uma express√£o do PromQL seguida de um intervalo entre colchetes e possivelmente uma resolu√ß√£o, por exemplo: <code>expr[dura√ß√£o:passo]</code>. Isso faz o Prometheus avaliar <code>expr</code> repetidamente ao longo do intervalo dado, produzindo um range vector como resultado.</p>
<p>Por exemplo, <code>avg_over_time(rate(http_requests_total[1m])[24h:1h])</code> funciona assim:</p>
<ul>
<li>Internamente, <code>rate(http_requests_total[1m])</code> √© avaliado para cada passo de 1h dentro das √∫ltimas 24h, gerando a taxa m√©dia por minuto calculada a cada hora.</li>
<li>Em seguida, <code>avg_over_time(...[24h:1h])</code> calcula a m√©dia desses 24 valores (um por hora) <strong>no tempo atual</strong>. Na pr√°tica, isso nos daria a m√©dia da taxa hor√°ria de requisi√ß√µes no dia.</li>
</ul>
<p>Subconsultas s√£o muito poderosas e foram aprimoradas a partir do Prometheus 2.7. Com elas √© poss√≠vel, por exemplo, calcular tend√™ncias, baselines e sazonalidade de forma compacta.</p>
<p><strong>Exemplos avan√ßados de subconsultas e an√°lise de tend√™ncias:</strong></p>
<ul>
<li><strong>Tend√™ncia de taxa de erro (janela m√≥vel):</strong> Calcular a m√©dia da taxa de erros em janelas de 1 hora, ao longo das √∫ltimas 24 horas:</li>
</ul>


  <pre><code class="language-promql">avg_over_time(
  rate(http_requests_total{status=~&#34;5..&#34;}[1m])[24h:1h]
)</code></pre>
 <p>Essa consulta gera 24 pontos (taxa de erro m√©dia de cada hora nas √∫ltimas 24h) e depois calcula a m√©dia disso tudo (ou seja, a m√©dia di√°ria da taxa de erro). Poder√≠amos tamb√©m omitir a fun√ß√£o externa para simplesmente visualizar a s√©rie das √∫ltimas 24 horas e identificar padr√µes de aumento ou redu√ß√£o de erros ao longo do dia.</p>
<ul>
<li><strong>Baseline de performance (compara√ß√£o com m√©dia hist√≥rica):</strong> Comparar a performance atual com a m√©dia da √∫ltima semana:</li>
</ul>


  <pre><code class="language-promql">rate(http_requests_total[5m]) 
  / avg_over_time(rate(http_requests_total[5m])[7d])</code></pre>
 <p>Essa consulta produz uma raz√£o: valores acima de 1 indicam que a taxa atual de requisi√ß√µes est√° <strong>acima</strong> da m√©dia semanal; valores abaixo de 1, abaixo da m√©dia. Isso pode ser √∫til para identificar desvios significativos de tr√°fego.</p>
<ul>
<li><strong>Detec√ß√£o de anomalia sazonal (padr√£o hor√°rio):</strong> Comparar o tr√°fego atual com o padr√£o do √∫ltimo dia:</li>
</ul>


  <pre><code class="language-promql">rate(http_requests_total[5m]) 
  / avg_over_time(rate(http_requests_total[5m])[24h:1h])</code></pre>
 <p>Aqui, o denominador <code>avg_over_time(...[24h:1h])</code> produz a m√©dia da taxa em cada hora do dia anterior. Dividindo a taxa atual por esse valor da mesma hora ontem, podemos identificar se o tr√°fego est√° anormalmente alto ou baixo para este hor√°rio do dia.</p>
<ul>
<li><strong>Diferen√ßa di√°ria (subconsulta com offset):</strong> Para calcular a diferen√ßa em uma m√©trica entre hoje e ontem, podemos usar <code>offset</code>. Exemplo:</li>
</ul>


  <pre><code class="language-promql">my_metric - my_metric offset 1d</code></pre>
 <p>Isso resulta em quanto <code>my_metric</code> variou em compara√ß√£o com exatamente 24 horas atr√°s.</p>
<ul>
<li><strong>Soma acumulada (exemplo de subconsulta):</strong></li>
</ul>


  <pre><code class="language-promql">sum(my_counter) - sum(my_counter) offset 1d</code></pre>
 <p>Este exemplo soma o contador <code>my_counter</code> (provavelmente de v√°rias inst√¢ncias) e subtrai o valor de 1 dia atr√°s, mostrando o incremento total em um dia. Essa √© outra forma de calcular algo similar a <code>increase(my_counter[1d])</code>.</p>
<p>Em todos esses casos, as subconsultas <code>[ ... ]</code> est√£o permitindo observar ou reutilizar resultados ao longo do tempo dentro de uma √∫nica express√£o.</p>
<h3 id="histogramas-mudan√ßa-de-tipo-altera√ß√£o-de-labels-e-ordena√ß√£o">Histogramas, Mudan√ßa de Tipo, Altera√ß√£o de Labels e Ordena√ß√£o</h3>
<p><strong>Histogramas:</strong> Em Prometheus, histogramas s√£o uma forma de metricar distribui√ß√µes de valores (dura√ß√£o de requisi√ß√µes, tamanho de payloads, etc.). Um histograma cl√°ssico consiste em m√∫ltiplas s√©ries: por conven√ß√£o, se a m√©trica base √© <code>request_duration_seconds</code>, as s√©ries ser√£o:</p>
<ul>
<li><code>request_duration_seconds_bucket{le=&quot;0.1&quot;, ...}</code> (um bucket contando quantas observa√ß√µes &lt;= 0.1s)</li>
<li>v√°rios outros buckets com diferentes limites <code>le</code> (le = limite inferior ou igual)</li>
<li><code>request_duration_seconds_count</code> (contagem total de observa√ß√µes)</li>
<li><code>request_duration_seconds_sum</code> (soma total dos valores observados)</li>
</ul>
<p>Para analisar histogramas, geralmente somamos as s√©ries <code>_bucket</code> <em>por limite</em> para agregar todas as inst√¢ncias ou r√≥tulos de interesse. <strong>√â crucial incluir o label <code>le</code> ao agregar buckets.</strong> Por exemplo, a forma correta de agregar um histograma de dura√ß√£o por job seria:</p>


  <pre><code class="language-promql">sum by (job, le) (rate(http_request_duration_seconds_bucket[5m]))</code></pre>
 <p>Depois de agregado adequadamente, podemos aplicar <code>histogram_quantile()</code> para extrair quantis (p50, p90, p99, etc.).</p>
<p><strong>Trabalhando corretamente com histogramas:</strong></p>
<ul>
<li><em>Exemplo can√¥nico (p99 de lat√™ncia HTTP)</em>:</li>
</ul>


  <pre><code class="language-promql">histogram_quantile(
  0.99, 
  sum(rate(http_request_duration_seconds_bucket[5m])) by (le)
)</code></pre>
 <p>Esse retorna o 99¬∫ percentil da dura√ß√£o das requisi√ß√µes HTTP considerando todos os buckets. Note o uso de <code>by (le)</code> dentro do sum.</p>
<ul>
<li><em>Agregando por labels extras:</em> Se quisermos o percentil por <code>job</code> e <code>instance</code>, por exemplo, devemos manter esses labels na agrega√ß√£o, al√©m do <code>le</code>:</li>
</ul>


  <pre><code class="language-promql">histogram_quantile(
  0.95, 
  sum(rate(http_request_duration_seconds_bucket[5m])) by (job, instance, le)
)</code></pre>
 <ul>
<li>
<p><em>Evitando erro comum:</em> <strong>Nunca</strong> esque√ßa o <code>by (le)</code> ao somar buckets de um histograma cl√°ssico. Por exemplo, isto est√° <strong>errado</strong>:</p>


  <pre><code class="language-promql"># Exemplo INCORRETO - aus√™ncia de by(le)
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])))</code></pre>
 </li>
</ul>
<p>Sem agrupar por <code>le</code>, os valores de buckets se somam indevidamente, tornando o resultado do quantil incorreto.</p>
<p>No Prometheus 3.0, foram introduzidos os <strong>histogramas nativos</strong> (ainda experimentais). Eles visam simplificar e tornar mais eficiente o uso de histogramas (evitando lidar com dezenas de s√©ries <code>_bucket</code>).</p>
<p>Com histogramas nativos, existem inclusive novas fun√ß√µes como <code>histogram_count()</code>, <code>histogram_sum()</code> e <code>histogram_avg()</code> para extrair diretamente contagem, soma e m√©dia dos histogramas.</p>
<p>Al√©m disso, h√° a fun√ß√£o <code>histogram_fraction()</code> para calcular fra√ß√µes entre limites. Embora seja um recurso promissor, a maioria dos usu√°rios ainda trabalha com histogramas cl√°ssicos <code>_bucket</code> at√© que os nativos se estabilizem.</p>
<p><strong>Mudan√ßa de tipo (convers√£o Escalar &lt;-&gt; Vetor):</strong> Em algumas situa√ß√µes avan√ßadas, voc√™ pode precisar converter escalares em vetores ou vice-versa:</p>
<ul>
<li><code>scalar(vetor)</code> ‚Äì Converte um vetor de uma √∫nica s√©rie temporal (com um √∫nico valor) em um escalar simples. Isso √© √∫til, por exemplo, quando voc√™ calculou um valor m√≠nimo ou m√°ximo e quer us√°-lo em uma compara√ß√£o global.
<em>Exemplo:</em> <code>scalar(min(up{job=&quot;webserver&quot;}))</code> ‚Äì isso resultar√° em um escalar 0 ou 1 indicando se <strong>alguma</strong> inst√¢ncia do job &ldquo;webserver&rdquo; est√° ca√≠da (0 se o m√≠nimo for 0, ou seja, pelo menos uma inst√¢ncia est√° down; 1 se todas est√£o up).</li>
<li><code>vector(escalar)</code> ‚Äì O oposto, pega um escalar e o transforma em um vetor (sem labels). √ötil se voc√™ precisa combinar um n√∫mero puro com s√©ries.
<em>Exemplo:</em> <code>vector(1)</code> ‚Äì produziria um vetor contendo apenas o valor 1.</li>
</ul>
<p><strong>Altera√ß√£o de Labels:</strong> √Äs vezes √© necess√°rio renomear ou copiar labels nas s√©ries. Fun√ß√µes √∫teis:</p>
<ul>
<li><code>label_replace(vetor, &quot;label_destino&quot;, &quot;valor_novo&quot;, &quot;label_origem&quot;, &quot;regex&quot;)</code> ‚Äì Retorna um vetor a partir de outro, adicionando ou modificando um label. Ele pega o valor do <code>label_origem</code> que case com a regex fornecida e o coloca em <code>label_destino</code> usando <code>valor_novo</code> (onde <code>'$1'</code> pode referenciar grupos da regex).
<em>Exemplo:</em></li>
</ul>


  <pre><code class="language-promql">label_replace(my_metric, &#34;new_label&#34;, &#34;$1&#34;, &#34;old_label&#34;, &#34;(.*)&#34;)</code></pre>
 <p>Isso criaria (ou sobrescreveria) <code>new_label</code> em cada s√©rie de <code>my_metric</code>, copiando exatamente o valor de <code>old_label</code> (j√° que <code>(.*)</code> captura todo o valor e <code>$1</code> insere ele).</p>
<ul>
<li><code>label_join(vetor, &quot;label_destino&quot;, &quot;sep&quot;, &quot;label1&quot;, &quot;label2&quot;, ...)</code> ‚Äì Concatena m√∫ltiplos labels em um s√≥. Ex: <code>label_join(my_metric, &quot;instance_job&quot;, &quot;-&quot;, &quot;instance&quot;, &quot;job&quot;)</code> criaria um novo label <code>instance_job</code> juntando os valores de <code>instance</code> e <code>job</code> separados por um <code>-</code>.</li>
</ul>
<p>Essas fun√ß√µes n√£o s√£o usadas com frequ√™ncia em consultas ad-hoc, mas podem ser muito √∫teis ao preparar m√©tricas para certas compara√ß√µes ou ao lidar com diferen√ßas de rotulagem entre m√©tricas.</p>
<p><strong>Ordena√ß√£o (Sorting):</strong> Para ordenar resultados, podemos usar as fun√ß√µes <code>sort(vector)</code> (ordem crescente) e <code>sort_desc(vector)</code> (ordem decrescente). Isso pode ser √∫til quando estamos interessados no topo ou no final de uma lista de resultados (embora muitas vezes <code>topk</code> e <code>bottomk</code> j√° cubram esses casos).</p>
<p>Exemplos r√°pidos:</p>
<ul>
<li>
<p>Ordenar todas as inst√¢ncias pelo uso de CPU decrescente:</p>


  <pre><code class="language-promql">sort_desc(rate(node_cpu_seconds_total{mode!=&#34;idle&#34;}[5m])) by (instance))</code></pre>
 <p><em>(Aqui somamos as CPUs por inst√¢ncia implicitamente ao usar o <code>by (instance)</code> na express√£o, e depois ordenamos.)</em></p>
</li>
<li>
<p>Ordenar alfab√©ticamente por valor de um label (pouco comum, mas poss√≠vel):</p>


  <pre><code class="language-promql">sort(my_metric)</code></pre>
 <p><em>(Se <code>my_metric</code> √© um escalar ou tem apenas um valor por s√©rie, <code>sort()</code> essencialmente ordenar√° pelos labels j√° que os valores podem ser iguais.)</em></p>
</li>
</ul>
<h3 id="valores-ausentes-absent--missing-values">Valores ausentes (Absent / Missing Values)</h3>
<p>Valores ausentes podem ocorrer quando uma m√©trica n√£o √© reportada (por exemplo, um servi√ßo caiu ou foi desligado). Em consultas PromQL, um valor ausente simplesmente n√£o aparece no resultado. Entretanto, podemos detectar explicitamente a aus√™ncia de s√©ries usando a fun√ß√£o <code>absent()</code> mencionada anteriormente.</p>
<p>Recapitulando o uso de <code>absent()</code>:</p>
<ul>
<li><code>absent(metric)</code> ‚Äì Retorna uma s√©rie sem labels (ou com labels especificados na consulta) com valor 1 se <strong>nenhuma s√©rie</strong> correspondente a <code>metric</code> est√° presente, ou retorna nada (vazio) caso contr√°rio. Isso √© muito √∫til em regras de alerta: um alerta de &ldquo;TargetDown&rdquo; pode ser escrito como <code>absent(up{job=&quot;myjob&quot;} == 1)</code> para disparar quando nenhum alvo daquele job estiver up.</li>
</ul>
<p>Exemplo:</p>


  <pre><code class="language-promql">absent(up{job=&#34;node&#34;} == 1)</code></pre>
 <p>Acima, a express√£o <code>up{job=&quot;node&quot;} == 1</code> resultaria em 1 para cada inst√¢ncia de <code>node</code> que esteja up, ent√£o <code>absent(...)</code> retornaria 1 (sem label) se nenhuma inst√¢ncia de <code>node</code> estiver up (ou seja, o resultado dentro foi vazio). Se pelo menos uma inst√¢ncia estiver up, <code>absent</code> n√£o retorna nada.</p>
<p>Da mesma forma, <code>absent_over_time(metric[5m])</code> verifica se <em>nenhum</em> ponto de <code>metric</code> apareceu nos √∫ltimos 5 minutos.</p>
<p><strong>Importante:</strong> Ao visualizar dados no gr√°fico do Prometheus ou Grafana, s√©ries ausentes simplesmente n√£o aparecem. Por isso, ao compor dashboards ou alertas, pode ser √∫til usar consultas que retornem 0 explicitamente quando algo est√° ausente para facilitar a visualiza√ß√£o. Uma t√©cnica √© usar a opera√ß√£o <code>OR</code> com <code>absent()</code>. Exemplo:</p>


  <pre><code class="language-promql">rate(http_requests_total[5m]) or absent(http_requests_total)</code></pre>
 <p>Isso retornar√° a taxa de requisi√ß√µes normalmente; se nenhuma s√©rie existir, em vez de nada, retornar√° 1 (ou outro valor constante) indicando aus√™ncia.</p>
<h3 id="fun√ß√µes-avan√ßadas-e-menos-conhecidas">Fun√ß√µes avan√ßadas e menos conhecidas</h3>
<p>Algumas fun√ß√µes do PromQL s√£o menos conhecidas, mas podem ser extremamente poderosas em cen√°rios espec√≠ficos:</p>
<ul>
<li>
<p><strong><code>resets(counter[interval])</code>:</strong> Conta quantas vezes um contador &ldquo;resetou&rdquo; (voltou a zero) no per√≠odo. √ötil para detectar reinicializa√ß√µes de aplicativos ou problemas de coleta.
<em>Exemplos:</em></p>


  <pre><code class="language-promql">resets(http_requests_total[5m])</code></pre>
 <p>Contaria quantos resets ocorreram no <code>http_requests_total</code> nos √∫ltimos 5 minutos. Se esse n√∫mero for &gt; 0 constantemente, pode indicar que o servi√ßo est√° reiniciando frequentemente (se o contador for interno ao servi√ßo) ou que h√° overflow de contadores.</p>
</li>
<li>
<p><strong><code>changes(series[interval])</code>:</strong> Conta quantas vezes o valor de uma s√©rie mudou durante o intervalo. Isso vale para qualquer m√©trica (n√£o apenas counters). Pode indicar instabilidade ou flapping.
<em>Exemplo:</em></p>


  <pre><code class="language-promql">changes(process_start_time_seconds[5m]) &gt; 0</code></pre>
 <p>O exemplo acima retornaria 1 para inst√¢ncias cujo <code>process_start_time_seconds</code> (normalmente um timestamp de in√≠cio do processo) tenha mudado nos √∫ltimos 5 minutos ‚Äî ou seja, o processo reiniciou nesse per√≠odo.</p>
</li>
<li>
<p><strong><code>predict_linear(series[interval], passos_no_futuro)</code>:</strong> Realiza uma extrapola√ß√£o linear do valor da s√©rie com base na tend√™ncia nos √∫ltimos intervalos e prev√™ o valor daqui a X segundos (informado em <code>passos_no_futuro</code>). √ötil para prever quando algo alcan√ßar√° um certo limite.
<em>Exemplo:</em></p>


  <pre><code class="language-promql">predict_linear(node_filesystem_free_bytes[1h], 3600) &lt; 0</code></pre>
 <p>Poderia ser usado para alertar se a tend√™ncia de queda do espa√ßo livre prev√™ que em 1 hora (<code>3600</code> segundos) o espa√ßo chegaria a zero.</p>
</li>
<li>
<p><strong><code>holt_winters(series[interval], sf, tf)</code>:</strong> Embora mais comum no Graphite, o PromQL tamb√©m tem uma fun√ß√£o de previs√£o chamada <code>holt_winters</code> (Holt-Winters, s√©rie temporal com tend√™ncia e sazonalidade). Aceita uma s√©rie (geralmente resultado de subconsulta) e realiza suaviza√ß√£o exponencial dupla. No entanto, essa fun√ß√£o √© raramente usada diretamente em alertas, servindo mais para visualiza√ß√£o de tend√™ncias suavizadas.</p>
</li>
<li>
<p><strong>Fun√ß√µes para histogramas nativos (Prometheus 3.x):</strong></p>
<ul>
<li><code>histogram_count()</code> e <code>histogram_sum()</code> ‚Äì Retornam, respectivamente, a contagem total e a soma total das observa√ß√µes de histogramas (cl√°ssicos ou nativos). Para histogramas cl√°ssicos, esses usam as s√©ries <code>_count</code> e <code>_sum</code> internas; para nativos, usam os valores codificados.</li>
<li><code>histogram_avg()</code> ‚Äì Computa a m√©dia dos valores observados em cada histograma, equivalente a <code>histogram_sum/histogram_count</code>.</li>
<li><code>histogram_fraction(lower, upper, hist)</code> ‚Äì Estima a fra√ß√£o de observa√ß√µes dentro do intervalo <code>[lower, upper]</code> para cada histograma. √ötil, por exemplo, para calcular <em>Apdex</em> (fra√ß√£o de requisi√ß√µes abaixo de um certo limiar de lat√™ncia).</li>
</ul>
</li>
</ul>
<p>Lembrando que algumas dessas fun√ß√µes mais novas podem requerer flags experimentais, dependendo da vers√£o do Prometheus.</p>
<h3 id="operadores-aritm√©ticos-e-correspond√™ncia-de-vetores-simples">Operadores Aritm√©ticos e Correspond√™ncia de Vetores Simples</h3>
<p>PromQL permite usar operadores bin√°rios entre s√©ries temporais para calcular novas s√©ries. Os operadores aritm√©ticos s√£o: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (m√≥dulo) e <code>^</code> (exponencia√ß√£o). Eles podem operar entre:</p>
<ul>
<li>Escalar e escalar (ex.: <code>2 * 3</code>)</li>
<li>Vetor e escalar (o escalar aplica-se a todos os valores do vetor; ex.: <code>metric * 100</code>)</li>
<li>Vetor e vetor (aqui entra o conceito de correspond√™ncia de vetores)</li>
</ul>
<p>Quando aplicamos um operador entre dois vetores (Instant Vectors), o PromQL realiza a opera√ß√£o <strong>par a par</strong> entre s√©ries que &ldquo;correspondem&rdquo; umas √†s outras. Essa correspond√™ncia por padr√£o requer que as s√©ries tenham exatamente os mesmos labels (nome da m√©trica pode ser diferente, mas os r√≥tulos-chave e seus valores devem coincidir).</p>
<p>Exemplo simples: se temos as s√©ries <code>metric_a{host=&quot;A&quot;, env=&quot;prod&quot;}</code> com valor X e <code>metric_b{host=&quot;A&quot;, env=&quot;prod&quot;}</code> com valor Y, ent√£o <code>metric_a + metric_b</code> retornar√° <code>{host=&quot;A&quot;, env=&quot;prod&quot;}</code> com valor X+Y. Se n√£o houver correspond√™ncia exata de labels entre alguma s√©rie de <code>metric_a</code> e alguma de <code>metric_b</code>, aquela combina√ß√£o n√£o aparece no resultado.</p>
<p><strong>Correspond√™ncia simples</strong>: Por padr√£o, todos os labels (exceto o nome da m√©trica) devem casar entre as duas s√©ries para a opera√ß√£o acontecer. √â poss√≠vel ajustar isso com modificadores que veremos adiante (<code>on</code> e <code>ignoring</code>).</p>
<p>Se quisermos for√ßar a opera√ß√£o em todas as combina√ß√µes (o que raramente faz sentido), h√° o modificador <code>cross_join</code> (PromQL &gt;2.9), mas geralmente ele n√£o √© utilizado porque o comportamento padr√£o j√° √© suficiente.</p>
<p>Os operadores tamb√©m podem ser usados com o modificador <code>bool</code>, mas isso s√≥ se aplica a operadores de compara√ß√£o, n√£o aos aritm√©ticos.</p>
<p>Exemplos pr√°ticos de operadores aritm√©ticos:</p>
<ul>
<li>
<p><strong>Soma de m√©tricas</strong>:</p>


  <pre><code class="language-promql">http_requests_total{status=&#34;200&#34;} &#43; http_requests_total{status=&#34;500&#34;}</code></pre>
 <p>Aqui, somamos as s√©ries de requisi√ß√µes com status 200 e as com status 500, casando por quaisquer outros labels (por exemplo, inst√¢ncia). O resultado √© o total combinado de requisi√ß√µes de sucesso e erro.</p>
</li>
<li>
<p><strong>Diferen√ßa de m√©tricas</strong>:</p>


  <pre><code class="language-promql">node_memory_MemTotal_bytes - node_memory_MemFree_bytes</code></pre>
 <p>Calcula a mem√≥ria em uso (diferen√ßa entre total e livre) para cada inst√¢ncia, assumindo que ambas as m√©tricas compartilham os labels de inst√¢ncia.</p>
</li>
<li>
<p><strong>Multiplica√ß√£o por escalar</strong>:</p>


  <pre><code class="language-promql">cpu_usage * 100</code></pre>
 <p>Converte a m√©trica <code>cpu_usage</code> (talvez como fra√ß√£o 0‚Äì1) em porcentagem.</p>
</li>
<li>
<p><strong>Combina√ß√£o de dois vetores diferentes</strong>:</p>


  <pre><code class="language-promql">errors_total / requests_total</code></pre>
 <p>Pode calcular a taxa de erro (assumindo que <code>errors_total</code> e <code>requests_total</code> compartilham labels como servi√ßo/endpoint). Isso exige correspond√™ncia exata de labels.</p>
</li>
</ul>
<p>No caso acima, se <code>errors_total</code> existir para um determinado label e <code>requests_total</code> n√£o, essa combina√ß√£o n√£o retorna resultado. Podemos usar <em>vector matching</em> avan√ßado (pr√≥xima se√ß√£o) para ajustar essas situa√ß√µes.</p>
<h3 id="correspond√™ncia-de-s√©ries-temporais-on-ignoring-group_left-group_right">Correspond√™ncia de S√©ries Temporais: <code>on()</code>, <code>ignoring()</code>, <code>group_left</code>, <code>group_right</code></h3>
<p>Quando combinamos m√©tricas diferentes (vetor-vetor), muitas vezes precisamos controlar quais labels s√£o usados para fazer o <em>join</em> (uni√£o) entre as s√©ries de cada lado da opera√ß√£o. √â aqui que entram os modificadores <code>on</code> e <code>ignoring</code>, e os operadores de jun√ß√£o externa <code>group_left</code> e <code>group_right</code>:</p>
<ul>
<li>
<p><strong><code>on(lista_de_labels)</code></strong>: Especifica explicitamente quais labels devem ser usados para casar as s√©ries ao aplicar o operador. Todos os demais labels s√£o ignorados no matching (exceto os do <code>on</code> listados).
<em>Exemplo:</em></p>


  <pre><code class="language-promql">errors_total / on(instance) requests_total</code></pre>
 <p>Aqui dizemos: combine s√©ries de <code>errors_total</code> e <code>requests_total</code> que tenham o mesmo valor de <code>instance</code>. Labels diferentes de <code>instance</code> ser√£o ignorados na compara√ß√£o. Isso √© √∫til se, por exemplo, <code>errors_total</code> tem um label <code>status=&quot;5xx&quot;</code> enquanto <code>requests_total</code> n√£o tem o label <code>status</code>. Sem o <code>on(instance)</code>, essas s√©ries n√£o casariam por terem conjuntos de labels distintos.</p>
</li>
<li>
<p><strong><code>ignoring(lista_de_labels)</code></strong>: O inverso do <code>on</code>. Use todos os labels <em>exceto</em> os listados para fazer o matching. Ou seja, finge que os labels mencionados n√£o existem nos vetores ao procurar pares correspondentes.
<em>Exemplo:</em></p>


  <pre><code class="language-promql">cpu_usage{cpu=&#34;total&#34;} / ignoring(cpu) cpu_quota</code></pre>
 <p>Suponha que <code>cpu_usage</code> tenha um label <code>cpu</code> (n√∫cleo) e valor <code>&quot;total&quot;</code> para indicar uso total da CPU, enquanto <code>cpu_quota</code> n√£o tem esse label (aplica a todo CPU). O <code>ignoring(cpu)</code> permite desconsiderar essa diferen√ßa, casando as s√©ries somente pelos outros labels (por exemplo, pod ou cont√™iner, se for o caso).</p>
</li>
<li>
<p><strong>Jun√ß√µes um-para-muitos (many-to-one)</strong>: Por padr√£o, se houver m√∫ltiplas s√©ries de um lado que poderiam casar com uma s√©rie do outro, a opera√ß√£o n√£o ocorre e o resultado √© vazio para evitar ambiguidades. No entanto, √†s vezes desejamos permitir isso ‚Äî por exemplo, dividir uma m√©trica total por n√∫mero de CPUs, onde a m√©trica total n√£o tem o label <code>cpu</code> mas a de contagem de CPU tem (m√∫ltiplas s√©ries, uma por core).
Para isso, usamos <code>group_left</code> ou <code>group_right</code> em conjunto com <code>on</code>/<code>ignoring</code>:</p>
<ul>
<li><strong><code>group_left(label1, label2, ...)</code></strong>: Indica que as s√©ries do lado esquerdo do operador devem permanecer separadas (muitas) enquanto as do lado direito ser√£o &ldquo;espalhadas&rdquo; para casar. Em outras palavras, permite que uma √∫nica s√©rie do lado direito seja usada para m√∫ltiplas do lado esquerdo. Opcionalmente, podemos listar labels que ser√£o <strong>copiados</strong> do lado direito para o resultado final.</li>
<li><strong><code>group_right(label1, label2, ...)</code></strong>: O contr√°rio, mant√©m o lado direito com muitas s√©ries e espalha o lado esquerdo.</li>
</ul>
<p><em>Exemplo (adicionando labels com group_left):</em></p>


  <pre><code class="language-promql">rate(http_requests_total[5m]) 
  * on(instance) 
  group_left(job, environment) 
  up</code></pre>
 <p>Nesse exemplo, <code>rate(http_requests_total[5m])</code> produz s√©ries talvez com labels <code>instance</code> e outros, mas digamos que n√£o tenha <code>job</code> nem <code>environment</code> explicitamente (ou queremos copiar do <code>up</code>). A s√©rie <code>up</code> (m√©trica de sa√∫de do alvo) tem <code>job</code>, <code>instance</code>, e <code>environment</code>. Estamos multiplicando as duas m√©tricas apenas casando por <code>instance</code> (<code>on(instance)</code>). Como do lado direito (<code>up</code>) h√° possivelmente apenas uma s√©rie por instance (valor 0 ou 1), e do lado esquerdo pode haver m√∫ltiplas (por caminho de requisi√ß√£o, status, etc.), usamos <code>group_left(job, environment)</code> para dizer: permite que a mesma s√©rie de <code>up</code> case com m√∫ltiplas s√©ries de requests do lado esquerdo, e traga os labels <code>job</code> e <code>environment</code> dessa s√©rie de <code>up</code> para o resultado final. Assim, o resultado ter√° a taxa de requests por <code>instance</code> mas agora enriquecido com os labels de job e environment.</p>
<p><em>Exemplo (many-to-one sem copiar labels):</em></p>


  <pre><code class="language-promql">cpu_usage 
  / on(instance) 
  group_right 
  cpu_count</code></pre>
 <p>Suponha que <code>cpu_usage{instance=&quot;A&quot;}</code> representa o uso total de CPU (consolidado) em determinada m√°quina, e <code>cpu_count{instance=&quot;A&quot;, cpu=&quot;0&quot;}</code> e <code>cpu_count{instance=&quot;A&quot;, cpu=&quot;1&quot;}</code> etc. representam 1 para cada CPU f√≠sica (cada core). Se somarmos <code>cpu_count by (instance)</code> obter√≠amos o n√∫mero de CPUs por inst√¢ncia, mas podemos diretamente dividir usando o truque do <code>group_right</code>. Aqui, cada s√©rie de <code>cpu_usage</code> (uma por instancia) ser√° comparada com m√∫ltiplas s√©ries de <code>cpu_count</code> (uma por CPU). Sem <code>group_right</code>, n√£o casaria por haver m√∫ltiplas s√©ries do lado direito para o mesmo instance. Com <code>group_right</code>, permitimos isso e, por n√£o especificar labels a copiar, o resultado herda os labels do lado esquerdo (<code>cpu_usage</code>), e a opera√ß√£o divis√£o √© feita para cada combina√ß√£o (na pr√°tica repetindo o mesmo valor de <code>cpu_usage</code> para cada CPU e dividindo por o respectivo <code>cpu_count</code> ‚Äì o que acaba resultando no mesmo valor para cada CPU). Talvez nesse caso espec√≠fico fosse melhor j√° agrupar <code>cpu_count</code> antes de dividir, mas esse exemplo ilustra a sintaxe.</p>
</li>
<li>
<p><strong>Operador de conjunto <code>union</code>:</strong> PromQL n√£o possui um operador expl√≠cito &ldquo;UNION&rdquo; nomeado, mas podemos realizar uni√£o de resultados simplesmente listando express√µes separadas por v√≠rgula em uma consulta. Por exemplo:</p>


  <pre><code class="language-promql">metric_a, metric_b</code></pre>
 <p>Isso retorna todas as s√©ries de <code>metric_a</code> e todas as de <code>metric_b</code>. N√£o √© muito comum em consultas manuais, mas pode ser √∫til para jun√ß√£o visual.</p>
</li>
</ul>
<p>Resumindo, os modificadores <code>on</code> e <code>ignoring</code> controlam <strong>quais</strong> labels considerar ao casar s√©ries de m√©tricas diferentes, e <code>group_left</code>/<code>group_right</code> controlam <strong>como lidar</strong> quando h√° cardinalidades diferentes (um-para-muitos). Combin√°-los corretamente √© fundamental para escrever consultas que envolvam m√∫ltiplas m√©tricas.</p>
<h3 id="operadores-l√≥gicos-and-or-unless">Operadores L√≥gicos: <code>and</code>, <code>or</code>, <code>unless</code></h3>
<p>Al√©m dos operadores aritm√©ticos e de compara√ß√£o, PromQL tamb√©m suporta operadores l√≥gicos para vetores. Esses operadores n√£o criam valores num√©ricos novos, mas sim filtram ou combinam s√©ries com base em condi√ß√µes booleanas.</p>
<ul>
<li>
<p><strong><code>and</code>:</strong> Ret√©m apenas as s√©ries que aparecem em <strong>ambos</strong> os operandos. Em outras palavras, √© uma interse√ß√£o: uma s√©rie do lado esquerdo s√≥ passa se existe uma s√©rie exatamente igual do lado direito (considerando labels) e vice-versa. O valor resultante de cada s√©rie ser√° o valor do lado esquerdo (padr√£o) ou, se usado como comparador, segue regras de comparador bool.
Uso t√≠pico: aplicar uma condi√ß√£o a um resultado. Por exemplo:</p>


  <pre><code class="language-promql">(vector1 comparacao const) and vector1</code></pre>
 <p>Isso retornaria apenas as s√©ries de <code>vector1</code> que atendem √† compara√ß√£o (pois o comparador produzir√° 1 para as s√©ries que satisfazem, e ent√£o <code>and</code> manter√° apenas essas).</p>
</li>
<li>
<p><strong><code>or</code>:</strong> Uni√£o de s√©ries. Retorna s√©ries que est√£o em <strong>pelo menos um</strong> dos lados. Se a mesma s√©rie (mesmos labels) aparece em ambos, o valor resultante ser√° o do lado esquerdo (padr√£o) ou pode ser modificado com bool se estivermos combinando booleanos. √â √∫til para combinar resultados diferentes.
Por exemplo:</p>


  <pre><code class="language-promql">vector_a or vector_b</code></pre>
 <p>Isso d√° todas as s√©ries de <code>vector_a</code> e <code>vector_b</code>. Se alguma s√©rie estiver presente nos dois, aparece uma vez s√≥ (com valor de <code>vector_a</code>).</p>
</li>
<li>
<p><strong><code>unless</code>:</strong> Ret√©m as s√©ries do lado esquerdo <strong>a menos que</strong> elas tamb√©m apare√ßam no lado direito. Equivale a diferen√ßa de conjuntos: resultado = esquerda \ direita. (Obs: O lado direito s√≥ importa pelos labels, seus valores s√£o ignorados).
Por exemplo:</p>


  <pre><code class="language-promql">up{job=&#34;api&#34;} unless up{job=&#34;api&#34;, region=&#34;us-east&#34;}</code></pre>
 <p>Isso retornaria as s√©ries <code>up</code> do job &ldquo;api&rdquo; <strong>que n√£o t√™m</strong> region=&ldquo;us-east&rdquo;, ou seja, efetivamente filtra fora todas as inst√¢ncias da regi√£o us-east.</p>
</li>
</ul>
<p>Os operadores l√≥gicos s√£o avaliados ap√≥s todos os c√°lculos num√©ricos serem feitos. Isso significa que podemos us√°-los tanto em m√©tricas brutas quanto em resultados de express√µes.</p>
<p><strong>Exemplos pr√°ticos combinando compara√ß√µes e operadores l√≥gicos:</strong></p>
<ul>
<li>
<p><strong>Contar inst√¢ncias ativas em dois grupos diferentes:</strong></p>


  <pre><code class="language-promql">sum(up{job=&#34;node&#34;} == 1) or sum(up{job=&#34;db&#34;} == 1)</code></pre>
 <p>Esse exemplo usa <code>== 1</code> para converter as s√©ries <code>up</code> em booleanas (1 para up, 0 para down) e soma para contar quantas est√£o up em cada job. O <code>or</code> aqui faz a uni√£o, retornando duas s√©ries (uma para node e outra para db) com o valor de quantas inst√¢ncias est√£o up em cada.</p>
</li>
<li>
<p><strong>Filtrar top 5 de um conjunto e combinar com outro crit√©rio:</strong></p>


  <pre><code class="language-promql">topk(5, rate(http_requests_total[5m])) and ignoring(instance) (rate(errors_total[5m]) &gt; 0)</code></pre>
 <p>Esse exemplo hipot√©tico pegaria as 5 maiores taxas de requisi√ß√£o (independente de inst√¢ncia) e ent√£o, atrav√©s do <code>and</code> com <code>ignoring(instance)</code> e a condi√ß√£o de erros, manteria somente aquelas cujo servi√ßo (ignorando inst√¢ncias) est√° apresentando erros. Bastante espec√≠fico, mas demonstra o uso combinado: <code>topk</code> produz s√©ries; a outra parte produz 1/0 para servi√ßos com erro; o <code>and ignoring(instance)</code> casa por servi√ßo e filtra.</p>
</li>
</ul>
<p>Lembrando que, se quisermos comparar valores de uma s√©rie com um n√∫mero e obter diretamente 1 ou 0, podemos usar o modificador <code>bool</code>. Exemplo: <code>vector1 &gt; bool 10</code> retornaria um vetor com valor 1 para s√©ries onde <code>vector1</code> &gt; 10 e 0 caso contr√°rio (mantendo os labels). Sem <code>bool</code>, ele retornaria as pr√≥prias s√©ries (com seus valores originais) por√©m filtradas pelas que atendem √† condi√ß√£o.</p>
<h3 id="resumo-de-operadores-de-conjunto-conjuntos-de-s√©ries">Resumo de operadores de conjunto (conjuntos de s√©ries)</h3>
<p>J√° falamos sobre <code>on</code>, <code>ignoring</code>, <code>group_left</code>, <code>group_right</code> e os operadores l√≥gicos. Vale refor√ßar:</p>
<ul>
<li><code>on</code> / <code>ignoring</code>: controlam quais labels fazem parte da compara√ß√£o entre s√©ries ao aplicar um operador bin√°rio.</li>
<li><code>group_left</code> / <code>group_right</code>: permitem matching many-to-one e definem de que lado as s√©ries duplicadas ficam.</li>
<li><code>and</code>, <code>or</code>, <code>unless</code>: operam em n√≠vel de conjunto de s√©ries (interse√ß√£o, uni√£o, diferen√ßa).</li>
</ul>
<p>Al√©m disso, quando usamos agregadores (como <code>sum</code>, <code>avg</code> etc.), usamos <code>by</code> ou <code>without</code> para controlar quais labels ser√£o preservados ou removidos. Isso √†s vezes √© referido como agrupar por labels, mas √© diferente de <code>on/ignoring</code> (que √© para matching de operadores).</p>
<p><strong>Recapitulando agrega√ß√£o com <code>by</code> e <code>without</code>:</strong></p>
<ul>
<li><code>sum by(label1, label2) (expr)</code> ‚Äì Soma os valores de <code>expr</code> agrupando s√©ries que compartilham os mesmos valores de <code>label1</code> e <code>label2</code>. Os labels <code>label1</code> e <code>label2</code> ser√£o mantidos no resultado, e todos os outros ser√£o descartados (exceto aqueles usados no by).</li>
<li><code>avg without(labelX) (expr)</code> ‚Äì Calcula a m√©dia removendo <code>labelX</code> da distin√ß√£o. Isso significa agrupar por todas as outras labels, ou seja, fundir s√©ries que diferem apenas em <code>labelX</code>.</li>
</ul>
<p>Exemplo: <code>sum by(job) (up == 0)</code> ‚Äì contaria quantas inst√¢ncias est√£o down por job. Aqui <code>up == 0</code> produz 1 para inst√¢ncias down. Agrupando por job e somando, obtemos a contagem de inst√¢ncias n√£o ativas de cada job.</p>
<h2 id="fun√ß√µes-essenciais-do-promql">Fun√ß√µes Essenciais do PromQL</h2>
<p>As fun√ß√µes essenciais do PromQL s√£o aquelas mais utilizadas no dia a dia para monitoramento e an√°lise de m√©tricas. Elas permitem transformar dados brutos em informa√ß√µes acion√°veis, calculando taxas, agrega√ß√µes e estat√≠sticas importantes.</p>
<h3 id="fun√ß√µes-de-taxa-e-incremento">Fun√ß√µes de Taxa e Incremento</h3>
<p>As fun√ß√µes mais fundamentais para trabalhar com contadores s√£o <code>rate()</code> e <code>increase()</code>:</p>
<p><strong><code>rate(counter[interval])</code></strong>: Calcula a taxa m√©dia por segundo de incremento do contador no intervalo especificado. Esta fun√ß√£o lida automaticamente com resets do contador.</p>


  <pre><code class="language-promql">rate(http_requests_total[5m])</code></pre>
 <p><strong><code>increase(counter[interval])</code></strong>: Calcula quanto o contador aumentou no intervalo especificado.</p>


  <pre><code class="language-promql">increase(http_requests_total[1h])</code></pre>
 <p><strong><code>irate(counter[interval])</code></strong>: Calcula a taxa instant√¢nea baseada apenas nos dois pontos mais recentes. √â mais ruidosa, mas reage mais rapidamente a mudan√ßas.</p>


  <pre><code class="language-promql">irate(http_requests_total[5m])</code></pre>
 <h3 id="fun√ß√µes-de-agrega√ß√£o">Fun√ß√µes de Agrega√ß√£o</h3>
<p>As fun√ß√µes de agrega√ß√£o permitem resumir dados de m√∫ltiplas s√©ries:</p>
<p><strong><code>sum(expr) by (label1, label2)</code></strong>: Soma os valores agrupando por labels espec√≠ficos.</p>


  <pre><code class="language-promql">sum(rate(http_requests_total[5m])) by (job)</code></pre>
 <p><strong><code>avg(expr) by (label1, label2)</code></strong>: Calcula a m√©dia agrupando por labels espec√≠ficos.</p>


  <pre><code class="language-promql">avg(rate(node_cpu_seconds_total{mode=&#34;user&#34;}[5m])) by (instance)</code></pre>
 <p><strong><code>count(expr) by (label1, label2)</code></strong>: Conta o n√∫mero de s√©ries agrupando por labels.</p>


  <pre><code class="language-promql">count(up) by (job)</code></pre>
 <p><strong><code>max(expr) by (label1, label2)</code></strong>: Retorna o valor m√°ximo agrupando por labels.</p>


  <pre><code class="language-promql">max(rate(http_requests_total[5m])) by (endpoint)</code></pre>
 <p><strong><code>min(expr) by (label1, label2)</code></strong>: Retorna o valor m√≠nimo agrupando por labels.</p>


  <pre><code class="language-promql">min(rate(http_requests_total[5m])) by (endpoint)</code></pre>
 <h3 id="fun√ß√µes-de-percentil-e-histograma">Fun√ß√µes de Percentil e Histograma</h3>
<p><strong><code>histogram_quantile(quantile, histogram)</code></strong>: Calcula um quantil espec√≠fico a partir de um histograma.</p>


  <pre><code class="language-promql">histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))</code></pre>
 <p><strong><code>quantile(quantile, expr)</code></strong>: Calcula um quantil espec√≠fico de uma express√£o.</p>


  <pre><code class="language-promql">quantile(0.95, rate(http_requests_total[5m]))</code></pre>
 <h3 id="fun√ß√µes-de-filtro-e-sele√ß√£o">Fun√ß√µes de Filtro e Sele√ß√£o</h3>
<p><strong><code>topk(k, expr)</code></strong>: Retorna as k s√©ries com os maiores valores.</p>


  <pre><code class="language-promql">topk(5, rate(http_requests_total[5m]))</code></pre>
 <p><strong><code>bottomk(k, expr)</code></strong>: Retorna as k s√©ries com os menores valores.</p>


  <pre><code class="language-promql">bottomk(5, rate(http_requests_total[5m]))</code></pre>
 <h3 id="fun√ß√µes-de-tempo">Fun√ß√µes de Tempo</h3>
<p><strong><code>avg_over_time(expr[interval])</code></strong>: Calcula a m√©dia dos valores no intervalo especificado.</p>


  <pre><code class="language-promql">avg_over_time(http_requests_total[5m])</code></pre>
 <p><strong><code>sum_over_time(expr[interval])</code></strong>: Calcula a soma dos valores no intervalo especificado.</p>


  <pre><code class="language-promql">sum_over_time(http_requests_total[5m])</code></pre>
 <p><strong><code>max_over_time(expr[interval])</code></strong>: Retorna o valor m√°ximo no intervalo especificado.</p>


  <pre><code class="language-promql">max_over_time(cpu_usage[1h])</code></pre>
 <p><strong><code>min_over_time(expr[interval])</code></strong>: Retorna o valor m√≠nimo no intervalo especificado.</p>


  <pre><code class="language-promql">min_over_time(memory_usage[1h])</code></pre>
 <h3 id="fun√ß√µes-de-detec√ß√£o-de-aus√™ncia">Fun√ß√µes de Detec√ß√£o de Aus√™ncia</h3>
<p><strong><code>absent(expr)</code></strong>: Retorna 1 se a express√£o n√£o retornar nenhum dado, caso contr√°rio retorna nada.</p>


  <pre><code class="language-promql">absent(up{job=&#34;webserver&#34;})</code></pre>
 <p><strong><code>absent_over_time(expr[interval])</code></strong>: Verifica se a m√©trica esteve ausente durante todo o intervalo.</p>


  <pre><code class="language-promql">absent_over_time(up{job=&#34;webserver&#34;}[5m])</code></pre>
 <h2 id="promql-avan√ßado">PromQL Avan√ßado</h2>
<p>O PromQL oferece recursos avan√ßados para consultas complexas e an√°lises sofisticadas. Esta se√ß√£o aborda t√≥picos mais avan√ßados como correspond√™ncia de vetores, subconsultas, operadores l√≥gicos e fun√ß√µes especializadas.</p>
<h3 id="correspond√™ncia-de-s√©ries-temporais-on-ignoring-group_left-group_right-1">Correspond√™ncia de S√©ries Temporais: <code>on()</code>, <code>ignoring()</code>, <code>group_left</code>, <code>group_right</code></h3>
<p>Quando combinamos m√©tricas diferentes (vetor-vetor), muitas vezes precisamos controlar quais labels s√£o usados para fazer o <em>join</em> (uni√£o) entre as s√©ries de cada lado da opera√ß√£o. √â aqui que entram os modificadores <code>on</code> e <code>ignoring</code>, e os operadores de jun√ß√£o externa <code>group_left</code> e <code>group_right</code>:</p>
<ul>
<li>
<p><strong><code>on(lista_de_labels)</code></strong>: Especifica explicitamente quais labels devem ser usados para casar as s√©ries ao aplicar o operador. Todos os demais labels s√£o ignorados no matching (exceto os do <code>on</code> listados).
<em>Exemplo:</em></p>


  <pre><code class="language-promql">errors_total / on(instance) requests_total</code></pre>
 <p>Aqui dizemos: combine s√©ries de <code>errors_total</code> e <code>requests_total</code> que tenham o mesmo valor de <code>instance</code>. Labels diferentes de <code>instance</code> ser√£o ignorados na compara√ß√£o. Isso √© √∫til se, por exemplo, <code>errors_total</code> tem um label <code>status=&quot;5xx&quot;</code> enquanto <code>requests_total</code> n√£o tem o label <code>status</code>. Sem o <code>on(instance)</code>, essas s√©ries n√£o casariam por terem conjuntos de labels distintos.</p>
</li>
<li>
<p><strong><code>ignoring(lista_de_labels)</code></strong>: O inverso do <code>on</code>. Use todos os labels <em>exceto</em> os listados para fazer o matching. Ou seja, finge que os labels mencionados n√£o existem nos vetores ao procurar pares correspondentes.
<em>Exemplo:</em></p>


  <pre><code class="language-promql">cpu_usage{cpu=&#34;total&#34;} / ignoring(cpu) cpu_quota</code></pre>
 <p>Suponha que <code>cpu_usage</code> tenha um label <code>cpu</code> (n√∫cleo) e valor <code>&quot;total&quot;</code> para indicar uso total da CPU, enquanto <code>cpu_quota</code> n√£o tem esse label (aplica a todo CPU). O <code>ignoring(cpu)</code> permite desconsiderar essa diferen√ßa, casando as s√©ries somente pelos outros labels (por exemplo, pod ou cont√™iner, se for o caso).</p>
</li>
<li>
<p><strong>Jun√ß√µes um-para-muitos (many-to-one)</strong>: Por padr√£o, se houver m√∫ltiplas s√©ries de um lado que poderiam casar com uma s√©rie do outro, a opera√ß√£o n√£o ocorre e o resultado √© vazio para evitar ambiguidades. No entanto, √†s vezes desejamos permitir isso ‚Äî por exemplo, dividir uma m√©trica total por n√∫mero de CPUs, onde a m√©trica total n√£o tem o label <code>cpu</code> mas a de contagem de CPU tem (m√∫ltiplas s√©ries, uma por core).
Para isso, usamos <code>group_left</code> ou <code>group_right</code> em conjunto com <code>on</code>/<code>ignoring</code>:</p>
<ul>
<li><strong><code>group_left(label1, label2, ...)</code></strong>: Indica que as s√©ries do lado esquerdo do operador devem permanecer separadas (muitas) enquanto as do lado direito ser√£o &ldquo;espalhadas&rdquo; para casar. Em outras palavras, permite que uma √∫nica s√©rie do lado direito seja usada para m√∫ltiplas do lado esquerdo. Opcionalmente, podemos listar labels que ser√£o <strong>copiados</strong> do lado direito para o resultado final.</li>
<li><strong><code>group_right(label1, label2, ...)</code></strong>: O contr√°rio, mant√©m o lado direito com muitas s√©ries e espalha o lado esquerdo.</li>
</ul>
<p><em>Exemplo (adicionando labels com group_left):</em></p>


  <pre><code class="language-promql">rate(http_requests_total[5m]) 
  * on(instance) 
  group_left(job, environment) 
  up</code></pre>
 <p>Nesse exemplo, <code>rate(http_requests_total[5m])</code> produz s√©ries talvez com labels <code>instance</code> e outros, mas digamos que n√£o tenha <code>job</code> nem <code>environment</code> explicitamente (ou queremos copiar do <code>up</code>). A s√©rie <code>up</code> (m√©trica de sa√∫de do alvo) tem <code>job</code>, <code>instance</code>, e <code>environment</code>. Estamos multiplicando as duas m√©tricas apenas casando por <code>instance</code> (<code>on(instance)</code>). Como do lado direito (<code>up</code>) h√° possivelmente apenas uma s√©rie por instance (valor 0 ou 1), e do lado esquerdo pode haver m√∫ltiplas (por caminho de requisi√ß√£o, status, etc.), usamos <code>group_left(job, environment)</code> para dizer: permite que a mesma s√©rie de <code>up</code> case com m√∫ltiplas s√©ries de requests do lado esquerdo, e traga os labels <code>job</code> e <code>environment</code> dessa s√©rie de <code>up</code> para o resultado final. Assim, o resultado ter√° a taxa de requests por <code>instance</code> mas agora enriquecido com os labels de job e environment.</p>
<p><em>Exemplo (many-to-one sem copiar labels):</em></p>


  <pre><code class="language-promql">cpu_usage 
  / on(instance) 
  group_right 
  cpu_count</code></pre>
 <p>Suponha que <code>cpu_usage{instance=&quot;A&quot;}</code> representa o uso total de CPU (consolidado) em determinada m√°quina, e <code>cpu_count{instance=&quot;A&quot;, cpu=&quot;0&quot;}</code> e <code>cpu_count{instance=&quot;A&quot;, cpu=&quot;1&quot;}</code> etc. representam 1 para cada CPU f√≠sica (cada core). Se somarmos <code>cpu_count by (instance)</code> obter√≠amos o n√∫mero de CPUs por inst√¢ncia, mas podemos diretamente dividir usando o truque do <code>group_right</code>. Aqui, cada s√©rie de <code>cpu_usage</code> (uma por instancia) ser√° comparada com m√∫ltiplas s√©ries de <code>cpu_count</code> (uma por CPU). Sem <code>group_right</code>, n√£o casaria por haver m√∫ltiplas s√©ries do lado direito para o mesmo instance. Com <code>group_right</code>, permitimos isso e, por n√£o especificar labels a copiar, o resultado herda os labels do lado esquerdo (<code>cpu_usage</code>), e a opera√ß√£o divis√£o √© feita para cada combina√ß√£o (na pr√°tica repetindo o mesmo valor de <code>cpu_usage</code> para cada CPU e dividindo por o respectivo <code>cpu_count</code> ‚Äì o que acaba resultando no mesmo valor para cada CPU). Talvez nesse caso espec√≠fico fosse melhor j√° agrupar <code>cpu_count</code> antes de dividir, mas esse exemplo ilustra a sintaxe.</p>
</li>
<li>
<p><strong>Operador de conjunto <code>union</code>:</strong> PromQL n√£o possui um operador expl√≠cito &ldquo;UNION&rdquo; nomeado, mas podemos realizar uni√£o de resultados simplesmente listando express√µes separadas por v√≠rgula em uma consulta. Por exemplo:</p>


  <pre><code class="language-promql">metric_a, metric_b</code></pre>
 <p>Isso retorna todas as s√©ries de <code>metric_a</code> e todas as de <code>metric_b</code>. N√£o √© muito comum em consultas manuais, mas pode ser √∫til para jun√ß√£o visual.</p>
</li>
</ul>
<p>Resumindo, os modificadores <code>on</code> e <code>ignoring</code> controlam <strong>quais</strong> labels considerar ao casar s√©ries de m√©tricas diferentes, e <code>group_left</code>/<code>group_right</code> controlam <strong>como lidar</strong> quando h√° cardinalidades diferentes (um-para-muitos). Combin√°-los corretamente √© fundamental para escrever consultas que envolvam m√∫ltiplas m√©tricas.</p>
<h3 id="operadores-l√≥gicos-and-or-unless-1">Operadores L√≥gicos: <code>and</code>, <code>or</code>, <code>unless</code></h3>
<p>Al√©m dos operadores aritm√©ticos e de compara√ß√£o, PromQL tamb√©m suporta operadores l√≥gicos para vetores. Esses operadores n√£o criam valores num√©ricos novos, mas sim filtram ou combinam s√©ries com base em condi√ß√µes booleanas.</p>
<ul>
<li>
<p><strong><code>and</code>:</strong> Ret√©m apenas as s√©ries que aparecem em <strong>ambos</strong> os operandos. Em outras palavras, √© uma interse√ß√£o: uma s√©rie do lado esquerdo s√≥ passa se existe uma s√©rie exatamente igual do lado direito (considerando labels) e vice-versa. O valor resultante de cada s√©rie ser√° o valor do lado esquerdo (padr√£o) ou, se usado como comparador, segue regras de comparador bool.
Uso t√≠pico: aplicar uma condi√ß√£o a um resultado. Por exemplo:</p>


  <pre><code class="language-promql">(vector1 comparacao const) and vector1</code></pre>
 <p>Isso retornaria apenas as s√©ries de <code>vector1</code> que atendem √† compara√ß√£o (pois o comparador produzir√° 1 para as s√©ries que satisfazem, e ent√£o <code>and</code> manter√° apenas essas).</p>
</li>
<li>
<p><strong><code>or</code>:</strong> Uni√£o de s√©ries. Retorna s√©ries que est√£o em <strong>pelo menos um</strong> dos lados. Se a mesma s√©rie (mesmos labels) aparece em ambos, o valor resultante ser√° o do lado esquerdo (padr√£o) ou pode ser modificado com bool se estivermos combinando booleanos. √â √∫til para combinar resultados diferentes.
Por exemplo:</p>


  <pre><code class="language-promql">vector_a or vector_b</code></pre>
 <p>Isso d√° todas as s√©ries de <code>vector_a</code> e <code>vector_b</code>. Se alguma s√©rie estiver presente nos dois, aparece uma vez s√≥ (com valor de <code>vector_a</code>).</p>
</li>
<li>
<p><strong><code>unless</code>:</strong> Ret√©m as s√©ries do lado esquerdo <strong>a menos que</strong> elas tamb√©m apare√ßam no lado direito. Equivale a diferen√ßa de conjuntos: resultado = esquerda \ direita. (Obs: O lado direito s√≥ importa pelos labels, seus valores s√£o ignorados).
Por exemplo:</p>


  <pre><code class="language-promql">up{job=&#34;api&#34;} unless up{job=&#34;api&#34;, region=&#34;us-east&#34;}</code></pre>
 <p>Isso retornaria as s√©ries <code>up</code> do job &ldquo;api&rdquo; <strong>que n√£o t√™m</strong> region=&ldquo;us-east&rdquo;, ou seja, efetivamente filtra fora todas as inst√¢ncias da regi√£o us-east.</p>
</li>
</ul>
<p>Os operadores l√≥gicos s√£o avaliados ap√≥s todos os c√°lculos num√©ricos serem feitos. Isso significa que podemos us√°-los tanto em m√©tricas brutas quanto em resultados de express√µes.</p>
<p><strong>Exemplos pr√°ticos combinando compara√ß√µes e operadores l√≥gicos:</strong></p>
<ul>
<li>
<p><strong>Contar inst√¢ncias ativas em dois grupos diferentes:</strong></p>


  <pre><code class="language-promql">sum(up{job=&#34;node&#34;} == 1) or sum(up{job=&#34;db&#34;} == 1)</code></pre>
 <p>Esse exemplo usa <code>== 1</code> para converter as s√©ries <code>up</code> em booleanas (1 para up, 0 para down) e soma para contar quantas est√£o up em cada job. O <code>or</code> aqui faz a uni√£o, retornando duas s√©ries (uma para node e outra para db) com o valor de quantas inst√¢ncias est√£o up em cada.</p>
</li>
<li>
<p><strong>Filtrar top 5 de um conjunto e combinar com outro crit√©rio:</strong></p>


  <pre><code class="language-promql">topk(5, rate(http_requests_total[5m])) and ignoring(instance) (rate(errors_total[5m]) &gt; 0)</code></pre>
 <p>Esse exemplo hipot√©tico pegaria as 5 maiores taxas de requisi√ß√£o (independente de inst√¢ncia) e ent√£o, atrav√©s do <code>and</code> com <code>ignoring(instance)</code> e a condi√ß√£o de erros, manteria somente aquelas cujo servi√ßo (ignorando inst√¢ncias) est√° apresentando erros. Bastante espec√≠fico, mas demonstra o uso combinado: <code>topk</code> produz s√©ries; a outra parte produz 1/0 para servi√ßos com erro; o <code>and ignoring(instance)</code> casa por servi√ßo e filtra.</p>
</li>
</ul>
<p>Lembrando que, se quisermos comparar valores de uma s√©rie com um n√∫mero e obter diretamente 1 ou 0, podemos usar o modificador <code>bool</code>. Exemplo: <code>vector1 &gt; bool 10</code> retornaria um vetor com valor 1 para s√©ries onde <code>vector1</code> &gt; 10 e 0 caso contr√°rio (mantendo os labels). Sem <code>bool</code>, ele retornaria as pr√≥prias s√©ries (com seus valores originais) por√©m filtradas pelas que atendem √† condi√ß√£o.</p>
<h3 id="subconsultas-e-an√°lise-temporal-avan√ßada">Subconsultas e An√°lise Temporal Avan√ßada</h3>
<p><strong>Counter Range Vectors</strong>: Contadores s√£o m√©tricas que apenas aumentam (ou resetam para zero e voltam a aumentar). Exemplos: n√∫mero total de requisi√ß√µes atendidas, bytes transferidos, etc. Quando consultamos diretamente um <em>counter</em> como range vector, obteremos uma s√©rie de pontos que s√≥ crescem (com eventuais resets). Para extrair informa√ß√µes √∫teis (como taxa de eventos por segundo ou aumentos em determinado per√≠odo) usamos fun√ß√µes especiais:</p>
<ul>
<li><code>rate(counter[5m])</code>: Calcula a <strong>taxa m√©dia por segundo</strong> de incremento do contador nos √∫ltimos 5 minutos. Essa fun√ß√£o j√° lida corretamente com resets do contador (ignorando as quedas abruptas devido a resets e calculando a taxa considerando isso).</li>
<li><code>irate(counter[5m])</code>: Calcula a <strong>taxa instant√¢nea</strong> (baseada apenas nos dois pontos mais recentes dentro dos 5 minutos). √â mais ruidosa, mas pode reagir mais rapidamente a mudan√ßas repentinas.</li>
<li><code>increase(counter[1h])</code>: Calcula <strong>quanto o contador aumentou</strong> no √∫ltimo 1 hora. Essencialmente integra a taxa ao longo do per√≠odo.</li>
</ul>
<p><strong>Agrega√ß√£o atrav√©s do tempo (Aggregating Across Time)</strong>: √Äs vezes, queremos primeiro agregar os dados e depois analisar a evolu√ß√£o temporal dessa agrega√ß√£o. As <strong>subconsultas</strong> nos permitem isso. Uma <em>subquery</em> (subconsulta) √© quando temos uma express√£o do PromQL seguida de um intervalo entre colchetes e possivelmente uma resolu√ß√£o, por exemplo: <code>expr[dura√ß√£o:passo]</code>. Isso faz o Prometheus avaliar <code>expr</code> repetidamente ao longo do intervalo dado, produzindo um range vector como resultado.</p>
<p>Por exemplo, <code>avg_over_time(rate(http_requests_total[1m])[24h:1h])</code> funciona assim:</p>
<ul>
<li>Internamente, <code>rate(http_requests_total[1m])</code> √© avaliado para cada passo de 1h dentro das √∫ltimas 24h, gerando a taxa m√©dia por minuto calculada a cada hora.</li>
<li>Em seguida, <code>avg_over_time(...[24h:1h])</code> calcula a m√©dia desses 24 valores (um por hora) <strong>no tempo atual</strong>. Na pr√°tica, isso nos daria a m√©dia da taxa hor√°ria de requisi√ß√µes no dia.</li>
</ul>
<p>Subconsultas s√£o muito poderosas e foram aprimoradas a partir do Prometheus 2.7. Com elas √© poss√≠vel, por exemplo, calcular tend√™ncias, baselines e sazonalidade de forma compacta.</p>
<p><strong>Exemplos avan√ßados de subconsultas e an√°lise de tend√™ncias:</strong></p>
<ul>
<li>
<p><strong>Tend√™ncia de taxa de erro (janela m√≥vel):</strong> Calcular a m√©dia da taxa de erros em janelas de 1 hora, ao longo das √∫ltimas 24 horas:</p>


  <pre><code class="language-promql">avg_over_time(
  rate(http_requests_total{status=~&#34;5..&#34;}[1m])[24h:1h]
)</code></pre>
 <p>Essa consulta gera 24 pontos (taxa de erro m√©dia de cada hora nas √∫ltimas 24h) e depois calcula a m√©dia disso tudo (ou seja, a m√©dia di√°ria da taxa de erro). Poder√≠amos tamb√©m omitir a fun√ß√£o externa para simplesmente visualizar a s√©rie das √∫ltimas 24 horas e identificar padr√µes de aumento ou redu√ß√£o de erros ao longo do dia.</p>
</li>
<li>
<p><strong>Baseline de performance (compara√ß√£o com m√©dia hist√≥rica):</strong> Comparar a performance atual com a m√©dia da √∫ltima semana:</p>


  <pre><code class="language-promql">rate(http_requests_total[5m]) 
  / avg_over_time(rate(http_requests_total[5m])[7d])</code></pre>
 <p>Essa consulta produz uma raz√£o: valores acima de 1 indicam que a taxa atual de requisi√ß√µes est√° <strong>acima</strong> da m√©dia semanal; valores abaixo de 1, abaixo da m√©dia. Isso pode ser √∫til para identificar desvios significativos de tr√°fego.</p>
</li>
<li>
<p><strong>Detec√ß√£o de anomalia sazonal (padr√£o hor√°rio):</strong> Comparar o tr√°fego atual com o padr√£o do √∫ltimo dia:</p>


  <pre><code class="language-promql">rate(http_requests_total[5m]) 
  / avg_over_time(rate(http_requests_total[5m])[24h:1h])</code></pre>
 <p>Aqui, o denominador <code>avg_over_time(...[24h:1h])</code> produz a m√©dia da taxa em cada hora do dia anterior. Dividindo a taxa atual por esse valor da mesma hora ontem, podemos identificar se o tr√°fego est√° anormalmente alto ou baixo para este hor√°rio do dia.</p>
</li>
<li>
<p><strong>Diferen√ßa di√°ria (subconsulta com offset):</strong> Para calcular a diferen√ßa em uma m√©trica entre hoje e ontem, podemos usar <code>offset</code>. Exemplo:</p>


  <pre><code class="language-promql">my_metric - my_metric offset 1d</code></pre>
 <p>Isso resulta em quanto <code>my_metric</code> variou em compara√ß√£o com exatamente 24 horas atr√°s.</p>
</li>
<li>
<p><strong>Soma acumulada (exemplo de subconsulta):</strong></p>


  <pre><code class="language-promql">sum(my_counter) - sum(my_counter) offset 1d</code></pre>
 <p>Este exemplo soma o contador <code>my_counter</code> (provavelmente de v√°rias inst√¢ncias) e subtrai o valor de 1 dia atr√°s, mostrando o incremento total em um dia. Essa √© outra forma de calcular algo similar a <code>increase(my_counter[1d])</code>.</p>
</li>
</ul>
<p>Em todos esses casos, as subconsultas <code>[ ... ]</code> est√£o permitindo observar ou reutilizar resultados ao longo do tempo dentro de uma √∫nica express√£o.</p>
<h3 id="fun√ß√µes-avan√ßadas-e-especializadas">Fun√ß√µes Avan√ßadas e Especializadas</h3>
<p>Algumas fun√ß√µes do PromQL s√£o menos conhecidas, mas podem ser extremamente poderosas em cen√°rios espec√≠ficos:</p>
<ul>
<li>
<p><strong><code>resets(counter[interval])</code>:</strong> Conta quantas vezes um contador &ldquo;resetou&rdquo; (voltou a zero) no per√≠odo. √ötil para detectar reinicializa√ß√µes de aplicativos ou problemas de coleta.
<em>Exemplos:</em></p>


  <pre><code class="language-promql">resets(http_requests_total[5m])</code></pre>
 <p>Contaria quantos resets ocorreram no <code>http_requests_total</code> nos √∫ltimos 5 minutos. Se esse n√∫mero for &gt; 0 constantemente, pode indicar que o servi√ßo est√° reiniciando frequentemente (se o contador for interno ao servi√ßo) ou que h√° overflow de contadores.</p>
</li>
<li>
<p><strong><code>changes(series[interval])</code>:</strong> Conta quantas vezes o valor de uma s√©rie mudou durante o intervalo. Isso vale para qualquer m√©trica (n√£o apenas counters). Pode indicar instabilidade ou flapping.
<em>Exemplo:</em></p>


  <pre><code class="language-promql">changes(process_start_time_seconds[5m]) &gt; 0</code></pre>
 <p>O exemplo acima retornaria 1 para inst√¢ncias cujo <code>process_start_time_seconds</code> (normalmente um timestamp de in√≠cio do processo) tenha mudado nos √∫ltimos 5 minutos ‚Äî ou seja, o processo reiniciou nesse per√≠odo.</p>
</li>
<li>
<p><strong><code>predict_linear(series[interval], passos_no_futuro)</code>:</strong> Realiza uma extrapola√ß√£o linear do valor da s√©rie com base na tend√™ncia nos √∫ltimos intervalos e prev√™ o valor daqui a X segundos (informado em <code>passos_no_futuro</code>). √ötil para prever quando algo alcan√ßar√° um certo limite.
<em>Exemplo:</em></p>


  <pre><code class="language-promql">predict_linear(node_filesystem_free_bytes[1h], 3600) &lt; 0</code></pre>
 <p>Poderia ser usado para alertar se a tend√™ncia de queda do espa√ßo livre prev√™ que em 1 hora (<code>3600</code> segundos) o espa√ßo chegaria a zero.</p>
</li>
<li>
<p><strong><code>holt_winters(series[interval], sf, tf)</code>:</strong> Embora mais comum no Graphite, o PromQL tamb√©m tem uma fun√ß√£o de previs√£o chamada <code>holt_winters</code> (Holt-Winters, s√©rie temporal com tend√™ncia e sazonalidade). Aceita uma s√©rie (geralmente resultado de subconsulta) e realiza suaviza√ß√£o exponencial dupla. No entanto, essa fun√ß√£o √© raramente usada diretamente em alertas, servindo mais para visualiza√ß√£o de tend√™ncias suavizadas.</p>
</li>
<li>
<p><strong>Fun√ß√µes para histogramas nativos (Prometheus 3.x):</strong></p>
<ul>
<li><code>histogram_count()</code> e <code>histogram_sum()</code> ‚Äì Retornam, respectivamente, a contagem total e a soma total das observa√ß√µes de histogramas (cl√°ssicos ou nativos). Para histogramas cl√°ssicos, esses usam as s√©ries <code>_count</code> e <code>_sum</code> internas; para nativos, usam os valores codificados.</li>
<li><code>histogram_avg()</code> ‚Äì Computa a m√©dia dos valores observados em cada histograma, equivalente a <code>histogram_sum/histogram_count</code>.</li>
<li><code>histogram_fraction(lower, upper, hist)</code> ‚Äì Estima a fra√ß√£o de observa√ß√µes dentro do intervalo <code>[lower, upper]</code> para cada histograma. √ötil, por exemplo, para calcular <em>Apdex</em> (fra√ß√£o de requisi√ß√µes abaixo de um certo limiar de lat√™ncia).</li>
</ul>
</li>
</ul>
<p>Lembrando que algumas dessas fun√ß√µes mais novas podem requerer flags experimentais, dependendo da vers√£o do Prometheus.</p>
<h2 id="promql-na-pr√°tica">PromQL na Pr√°tica</h2>
<p>O PromQL √© a linguagem de consulta do Prometheus que permite extrair insights valiosos das m√©tricas coletadas. Vamos explorar exemplos pr√°ticos de consultas comuns para uso di√°rio em monitoramento.</p>
<h3 id="consultas-b√°sicas-de-disponibilidade">Consultas B√°sicas de Disponibilidade</h3>
<p><strong>Verificar se todos os targets est√£o up:</strong></p>


  <pre><code class="language-promql">up == 1</code></pre>
 <p><strong>Contar quantos targets est√£o down:</strong></p>


  <pre><code class="language-promql">count(up == 0)</code></pre>
 <p><strong>Taxa de disponibilidade por job:</strong></p>


  <pre><code class="language-promql">avg(up) by (job)</code></pre>
 <h3 id="m√©tricas-de-sistema-node-exporter">M√©tricas de Sistema (Node Exporter)</h3>
<p><strong>CPU m√©dio por inst√¢ncia:</strong></p>


  <pre><code class="language-promql">avg(rate(node_cpu_seconds_total{mode=&#34;user&#34;}[5m])) by (instance)</code></pre>
 <p><strong>Uso de mem√≥ria em porcentagem:</strong></p>


  <pre><code class="language-promql">(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes * 100</code></pre>
 <p><strong>Uso de disco por filesystem:</strong></p>


  <pre><code class="language-promql">(node_filesystem_size_bytes - node_filesystem_free_bytes) / node_filesystem_size_bytes * 100</code></pre>
 <p><strong>Taxa de I/O de disco:</strong></p>


  <pre><code class="language-promql">rate(node_disk_io_time_seconds_total[5m])</code></pre>
 <h3 id="m√©tricas-de-aplica√ß√£o-web">M√©tricas de Aplica√ß√£o Web</h3>
<p><strong>Taxa de requisi√ß√µes por segundo (QPS):</strong></p>


  <pre><code class="language-promql">rate(http_requests_total[5m])</code></pre>
 <p><strong>Taxa de erro por endpoint:</strong></p>


  <pre><code class="language-promql">rate(http_requests_total{status=~&#34;5..&#34;}[5m])</code></pre>
 <p><strong>Lat√™ncia p95 (percentil 95):</strong></p>


  <pre><code class="language-promql">histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))</code></pre>
 <p><strong>Lat√™ncia p99 (percentil 99):</strong></p>


  <pre><code class="language-promql">histogram_quantile(0.99, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))</code></pre>
 <p><strong>Tempo de resposta m√©dio:</strong></p>


  <pre><code class="language-promql">rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])</code></pre>
 <h3 id="m√©tricas-de-banco-de-dados">M√©tricas de Banco de Dados</h3>
<p><strong>Conex√µes ativas do PostgreSQL:</strong></p>


  <pre><code class="language-promql">pg_stat_database_numbackends</code></pre>
 <p><strong>Taxa de transa√ß√µes por segundo:</strong></p>


  <pre><code class="language-promql">rate(pg_stat_database_xact_commit[5m]) &#43; rate(pg_stat_database_xact_rollback[5m])</code></pre>
 <p><strong>Tamanho de tabelas (PostgreSQL):</strong></p>


  <pre><code class="language-promql">pg_stat_user_tables_size_bytes</code></pre>
 <h3 id="m√©tricas-de-containerkubernetes">M√©tricas de Container/Kubernetes</h3>
<p><strong>CPU por pod:</strong></p>


  <pre><code class="language-promql">sum(rate(container_cpu_usage_seconds_total{container!=&#34;&#34;}[5m])) by (pod)</code></pre>
 <p><strong>Mem√≥ria por pod:</strong></p>


  <pre><code class="language-promql">sum(container_memory_usage_bytes{container!=&#34;&#34;}) by (pod)</code></pre>
 <p><strong>Pods por namespace:</strong></p>


  <pre><code class="language-promql">count(kube_pod_info) by (namespace)</code></pre>
 <h3 id="alertas-comuns">Alertas Comuns</h3>
<p><strong>Alerta de CPU alta:</strong></p>


  <pre><code class="language-promql">100 - (avg(irate(node_cpu_seconds_total{mode=&#34;idle&#34;}[5m])) by (instance) * 100) &gt; 80</code></pre>
 <p><strong>Alerta de mem√≥ria alta:</strong></p>


  <pre><code class="language-promql">(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes * 100 &gt; 85</code></pre>
 <p><strong>Alerta de disco cheio:</strong></p>


  <pre><code class="language-promql">(node_filesystem_size_bytes - node_filesystem_free_bytes) / node_filesystem_size_bytes * 100 &gt; 90</code></pre>
 <p><strong>Alerta de lat√™ncia alta:</strong></p>


  <pre><code class="language-promql">histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le)) &gt; 1</code></pre>
 <p><strong>Alerta de taxa de erro alta:</strong></p>


  <pre><code class="language-promql">rate(http_requests_total{status=~&#34;5..&#34;}[5m]) / rate(http_requests_total[5m]) &gt; 0.05</code></pre>
 <h3 id="consultas-avan√ßadas">Consultas Avan√ßadas</h3>
<p><strong>Top 5 inst√¢ncias com maior CPU:</strong></p>


  <pre><code class="language-promql">topk(5, 100 - (avg(irate(node_cpu_seconds_total{mode=&#34;idle&#34;}[5m])) by (instance) * 100))</code></pre>
 <p><strong>Soma de m√©tricas por regi√£o:</strong></p>


  <pre><code class="language-promql">sum(rate(http_requests_total[5m])) by (region)</code></pre>
 <p><strong>Diferen√ßa de m√©tricas entre per√≠odos:</strong></p>


  <pre><code class="language-promql">increase(http_requests_total[1h]) - increase(http_requests_total[1h] offset 1h)</code></pre>
 <p><strong>M√©trica com label din√¢mico:</strong></p>


  <pre><code class="language-promql">rate(http_requests_total{endpoint=~&#34;/api/.*&#34;}[5m])</code></pre>
 <h3 id="dicas-de-performance">Dicas de Performance</h3>
<p><strong>Use intervalos apropriados:</strong></p>
<ul>
<li>Para alertas: <code>[5m]</code> ou <code>[1m]</code></li>
<li>Para dashboards: <code>[1h]</code> para tend√™ncias</li>
<li>Evite <code>[24h]</code> em consultas frequentes</li>
</ul>
<p><strong>Prefira <code>rate()</code> sobre <code>irate()</code> para alertas:</strong></p>


  <pre><code class="language-promql"># Bom para alertas (mais est√°vel)
rate(http_requests_total[5m])

# Melhor para dashboards (mais responsivo)
irate(http_requests_total[5m])</code></pre>
 <p><strong>Agregue quando poss√≠vel:</strong></p>


  <pre><code class="language-promql"># Em vez de somar muitas s√©ries
sum(rate(http_requests_total[5m])) by (job)

# Evite isso em m√©tricas com alta cardinalidade
sum(rate(http_requests_total[5m]))</code></pre>
 <h3 id="exemplos-de-recording-rules">Exemplos de Recording Rules</h3>
<p><strong>Regra para QPS agregado:</strong></p>


  <pre><code class="language-yaml">groups:
- name: recording_rules
  rules:
    - record: job:http_requests:rate5m
      expr: sum(rate(http_requests_total[5m])) by (job)</code></pre>
 <p><strong>Regra para lat√™ncia p95:</strong></p>


  <pre><code class="language-yaml">    - record: job:http_request_duration_seconds:p95
      expr: histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le, job))</code></pre>
 <blockquote>
<p><strong>Dica</strong>: Use recording rules para pr√©-calcular consultas complexas e frequentes. Isso melhora a performance e reduz a carga no Prometheus.</p></blockquote>
<h3 id="instrumenta√ß√£o-direta-exemplos-por-linguagem">Instrumenta√ß√£o direta: exemplos por linguagem</h3>
<p>Agora vejamos como instrumentar aplica√ß√µes escritas em algumas linguagens populares. A ideia geral em qualquer linguagem √©: instalar a biblioteca cliente do Prometheus, criar m√©tricas (<a href="https://prometheus.io/docs/concepts/metric_types/#counter">counters</a>, <a href="https://prometheus.io/docs/concepts/metric_types/#gauge">gauges</a>, etc.) em pontos estrat√©gicos do c√≥digo, e expor um endpoint HTTP <code>/metrics</code> onde essas m√©tricas s√£o servidas (em formato de texto). O Prometheus ent√£o coleta nesse endpoint.</p>
<h4 id="java-micrometer--cliente-java-do-prometheus">Java (Micrometer / Cliente Java do Prometheus)</h4>
<p>Em Java, uma abordagem comum √© usar o <strong><a href="https://micrometer.io/">Micrometer</a></strong> ‚Äì uma biblioteca de instrumenta√ß√£o que suporta m√∫ltiplos backends (Prometheus, Graphite, etc.). O Micrometer foi adotado pelo Spring Boot, por exemplo, facilitando a exposi√ß√£o de m√©tricas. Passos b√°sicos:</p>
<ol>
<li>
<p><strong>Depend√™ncias:</strong> Adicione ao seu projeto (pom.xml ou build.gradle) a depend√™ncia do Micrometer e do registry Prometheus. Exemplo (Maven):</p>


  <pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-core&lt;/artifactId&gt;
    &lt;version&gt;1.10.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;
    &lt;version&gt;1.10.4&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
 </li>
<li>
<p><strong>Registrar m√©tricas:</strong> Em sua aplica√ß√£o, configure um <code>MeterRegistry</code> do Prometheus e registre m√©tricas. Por exemplo, em uma classe de configura√ß√£o Spring:</p>


  <pre><code class="language-java">@Bean
PrometheusMeterRegistry prometheusRegistry() {
    return new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
}</code></pre>
 <p>Voc√™ pode ent√£o criar contadores, gauges, etc. usando esse registry:</p>


  <pre><code class="language-java">Counter requestCount = Counter.builder(&#34;myapp_requests_total&#34;)
                              .description(&#34;Total de requisi√ß√µes&#34;)
                              .register(prometheusRegistry());
// Usar requestCount.inc(); em pontos apropriados do c√≥digo</code></pre>
 <p>Ou usar anota√ß√µes/filtros prontos do Spring Boot Actuator que medem tempos de resposta automaticamente.</p>
</li>
<li>
<p><strong>Expor endpoint /metrics:</strong> Se estiver usando Spring Boot Actuator, habilite a endpoint Prometheus. No application.properties:</p>


  <pre><code class="language-">management.endpoints.web.exposure.include=prometheus
management.endpoint.prometheus.enabled=true</code></pre>
 <p>Isso far√° o Actuator expor <code>/actuator/prometheus</code> com as m√©tricas no formato Prometheus. O Prometheus pode ent√£o fazer scrape nessa URL. (Alternativamente, sem Spring, voc√™ poderia iniciar um HTTP server manualmente que responda com <code>prometheusRegistry.scrape()</code> output).</p>
</li>
<li>
<p><strong>Verificar m√©tricas:</strong> Ao rodar a aplica√ß√£o, acesse <a href="http://localhost:8080/actuator/prometheus">http://localhost:8080/actuator/prometheus</a> (por exemplo) e voc√™ ver√° todas as m√©tricas registradas, inclusive padr√µes do JVM (o Micrometer j√° fornece m√©tricas de mem√≥ria, CPU, GC, etc. por padr√£o) e as personalizadas que voc√™ adicionou.</p>
</li>
</ol>
<blockquote>
<p>Em resumo, no Java/Spring o processo pode ser muito simples aproveitando frameworks existentes. Para outras aplica√ß√µes Java sem Spring, existe tamb√©m o cliente Java do Prometheus (simpleclient) onde voc√™ manualmente gerencia as m√©tricas e HTTP endpoint.</p></blockquote>
<h4 id="javascriptnodejs">JavaScript/Node.js</h4>
<p>No Node.js podemos usar o pacote <strong>prom-client</strong> para instrumenta√ß√£o:</p>
<ol>
<li>
<p><strong>Instalar pacote:</strong> <code>npm install prom-client</code>.</p>
</li>
<li>
<p><strong>Criar m√©tricas no c√≥digo:</strong> Por exemplo, vamos medir o tempo de resposta de uma rota Express:</p>


  <pre><code class="language-js">const express = require(&#39;express&#39;);
const promClient = require(&#39;prom-client&#39;);
const app = express();

// Cria um histogram para tempos de resposta em segundos
const httpResponseHist = new promClient.Histogram({
  name: &#39;myapp_http_response_duration_seconds&#39;,
  help: &#39;Tempo de resposta das requisi√ß√µes HTTP (segundos)&#39;,
  labelNames: [&#39;route&#39;, &#39;method&#39;]
});</code></pre>
 <p>Aqui usamos um Histogram (poderia ser Summary tamb√©m). Antes de enviar a resposta na rota, registramos a observa√ß√£o:</p>


  <pre><code class="language-js">app.get(&#39;/example&#39;, (req, res) =&gt; {
  const end = httpResponseHist.startTimer({ route: &#39;/example&#39;, method: &#39;GET&#39; });
  // ... l√≥gica da rota ...
  res.send(&#34;Hello World&#34;);
  end(); // marca o fim do timer e observa a dura√ß√£o no histogram
});</code></pre>
 <p>O <em>prom-client</em> possui m√©todos convenientes para medir dura√ß√£o com <code>Histogram.startTimer()</code> que retorna uma fun√ß√£o para encerrar e registrar.</p>
</li>
<li>
<p><strong>Expor as m√©tricas:</strong> Precisamos servir as m√©tricas via HTTP para o Prometheus. Podemos criar um endpoint <code>/metrics</code>:</p>


  <pre><code class="language-js">app.get(&#39;/metrics&#39;, async (req, res) =&gt; {
  res.set(&#39;Content-Type&#39;, promClient.register.contentType);
  res.end(await promClient.register.metrics());
});</code></pre>
 <p>Isso coleta todas as m√©tricas registradas e retorna no formato de texto padr√£o.</p>
</li>
<li>
<p><strong>Iniciar server:</strong> Por fim, inicie seu servidor Node (por ex, <code>app.listen(3000)</code>). Ent√£o a URL <a href="http://localhost:3000/metrics">http://localhost:3000/metrics</a> mostrar√° as m√©tricas.</p>
</li>
<li>
<p><strong>Configurar Prometheus:</strong> Adicione no <code>prometheus.yml</code> um job apontando para o servi√ßo Node, porta 3000 (ou a porta usada) e path <code>/metrics</code>. Exemplo:</p>


  <pre><code class="language-yaml">scrape_configs:
  - job_name: &#39;my-nodeapp&#39;
    static_configs:
      - targets: [&#39;my-node-host:3000&#39;]</code></pre>
 <p>(Se o Node est√° no mesmo Docker Compose do Prometheus, pode usar o nome de servi√ßo do container e porta.)</p>
</li>
</ol>
<p>A partir da√≠, o Prometheus coletar√° as m√©tricas do seu app Node. Voc√™ poder√° consultar coisas como <code>rate(myapp_http_response_duration_seconds_count[5m])</code> ou <code>histogram_quantile(0.9, rate(myapp_http_response_duration_seconds_bucket[5m]))</code> para ver percentis de lat√™ncia.</p>
<h4 id="python-flask-etc">Python (Flask, etc.)</h4>
<p>Em Python, h√° o pacote <strong>prometheus_client</strong>. Exemplo integrando com Flask:</p>
<ol>
<li>
<p><strong>Instala√ß√£o:</strong> <code>pip install prometheus_client</code>.</p>
</li>
<li>
<p><strong>Cria√ß√£o de m√©tricas:</strong> Digamos que queremos contar requisi√ß√µes e medir dura√ß√£o. Podemos usar um Histogram ou Summary. Aqui um Summary:</p>


  <pre><code class="language-python">from flask import Flask, request
from prometheus_client import Summary, Counter, start_http_server

app = Flask(__name__)
REQUEST_TIME = Summary(&#39;myapp_request_processing_seconds&#39;, &#39;Tempo de processamento por rota&#39;, [&#39;endpoint&#39;])
REQUEST_COUNT = Counter(&#39;myapp_requests_total&#39;, &#39;Total de requisi√ß√µes&#39;, [&#39;endpoint&#39;, &#39;http_status&#39;])</code></pre>
 <p>Decoramos a rota para coletar m√©tricas:</p>


  <pre><code class="language-python">@app.route(&#34;/example&#34;)
def example():
    with REQUEST_TIME.labels(endpoint=&#34;/example&#34;).time():  # inicia timer autom√°tico
        # ... l√≥gica do endpoint ...
        response = &#34;Hello World&#34;
    REQUEST_COUNT.labels(endpoint=&#34;/example&#34;, http_status=200).inc()
    return response</code></pre>
 <p>O <code>Summary.time()</code> funciona como context manager medindo o tempo dentro do bloco. Tamb√©m incrementamos um counter de requests totais por endpoint e status.</p>
</li>
<li>
<p><strong>Expor m√©tricas:</strong> Podemos fazer de duas formas ‚Äì ou usamos o servidor HTTP interno do prometheus_client ou integramos com Flask. Uma maneira simples: iniciar um <em>thread</em> do servidor metrics separado:</p>


  <pre><code class="language-python">if __name__ == &#34;__main__&#34;:
    start_http_server(8000)  # inicia servidor em porta 8000
    app.run(host=&#34;0.0.0.0&#34;, port=5000)</code></pre>
 </li>
</ol>
<p>O <code>start_http_server(8000)</code> far√° com que em <a href="http://localhost:8000/metrics">http://localhost:8000/metrics</a> tenhamos as m√©tricas (note: ele por default exp√µe em /metrics automaticamente). Nesse caso, o Prometheus deve apontar para porta 8000 do app.</p>
<p>Alternativamente, h√° integra√ß√£o para Flask (via middleware) que poderia expor /metrics no pr√≥prio Flask app.</p>
<ol start="4">
<li><strong>Prometheus config:</strong> Similar aos anteriores, adicionar job apontando para o endpoint do metrics (host e porta usados).</li>
</ol>
<p>Ap√≥s esses passos, seu app Python estar√° fornecendo m√©tricas. Voc√™ pode conferir acessando <a href="http://localhost:8000/metrics">http://localhost:8000/metrics</a> e vendo as s√©ries nomeadas <code>myapp_request_processing_seconds_*</code> e <code>myapp_requests_total</code> entre outras (o client lib Python tamb√©m exp√µe m√©tricas padr√£o do processo Python como uso de mem√≥ria do processo, CPU, etc.).</p>
<h3 id="ferramentas-legadas-e-fechadas">Ferramentas legadas e fechadas</h3>
<p>Uma dificuldade comum √© monitorar sistemas legados ou softwares propriet√°rios que n√£o oferecem m√©tricas no formato Prometheus. Nesses casos, h√° alguns padr√µes de solu√ß√£o:</p>
<ul>
<li>
<p><strong><a href="https://prometheus.io/docs/instrumenting/exporters/">Exporters externos</a></strong>: Como j√° mencionado, se existir um exporter compat√≠vel (oficial ou da comunidade) para aquela ferramenta, ele √© o caminho mais f√°cil ‚Äì rodar o exporter e configur√°-lo como alvo. Por exemplo, para monitorar um servidor Oracle propriet√°rio, pode haver um exporter que conecta no Oracle e extrai estat√≠sticas via queries.</p>
</li>
<li>
<p><strong><a href="https://prometheus.io/docs/instrumenting/writing_exporters/#writing-a-bridge-exporter">Bridges personalizadas</a>:</strong> Caso n√£o exista um exporter pronto, podemos criar um processo intermedi√°rio (<em>bridge</em>) que consulta a ferramenta legada de alguma forma (API REST, CLI, leitura de arquivos de log) e exp√µe resultados em /metrics. Essencialmente, isso √© escrever um pequeno exporter sob medida. Ferramentas de script como Python facilitam isso ‚Äì voc√™ coleta os dados e usa <code>prometheus_client</code> para expor.</p>
</li>
<li>
<p><strong><a href="https://prometheus.io/docs/instrumenting/writing_exporters/#writing-a-bridge-exporter">Integra√ß√µes via gateway ou plugins</a>:</strong> Alguns ambientes possuem hooks para m√©tricas. Por exemplo, aplica√ß√µes .NET legadas podem exportar contadores no Windows Performance Counters ‚Äì a√≠ usar o Windows Exporter para peg√°-los. Em casos extremos, voc√™ pode usar o Pushgateway como ponte: o sistema legado faz push de alguma m√©trica b√°sica para o gateway (n√£o ideal, mas poss√≠vel).</p>
</li>
</ul>
<blockquote>
<p>Em resumo, <strong>sempre</strong> √© poss√≠vel integrar algo ao Prometheus, ainda que indiretamente. A comunidade j√° produziu exporters para muitos sistemas fechados (WebLogic, SAP, etc.). E como √∫ltimo recurso, extrair dados e expor manualmente n√£o √© t√£o complexo gra√ßas √†s bibliotecas cliente dispon√≠veis.</p></blockquote>
<h2 id="alertmanager">Alertmanager</h2>
<p>O <strong><a href="https://prometheus.io/docs/alerting/latest/alertmanager/">Alertmanager</a></strong> complementa o Prometheus no tratamento de alertas. Enquanto o Prometheus detecta condi√ß√µes de alerta (com base nas m√©tricas e regras definidas), ele delega ao Alertmanager a fun√ß√£o de envio de notifica√ß√µes e gerenciamento desses alertas. Isso inclui agregar alertas similares, evitar duplica√ß√µes, silenciar alertas durante manuten√ß√£o, e encaminh√°-los para canais apropriados (e-mail, sistemas de chat, PagerDuty, etc.).</p>
<p><strong>Alta Disponibilidade:</strong> O Alertmanager suporta configura√ß√£o em cluster para alta disponibilidade. Quando m√∫ltiplas inst√¢ncias do Alertmanager est√£o ativas, elas se comunicam entre si para deduplicar alertas vindos de dois Prometheus id√™nticos, garantindo que apenas uma notifica√ß√£o seja enviada mesmo quando m√∫ltiplas fontes detectam o mesmo problema.</p>
<blockquote>
<p>Como funciona: voc√™ define no Prometheus regras de alerta (no arquivo de configura√ß√£o ou separado) com express√µes PromQL que identificam situa√ß√µes problem√°ticas. Por exemplo: &ldquo;se a m√©trica <code>up</code> de um servidor for 0 por 5 minutos, dispare alerta&rdquo;.</p></blockquote>
<p>Quando a condi√ß√£o √© verdadeira, o Prometheus gera um evento de alerta e o envia para o Alertmanager (que est√° configurado na se√ß√£o <code>alerting</code> do prometheus.yml).</p>
<blockquote>
<p>O Alertmanager ent√£o aplica suas pr√≥prias regras de roteamento: por exemplo, enviar alertas de severidade cr√≠tica para um webhook do Slack e para email da equipe X, alertas menos graves s√≥ para email, etc&hellip;</p></blockquote>
<p><strong>Exemplo pr√°tico:</strong> Vamos configurar um alerta de servidor fora do ar com notifica√ß√£o no Slack.</p>
<ol>
<li><strong>Definir regra de alerta (Prometheus):</strong> Crie um arquivo <code>alert.rules.yml</code>:</li>
</ol>


  <pre><code class="language-yaml">groups:
- name: instance_down
  rules:
    - alert: InstanceDown
      expr: up == 0
      for: 1m
      labels:
        severity: critical
      annotations:
        summary: &#34;Inst√¢ncia {{ $labels.instance }} fora do ar&#34;
        description: &#34;O alvo {{ $labels.instance }} n√£o respondeu √†s coletas por mais de 1 minuto.&#34;</code></pre>
 <p>Essa regra verifica a m√©trica <code>up</code> de todos os alvos; se qualquer um estiver com valor 0 (significa alvo inacess√≠vel) por 1 minuto cont√≠nuo, aciona o alerta <strong>InstanceDown</strong> com severidade <strong>critical</strong>. As anota√ß√µes fornecem um resumo e descri√ß√£o usando templating (inserindo o label instance do alvo problem√°tico).</p>
<ol start="2">
<li><strong>Incluir regra e Alertmanager na config do Prometheus:</strong> No <code>prometheus.yml</code>, adicionar:</li>
</ol>


  <pre><code class="language-yaml">rule_files:
  - &#34;alert.rules.yml&#34;

alerting:
  alertmanagers:
    - static_configs:
        - targets: [&#39;alertmanager:9093&#39;]</code></pre>
 <p>Aqui presumimos que o Alertmanager est√° rodando e acess√≠vel no endere√ßo <code>alertmanager:9093</code> (no Docker Compose, por ex.). O Prometheus agora carrega as regras de alerta e sabe para onde enviar notifica√ß√µes.</p>
<ol start="3">
<li><strong>Configurar o Alertmanager (alertmanager.yml):</strong> Exemplo m√≠nimo para Slack:</li>
</ol>


  <pre><code class="language-yaml">route:
  group_by: [&#39;alertname&#39;]
  receiver: &#39;time-slack&#39;
receivers:
  - name: &#39;time-slack&#39;
    slack_configs:
      - api_url: &#39;https://hooks.slack.com/services/T000/B000/XXXXX&#39;  # Webhook do Slack
        channel: &#39;#alerts&#39;
        send_resolved: true
        title: &#34;{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}&#34;
        text: &#34;{{ range .Alerts }}{{ .Annotations.description }}{{ end }}&#34;</code></pre>
 <p>Esse config muito b√°sico diz: todos alertas (n√£o importa o grupo_by, etc.) ir√£o para o receptor nomeado &rsquo;time-slack&rsquo;, que tem um slack_config apontando para um webhook do Slack no canal <strong>#alerts</strong>. O <code>title</code> e <code>text</code> da mensagem aproveitam as anota√ß√µes definidas na regra (summary e description).</p>
<p>O valor <code>send_resolved: true</code> indica para notificar tamb√©m quando o alerta for resolvido.</p>
<p>Em produ√ß√£o, o Alertmanager pode ter rotas mais elaboradas ‚Äì por exemplo, roteando com base em labels de alerta (team=A vai para equipe A, severidade critical pode mandar SMS, etc.), escalonamento, agrupamento por determinados campos (como agrupar todos alertas do mesmo datacenter numa s√≥ notifica√ß√£o), etc.</p>
<ol start="4">
<li><strong>Executar e testar:</strong> Rode o Alertmanager com esse config (no Docker ou bin√°rio). Quando um alerta InstanceDown ocorrer, o Prometheus vai enviar para o Alertmanager, que em seguida usar√° a integra√ß√£o <a href="https://prometheus.io/docs/alerting/latest/configuration/#slack-receiver">Slack</a> para postar no canal configurado uma mensagem com t√≠tulo &ldquo;Inst√¢ncia X fora do ar&rdquo; e descri√ß√£o com detalhes.</li>
</ol>
<p>Esse foi um exemplo focado em Slack, mas o Alertmanager suporta muitos outros <strong>receivers</strong>: e-mail (SMTP), PagerDuty, OpsGenie, VictorOps, Webhooks gen√©ricos, entre outros. Com ele, voc√™ ganha flexibilidade para gerenciar o &ldquo;barulho&rdquo; de alertas: por exemplo, suprimir alertas filhos quando um pai j√° ocorreu (<a href="https://prometheus.io/docs/alerting/latest/configuration/#inhibition">inhibition</a>), ou silenciar certos alertas durante janelas de manuten√ß√£o planejada.</p>
<blockquote>
<p><strong>Observa√ß√£o:</strong> O Alertmanager n√£o √© obrigat√≥rio ‚Äì voc√™ pode rodar o Prometheus sem ele se n√£o precisar de notifica√ß√µes externas. Por√©m, para qualquer ambiente de produ√ß√£o, √© altamente recomendado configur√°-lo para n√£o depender de ficar olhando a p√°gina /alerts manualmente. Em outro artigo abordaremos em detalhes boas pr√°ticas de configura√ß√£o do Alertmanager.</p></blockquote>
<h3 id="alertmanager-avan√ßado-silencing-e-inhibition">Alertmanager Avan√ßado: Silencing e Inhibition</h3>
<p>Em ambientes de produ√ß√£o com muitos alertas, o <strong>&ldquo;alert fatigue&rdquo;</strong> (fadiga de alertas) pode ser um problema s√©rio. O Alertmanager oferece funcionalidades avan√ßadas para gerenciar esse cen√°rio: <strong>silencing</strong> (silenciamento) e <strong>inhibition</strong> (inibi√ß√£o).</p>
<h4 id="silencing">Silencing</h4>
<p>O <strong>silencing</strong> permite suprimir temporariamente alertas espec√≠ficos, geralmente durante janelas de manuten√ß√£o planejada. Isso evita spam desnecess√°rio quando voc√™ j√° sabe que um servi√ßo estar√° indispon√≠vel.</p>
<p><strong>Exemplo de configura√ß√£o de silence:</strong></p>


  <pre><code class="language-yaml"># Via API do Alertmanager (POST /api/v1/silences)
{
  &#34;matchers&#34;: [
    {
      &#34;name&#34;: &#34;alertname&#34;,
      &#34;value&#34;: &#34;InstanceDown&#34;,
      &#34;isRegex&#34;: false
    },
    {
      &#34;name&#34;: &#34;instance&#34;,
      &#34;value&#34;: &#34;web-server-01:9100&#34;,
      &#34;isRegex&#34;: false
    }
  ],
  &#34;startsAt&#34;: &#34;2023-12-01T10:00:00Z&#34;,
  &#34;endsAt&#34;: &#34;2023-12-01T12:00:00Z&#34;,
  &#34;createdBy&#34;: &#34;admin&#34;,
  &#34;comment&#34;: &#34;Manuten√ß√£o programada do servidor web-01&#34;
}</code></pre>
 <p><strong>Silencing via interface web:</strong>
O Alertmanager oferece uma interface web em <code>/silences</code> onde voc√™ pode criar silences interativamente, especificando:</p>
<ul>
<li><strong>Matchers</strong>: Labels que identificam os alertas a silenciar</li>
<li><strong>Dura√ß√£o</strong>: Per√≠odo de silenciamento (in√≠cio e fim)</li>
<li><strong>Coment√°rio</strong>: Justificativa para o silence</li>
</ul>
<h4 id="inhibition">Inhibition</h4>
<p>A <strong>inhibition</strong> permite suprimir alertas secund√°rios quando um alerta prim√°rio j√° est√° ativo. Por exemplo, se um servidor caiu (alerta cr√≠tico), n√£o faz sentido alertar sobre &ldquo;disco quase cheio&rdquo; ou &ldquo;alta lat√™ncia&rdquo; na mesma inst√¢ncia.</p>
<p><strong>Exemplo de configura√ß√£o de inhibition:</strong></p>


  <pre><code class="language-yaml">inhibit_rules:
  # Se um alerta critical estiver ativo, suprimir warnings da mesma inst√¢ncia
  - source_match:
      severity: &#39;critical&#39;
    target_match:
      severity: &#39;warning&#39;
    equal: [&#39;instance&#39;, &#39;job&#39;]
  
  # Se um datacenter estiver down, suprimir alertas de servi√ßos internos
  - source_match:
      alertname: &#39;DatacenterDown&#39;
    target_match:
      severity: &#39;warning&#39;
    equal: [&#39;datacenter&#39;]
  
  # Se CPU estiver 100%, suprimir alertas de alta lat√™ncia
  - source_match:
      alertname: &#39;HighCPUUsage&#39;
      severity: &#39;critical&#39;
    target_match:
      alertname: &#39;HighLatency&#39;
    equal: [&#39;instance&#39;]</code></pre>
 <p><strong>Casos de uso comuns:</strong></p>
<ul>
<li><strong>Alertas de infraestrutura</strong>: Se um rack/datacenter caiu, suprimir alertas de servi√ßos que dependem dele</li>
<li><strong>Alertas de aplica√ß√£o</strong>: Se um servi√ßo cr√≠tico est√° down, n√£o alertar sobre m√©tricas secund√°rias</li>
<li><strong>Alertas de depend√™ncia</strong>: Se um banco de dados est√° inacess√≠vel, suprimir alertas de aplica√ß√µes que dependem dele</li>
</ul>
<h4 id="routing-avan√ßado">Routing Avan√ßado</h4>
<p>O Alertmanager permite roteamento sofisticado baseado em labels de alerta:</p>


  <pre><code class="language-yaml">route:
  group_by: [&#39;alertname&#39;, &#39;cluster&#39;, &#39;service&#39;]
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 4h
  
  routes:
    # Alertas cr√≠ticos v√£o para PagerDuty &#43; Slack
    - match:
        severity: critical
      receiver: &#39;pager-duty-critical&#39;
      continue: true  # Continua para o pr√≥ximo receiver
    
    # Alertas cr√≠ticos tamb√©m v√£o para Slack
    - match:
        severity: critical
      receiver: &#39;slack-critical&#39;
    
    # Alertas de infraestrutura v√£o para equipe de infra
    - match:
        job: node
      receiver: &#39;infra-team&#39;
    
    # Alertas de aplica√ß√£o v√£o para equipe de dev
    - match:
        job: app
      receiver: &#39;dev-team&#39;
    
    # Default: todos os outros alertas v√£o para Slack geral
    - receiver: &#39;slack-general&#39;

receivers:
  - name: &#39;pager-duty-critical&#39;
    pagerduty_configs:
      - service_key: &#39;your-pagerduty-key&#39;
  
  - name: &#39;slack-critical&#39;
    slack_configs:
      - api_url: &#39;https://hooks.slack.com/services/...&#39;
        channel: &#39;#alerts-critical&#39;
  
  - name: &#39;infra-team&#39;
    slack_configs:
      - api_url: &#39;https://hooks.slack.com/services/...&#39;
        channel: &#39;#infra-alerts&#39;
  
  - name: &#39;dev-team&#39;
    slack_configs:
      - api_url: &#39;https://hooks.slack.com/services/...&#39;
        channel: &#39;#dev-alerts&#39;
  
  - name: &#39;slack-general&#39;
    slack_configs:
      - api_url: &#39;https://hooks.slack.com/services/...&#39;
        channel: &#39;#monitoring&#39;</code></pre>
 <p><strong>Recursos avan√ßados:</strong></p>
<ul>
<li><strong>Agrupamento inteligente</strong>: <code>group_by</code> agrupa alertas similares em uma notifica√ß√£o</li>
<li><strong>Tempo de espera</strong>: <code>group_wait</code> aguarda antes de enviar o primeiro alerta do grupo</li>
<li><strong>Intervalo de repeti√ß√£o</strong>: <code>repeat_interval</code> define quando reenviar alertas n√£o resolvidos</li>
<li><strong>Roteamento condicional</strong>: <code>continue: true</code> permite m√∫ltiplos receivers para o mesmo alerta</li>
</ul>
<h2 id="pushgateway">PushGateway</h2>
<p>O <strong><a href="https://prometheus.io/docs/instrumenting/pushing/">Pushgateway</a></strong> √© um componente auxiliar do ecossistema Prometheus que permite coletar m√©tricas via modelo <em>push</em> em situa√ß√µes espec√≠ficas. A ideia √© que certos jobs ou aplicativos ef√™meros, que n√£o t√™m como serem raspados diretamente (por exemplo, um script cron que executa e termina rapidamente), possam empurrar suas m√©tricas para um gateway intermedi√°rio. O Prometheus ent√£o coleta essas m√©tricas do Pushgateway posteriormente.</p>
<p>Funciona assim: o job de curta dura√ß√£o (ou qualquer processo que n√£o viva tempo suficiente para ser raspado) envia um HTTP POST para o Pushgateway com suas m√©tricas no formato Prometheus. O Pushgateway armazena essas m√©tricas em mem√≥ria e as exp√µe em seu pr√≥prio <code>/metrics</code>. O Prometheus configura um scrape no Pushgateway, coletando tudo que estiver l√°.</p>
<p><strong>Por√©m,</strong> √© importante entender que o Pushgateway deve ser usado com modera√ß√£o e prop√≥sito claro. Ele n√£o √© um agente gen√©rico para substituir o modelo pull. Alguns pontos de aten√ß√£o destacados pela documenta√ß√£o oficial:</p>
<ul>
<li>Se m√∫ltiplas inst√¢ncias usam um mesmo Pushgateway, ele vira um ponto central de falha e potencial gargalo.</li>
<li>Voc√™ perde a detec√ß√£o autom√°tica de <em>down</em> (j√° que as m√©tricas s√£o push, o Prometheus n√£o sabe se um job n√£o est√° rodando ou s√≥ n√£o teve m√©tricas recentes).</li>
<li>O Pushgateway <strong>n√£o expira</strong> automaticamente s√©ries que foram enviadas. Uma vez que uma m√©trica √© empurrada, ela ficar√° l√° at√© ser sobrescrita ou manualmente apagada via API do Pushgateway. Isso significa que m√©tricas de jobs antigos podem ficar persistindo como &ldquo;fantasmas&rdquo;, exigindo que voc√™ gerencie remo√ß√£o ou inclus√£o de algum label de <em>instance</em> para distingui-las.</li>
</ul>
<p>Devido a esses aspectos, o uso recomendado do Pushgateway √© <strong>capturar resultados de jobs batch de n√≠vel de servi√ßo</strong> ‚Äì isto √©, trabalhos que n√£o pertencem a uma √∫nica m√°quina ou inst√¢ncia espec√≠fica, mas sim algo como &ldquo;um script de limpeza de banco que roda uma vez por dia&rdquo;.</p>
<p>Nesse caso, o job emite (push) uma m√©trica do tipo &ldquo;usuarios_deletados_total{job=&ldquo;cleanup&rdquo;} 123&rdquo; e termina. O Pushgateway guarda esse valor.</p>
<p>O Prometheus, ao raspar, ter√° essa informa√ß√£o agregada do job. Como esse tipo de job n√£o tem um &ldquo;endpoint&rdquo; pr√≥prio para scrap, o Pushgateway serve como cache.</p>
<p>Para outros cen√°rios, onde o push √© considerado porque h√° firewall/NAT impedindo scrapes, a documenta√ß√£o sugere alternativas melhores ‚Äì como rodar Prometheus perto dos alvos (dentro da rede) ou usar algo como o <strong><a href="https://github.com/prometheus/pushprox">PushProx</a></strong> para atravessar firewalls mantendo o modelo pull. E para jobs cron por m√°quina, que t√™m contexto de host, recomenda-se usar o <strong><a href="https://github.com/prometheus/node_exporter#textfile-collector">Node Exporter Textfile Collector</a></strong> (escrever m√©tricas em um arquivo que o Node Exporter l√™), ao inv√©s do Pushgateway.</p>
<blockquote>
<p>Resumindo: o Pushgateway √© √∫til, mas <strong>somente</strong> em casos espec√≠ficos. Evite us√°-lo para coletar m√©tricas de servi√ßos normais (isso seria ‚Äúusar push por pregui√ßa‚Äù, e acarretaria problemas de dados stale e falta de detec√ß√£o de falha). Use-o para jobs batch pontuais, e mesmo assim, sem abusar ‚Äì lembre-se de limpar m√©tricas antigas se necess√°rio, ou projetar os labels de modo que cada job substitua seu pr√≥prio valor sem acumular lixo.</p></blockquote>
<h2 id="federa√ß√£o">Federa√ß√£o</h2>
<p>A <strong>federa√ß√£o</strong> no Prometheus permite que uma inst√¢ncia do Prometheus (geralmente chamada de <strong>federadora</strong> ou <strong>global</strong>) fa√ßa scrape em endpoints de outras inst√¢ncias do Prometheus (<strong>federadas</strong>) para obter um subconjunto de suas m√©tricas.</p>
<p>Em outras palavras, √© uma forma de <strong>hierarquizar</strong> o monitoramento: por exemplo, voc√™ pode ter um Prometheus por data center coletando tudo localmente, e um Prometheus global que apenas busca m√©tricas j√° agregadas de cada data center para ter uma vis√£o geral corporativa.</p>
<p>Existem dois casos de uso principais para federa√ß√£o:</p>
<ol>
<li>
<p><strong><a href="https://prometheus.io/docs/prometheus/latest/federation/">Agrega√ß√£o hier√°rquica</a></strong>: como no exemplo acima, onde cada Prometheus local faz o trabalho pesado e calcula agregados (soma de CPU por datacenter, lat√™ncia m√©dia de servi√ßo X por datacenter, etc.), e o Prometheus global s√≥ extrai essas s√©ries agregadas prontas. Isso d√° uma vis√£o do todo sem sobrecarregar a inst√¢ncia global com todas as s√©ries detalhadas.</p>
</li>
<li>
<p><strong><a href="https://prometheus.io/docs/prometheus/latest/federation/">Checagens cruzadas ou seletivas</a></strong>: Puxar algumas poucas m√©tricas de outra inst√¢ncia para compara√ß√µes. Exemplo: voc√™ tem um Prometheus dedicado a HAProxy e outro para um app front-end, pode federar a m√©trica de QPS do HAProxy no Prometheus do front-end para checar se ambos observam o mesmo tr√°fego. Normalmente, isso √© usado at√© mesmo apenas para alertas (voc√™ pode configurar alertas usando essas poucas m√©tricas federadas).</p>
</li>
</ol>
<p><strong><a href="https://prometheus.io/docs/prometheus/latest/federation/#when-not-to-use-federation">Quando N√ÉO usar federa√ß√£o</a>:</strong> a tenta√ß√£o de federar tudo de todos os Prometheus em um ‚Äúsuper Prometheus‚Äù central deve ser evitada. Pegar todas as s√©ries de inst√¢ncias filhas e centralizar em uma s√≥ inst√¢ncia global traz v√°rios problemas:</p>
<ul>
<li><strong>Escalabilidade limitada:</strong> O desempenho do Prometheus √© limitado pelos recursos de um √∫nico n√≥ (n√£o escala horizontalmente). Se voc√™ puxa tudo para um s√≥ servidor global, no fim do dia voc√™ est√° limitado ao throughput e mem√≥ria de uma m√°quina. Isso anula a distribui√ß√£o de carga que m√∫ltiplas inst√¢ncias proporcionam.</li>
<li><strong>Performance e carga duplicada:</strong> Al√©m de sobrecarregar a inst√¢ncia global ao ter que armazenar e consultar tudo, a pr√≥pria opera√ß√£o de federa√ß√£o (expor /federate e responder a scraping) gera carga nas inst√¢ncias filhas. Se a consulta federada n√£o for focada (usar express√µes match[] gen√©ricas demais), pode consumir muitos recursos para as inst√¢ncias fonte servirem esses dados.</li>
<li><strong>Confiabilidade reduzida:</strong> Voc√™ adiciona um ponto extra de falha. Se o link entre uma inst√¢ncia local e a global cair, a inst√¢ncia global ‚Äúfica cega‚Äù √†quele segmento. E pior, se voc√™ centralizou a avalia√ß√£o de certos alertas s√≥ no global, pode ficar sem alertas (falso negativo) caso o global perca conex√£o com os locais. A recomenda√ß√£o de especialistas √© sempre que poss√≠vel avaliar alertas o mais localmente poss√≠vel ‚Äì por exemplo, um alerta ‚Äúservi√ßo X caiu‚Äù deve ser definido no Prometheus que coleta servi√ßo X, n√£o em um global distante, exatamente para n√£o depender de rede.</li>
<li><strong>Delay e poss√≠veis inconsist√™ncias:</strong> A federa√ß√£o n√£o √© instant√¢nea; h√° lat√™ncia entre um dado ser coletado no Prometheus filho e ser federado pelo pai. Al√©m disso, condi√ß√µes de corrida podem fazer o global perder algumas amostras ou ver valores ligeiramente diferentes (por exemplo, contadores que resetaram podem parecer estranhos). Para uns poucos agregados isso √© toler√°vel, mas se voc√™ federar tudo e depender disso para alertar, pode ter sutilezas indesejadas.</li>
<li><strong>Complexidade de configura√ß√£o e seguran√ßa:</strong> √â mais complexo gerenciar dois n√≠veis de Prometheus, com configura√ß√µes de match[], externas labels √∫nicas por inst√¢ncia, etc. Tamb√©m √© necess√°rio expor o endpoint /federate das inst√¢ncias filhas ‚Äì o que pode ampliar a superf√≠cie de ataque ou requerer configura√ß√µes TLS, autentica√ß√£o, caso atravesse redes n√£o confi√°veis.</li>
</ul>
<p>Em raz√£o desses fatores, a federa√ß√£o deve ser usada <strong>apenas</strong> para casos de uso bem planejados (tipicamente agrega√ß√µes de baixo volume ou m√©tricas espec√≠ficas). N√£o √© a solu√ß√£o adequada para reten√ß√£o de longo prazo nem para alta disponibilidade.</p>
<blockquote>
<p><strong>NOTA:</strong> Para necessidades de <strong>escalabilidade horizontal</strong> e <strong>armazenamento de longo prazo</strong>, surgiram outros projetos que complementam o Prometheus, como <strong>Thanos</strong>, <strong>Cortex</strong> e <strong>Mimir</strong> (Grafana Labs). Essas solu√ß√µes armazenam as s√©ries em storage distribu√≠do (objeto, bigtable, etc.) e permitem ‚Äújuntar‚Äù m√∫ltiplas inst√¢ncias como se fossem uma s√≥, suportando consultas globais e reten√ß√£o virtualmente infinita. Exploraremos essas alternativas em outro artigo, mas adianta-se que elas resolvem muitos dos problemas de tentar usar federa√ß√£o pura para esses fins.</p></blockquote>
<h2 id="remote-write-e-remote-read">Remote Write e Remote Read</h2>
<p>O Prometheus pode ser configurado para enviar suas m√©tricas em tempo real para bancos externos (<strong>remote write</strong>) e buscar dados hist√≥ricos de outros sistemas (<strong>remote read</strong>). Essa funcionalidade √© fundamental para integra√ß√£o com solu√ß√µes de armazenamento de longo prazo, compliance e an√°lise de dados.</p>
<h3 id="remote-write">Remote Write</h3>
<p>O <strong>remote write</strong> permite que o Prometheus envie amostras coletadas para sistemas externos em tempo real, mantendo uma c√≥pia local. Isso √© √∫til para:</p>
<ul>
<li><strong>Reten√ß√£o de longo prazo</strong>: Enviar dados para sistemas como InfluxDB, TimescaleDB, ou solu√ß√µes cloud</li>
<li><strong>Compliance e auditoria</strong>: Manter m√©tricas por meses/anos para requisitos regulat√≥rios</li>
<li><strong>Machine Learning</strong>: Integrar com plataformas de ML para an√°lise preditiva</li>
<li><strong>Correla√ß√£o de dados</strong>: Combinar m√©tricas com logs e traces em sistemas unificados</li>
</ul>
<p><strong>Exemplo de configura√ß√£o:</strong></p>


  <pre><code class="language-yaml">remote_write:
  - url: &#34;https://longterm.example.com/api/v1/write&#34;
    basic_auth:
      username: &#34;prometheus&#34;
      password: &#34;password&#34;
    write_relabel_configs:
      - source_labels: [__name__]
        regex: &#39;node_.*&#39;
        action: keep
    queue_config:
      max_samples_per_send: 1000
      max_shards: 30
      capacity: 2500</code></pre>
 <p><strong>Configura√ß√µes importantes:</strong></p>
<ul>
<li><strong><code>url</code></strong>: Endpoint do sistema de destino</li>
<li><strong><code>basic_auth</code></strong>: Autentica√ß√£o b√°sica (tamb√©m suporta TLS)</li>
<li><strong><code>write_relabel_configs</code></strong>: Filtros para enviar apenas m√©tricas espec√≠ficas</li>
<li><strong><code>queue_config</code></strong>: Configura√ß√µes de buffer e performance</li>
</ul>
<h3 id="remote-read">Remote Read</h3>
<p>O <strong>remote read</strong> permite que o Prometheus busque dados hist√≥ricos de sistemas externos, como se fossem parte do seu TSDB local. Isso √© √∫til para:</p>
<ul>
<li><strong>Consultas hist√≥ricas</strong>: Acessar dados antigos sem manter tudo localmente</li>
<li><strong>Migra√ß√£o de dados</strong>: Transi√ß√£o gradual entre sistemas de armazenamento</li>
<li><strong>An√°lise retrospectiva</strong>: Investigar incidentes passados com dados completos</li>
</ul>
<p><strong>Exemplo de configura√ß√£o:</strong></p>


  <pre><code class="language-yaml">remote_read:
  - url: &#34;https://longterm.example.com/api/v1/read&#34;
    basic_auth:
      username: &#34;prometheus&#34;
      password: &#34;password&#34;
    read_recent: true
    required_matchers:
      - label: &#34;job&#34;
        value: &#34;node&#34;</code></pre>
 <h3 id="casos-de-uso-t√≠picos">Casos de Uso T√≠picos</h3>
<p><strong>1. Integra√ß√£o com Grafana Cloud:</strong></p>


  <pre><code class="language-yaml">remote_write:
  - url: &#34;https://prometheus-prod-XX-XXX.grafana.net/api/prom/push&#34;
    basic_auth:
      username: &#34;12345&#34;
      password: &#34;glc_eyJvIjoiOTk5OTkiLCJuIjoiYWRtaW4iLCJpIjoiMTIzNDU2Nzg5MCJ9&#34;</code></pre>
 <p><strong>2. Envio para InfluxDB:</strong></p>


  <pre><code class="language-yaml">remote_write:
  - url: &#34;http://influxdb:8086/api/v2/prom/write?org=myorg&amp;bucket=prometheus&#34;
    basic_auth:
      username: &#34;admin&#34;
      password: &#34;password&#34;</code></pre>
 <p><strong>3. M√∫ltiplos destinos:</strong></p>


  <pre><code class="language-yaml">remote_write:
  - url: &#34;https://backup-storage.example.com/write&#34;
    write_relabel_configs:
      - source_labels: [__name__]
        regex: &#39;.*&#39;
        action: keep
  - url: &#34;https://ml-platform.example.com/metrics&#34;
    write_relabel_configs:
      - source_labels: [__name__]
        regex: &#39;app_.*&#39;
        action: keep</code></pre>
 <blockquote>
<p><strong>Importante</strong>: Remote write/read n√£o substitui o armazenamento local do Prometheus. O TSDB local continua sendo usado para consultas recentes e alertas. O remote write √© <strong>aditivo</strong> - voc√™ mant√©m os dados locais e envia uma c√≥pia para sistemas externos.</p></blockquote>
<h2 id="under-the-hood">Under the Hood</h2>
<p>Nesta se√ß√£o, vamos dissecar o funcionamento interno do armazenamento de dados do Prometheus ‚Äì o <strong><a href="https://prometheus.io/docs/introduction/architecture/#time-series-database">Time Series Database</a></strong> (TSDB) local ‚Äì e entender por que ele consome recursos como consome.</p>
<p>Quando instalamos o Prometheus, uma pasta de dados (por padr√£o chamada <code>data/</code>) √© usada para persistir as s√©ries temporais coletadas. Dentro dela, os dados s√£o organizados em blocos de tempo fixo. Por padr√£o, cada <strong>bloco</strong> cobre 2 horas de m√©tricas. Ap√≥s duas horas de coleta, o Prometheus fecha aquele bloco e inicia outro.</p>
<p>Periodicamente, v√°rios blocos menores podem ser compactados em blocos maiores (por exemplo, 5 blocos de 2h podem ser mesclados num bloco de 10h de dados, e assim por diante). A estrutura de arquivos t√≠pica em <code>data/</code> √© assim (exemplo simplificado):</p>


  <pre><code class="language-">data/
‚îú‚îÄ‚îÄ 01GZY5ABCD.../       # pasta de um bloco de dados
‚îÇ   ‚îú‚îÄ‚îÄ meta.json        # metadados do bloco
‚îÇ   ‚îú‚îÄ‚îÄ index            # √≠ndice para busca das s√©ries no bloco
‚îÇ   ‚îú‚îÄ‚îÄ chunks/          # peda√ßos contendo os samples comprimidos
‚îÇ   ‚îî‚îÄ‚îÄ tombstones       # (pode estar vazio) marca√ß√µes de dele√ß√£o
‚îú‚îÄ‚îÄ 01GZY1WXYZ.../       # outro bloco (mais antigo, por ex)
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ chunks_head/         # chunks do bloco &#34;head&#34; atual (em uso)
‚îî‚îÄ‚îÄ wal/                 # Write-Ahead Log (log de escrita recente)
    ‚îú‚îÄ‚îÄ 00000000
    ‚îú‚îÄ‚îÄ 00000001
    ‚îî‚îÄ‚îÄ checkpoint.000001/ ...</code></pre>
 <p>Cada bloco de 2h √© identificado por um <strong><a href="https://github.com/prometheus/prometheus/blob/main/tsdb/encoding/ulid.go">ULID</a></strong> (ID √∫nico lexicograficamente orden√°vel) que comp√µe o nome da pasta. Dentro de um bloco, temos:</p>
<ul>
<li><strong>meta.json:</strong> arquivo JSON com metadados do bloco (faixa de tempo coberta, stats de quantas s√©ries/amostras cont√©m, hist√≥rico de compacta√ß√£o, etc.).</li>
<li><strong>index:</strong> arquivo de √≠ndice invertido para permitir procurar s√©ries rapidamente pelo nome e labels, e localizar em quais chunks est√£o seus dados.</li>
<li><strong>chunks/</strong>: diret√≥rio contendo os arquivos bin√°rios de chunks de dados. Os <em>chunks</em> s√£o os blocos comprimidos de amostras das s√©ries. Cada arquivo (nomeado como 000001, 000002, &hellip;) cont√©m muitos chunks. O tamanho m√°ximo de cada arquivo √© ~512MB para facilitar gerenciamento.</li>
<li><strong>tombstones:</strong> arquivo que registra intervalos de dados deletados manualmente (via API de delete), se houver.</li>
</ul>
<p>Al√©m dos blocos fechados, existe o <strong><a href="https://prometheus.io/docs/introduction/architecture/#head-block">Head block</a></strong> (bloco atual em mem√≥ria) que armazena as m√©tricas em curso. Os dados mais recentes (√∫ltimas ~2h) residem em mem√≥ria para escrita r√°pida e consultas de curt√≠ssimo prazo.</p>
<p>A cada 2h, o Prometheus ‚Äúdissolve‚Äù parte do Head em um bloco persistente e libera daquela mem√≥ria. Vamos inspecionar um exemplo de <strong>meta.json</strong> para entender seus campos:</p>


  <pre><code class="language-json">{
    &#34;ulid&#34;: &#34;01BKGTZQ1SYQJTR4PB43C8PD98&#34;,
    &#34;minTime&#34;: 1602237600000,
    &#34;maxTime&#34;: 1602244800000,
    &#34;stats&#34;: {
        &#34;numSamples&#34;: 553673232,
        &#34;numSeries&#34;: 1346066,
        &#34;numChunks&#34;: 4440437
    },
    &#34;compaction&#34;: {
        &#34;level&#34;: 1,
        &#34;sources&#34;: [
            &#34;01EM65SHSX4VARXBBHBF0M0FDS&#34;,
            &#34;01EM6GAJSYWSQQRDY782EA5ZPN&#34;
        ]
    },
    &#34;version&#34;: 1
}</code></pre>
 <p>Explicando os campos principais:</p>
<ul>
<li><strong>ulid:</strong> Identificador √∫nico do bloco (um c√≥digo 128-bit parecido com <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>). Ele √© tamb√©m o nome da pasta do bloco.</li>
<li><strong>minTime e maxTime:</strong> Timestamp inicial e final (epoch em milissegundos) cobertos pelos samples deste bloco. No exemplo, corresponde a um intervalo de 2h.</li>
<li><strong>stats:</strong> Estat√≠sticas do bloco ‚Äì quantas amostras (<a href="https://prometheus.io/docs/introduction/architecture/#head-block">numSamples</a>), s√©ries (<a href="https://prometheus.io/docs/introduction/architecture/#head-block">numSeries</a>) e chunks (<a href="https://prometheus.io/docs/introduction/architecture/#head-block">numChunks</a>) est√£o armazenados nele. No exemplo real acima, temos ~1,34 milh√£o de s√©ries distintas, totalizando 553 milh√µes de amostras em ~4,44 milh√µes de chunks dentro desse bloco de 2h. Esses n√∫meros d√£o uma no√ß√£o do volume de dados.</li>
<li><strong>compaction:</strong> Informa o hist√≥rico de compacta√ß√£o. <strong><a href="https://prometheus.io/docs/introduction/architecture/#head-block">level</a></strong> indica quantas vezes j√° foi compactado (1 significa um bloco resultante da jun√ß√£o de outros menores). <strong><a href="https://prometheus.io/docs/introduction/architecture/#head-block">sources</a></strong> lista os IDs dos blocos que foram combinados para formar este (no caso, dois blocos anteriores). Se o bloco foi gerado direto do Head (dados ‚Äúoriginais‚Äù), √†s vezes sources cont√©m ele pr√≥prio.</li>
<li><strong>version:</strong> Vers√£o do formato do bloco/arquivo (para compatibilidade futura).</li>
</ul>
<p>Com isso, entendemos que cada bloco √© imut√°vel depois de escrito. Se novos dados chegam daquele intervalo, seria criado um bloco novo via compaction. Isso facilita a confiabilidade ‚Äì dados hist√≥ricos n√£o mudam.</p>
<p>O <strong>arquivo de √≠ndice (index)</strong> serve para mapear as s√©ries e labels aos chunks dentro do bloco. Ele funciona como um √≠ndice invertido: dado um nome de m√©trica e um conjunto de labels, encontra os IDs das s√©ries correspondentes e, ent√£o, aponta para os chunks onde est√£o os dados daquela s√©rie.</p>
<p>Assim, ao fazer uma consulta, o Prometheus carrega o √≠ndice do bloco relevante e consegue buscar rapidamente somente os chunks necess√°rios (por exemplo, pula chunks inteiros que est√£o fora do range de tempo consultado, usando informa√ß√µes de minTime/maxtime dos chunks).</p>
<p>O √≠ndice √© altamente otimizado e comprimido ‚Äì usa conceitos de <a href="https://prometheus.io/docs/introduction/architecture/#posting-lists">posting lists</a> (listas de IDs de s√©ries para cada label-valor) e <a href="https://prometheus.io/docs/introduction/architecture/#symbol-table">tabelas de s√≠mbolos</a> para strings √∫nicas. Esses detalhes avan√ßados fogem do escopo aqui, mas o importante √©: o √≠ndice permite que mesmo com milh√µes de s√©ries por bloco, o Prometheus consiga localizar dados sem varrer tudo linearmente.</p>
<p>Finalmente, o <strong><a href="https://prometheus.io/docs/introduction/architecture/#write-ahead-log">WAL (Write-Ahead Log)</a></strong> √© um log de transa√ß√µes recente onde cada amostra coletada √© gravada imediatamente no disco antes de ser inserida na mem√≥ria do Head. Isso garante que, se o Prometheus cair inesperadamente, ao voltar ele pode reprocessar o WAL e recuperar as amostras que ainda n√£o tinham sido compactadas em blocos.</p>
<p>O WAL consiste em arquivos sequenciais (<code>00000000</code>, <code>00000001</code>, etc.) que v√£o acumulando as escritas. Periodicamente, o Prometheus faz um checkpoint (snapshot do head) e limpa parte do WAL j√° aplicado.</p>
<p>Em caso de crash, ele l√™ desde o √∫ltimo checkpoint para restaurar o estado do Head.</p>
<h3 id="gerenciamento-de-mem√≥ria-pelo-prometheus">Gerenciamento de mem√≥ria pelo Prometheus</h3>
<p>O Prometheus armazena as s√©ries temporais em mem√≥ria para r√°pido acesso √†s m√©tricas recentes, enquanto grava continuamente os novos dados no disco (WAL) para durabilidade. Isso pode levar a alto uso de RAM e espa√ßo em disco.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/main/post/images/tsdb/prom-mem02.png" alt=""></p>
<p>Como mencionado, o Prometheus mant√©m em RAM todas as s√©ries ativas do bloco atual (tipicamente √∫ltimas 2 horas de dados por s√©rie). Essa decis√£o arquitetural visa desempenho: consultas sobre dados recentes (que s√£o as mais comuns, e.g. alertas e dashboards de curto prazo) n√£o precisam esperar leitura de disco ‚Äì os valores j√° est√£o na mem√≥ria.</p>
<p>Al√©m disso, novas amostras sendo inseridas a cada segundo/minuto s√£o agregadas a estruturas em mem√≥ria (evitando I/O de disco a cada opera√ß√£o, que seria invi√°vel em alta escala). O resultado √© que o <strong>consumo de RAM</strong> do Prometheus cresce com o n√∫mero de s√©ries ativas e com a frequ√™ncia de coleta.</p>
<p>Estima-se, por experi√™ncias reportadas, que cada s√©rie ativa consome em torno de <strong>~3 KB de RAM</strong> (depende de labels, comprimento do nome, etc.). Portanto, 1 milh√£o de s√©ries pode usar na ordem de 3‚Äì4 GB de RAM apenas para manter o head da TSDB.</p>
<p>Em paralelo, o Prometheus escreve todas as amostras no WAL (em disco) para n√£o perd√™-las em caso de crash. A cada 2 horas, ele ent√£o compacta esses dados quentes em um bloco de 2h comprimido e libera a mem√≥ria correspondente. Ou seja, h√° um ciclo onde a mem√≥ria vai sendo ocupada pelas amostras recentes, e de hora em hora (na verdade 2h) h√° um flush para disco que esvazia um pouco a mem√≥ria (mas novas s√©ries podem surgir e ocupar de novo).</p>
<p>O <em>design</em> de manter dados recentes em mem√≥ria traz a consequ√™ncia de que <strong>o uso de RAM aumenta com a carga de m√©tricas e n√£o √© liberado at√© que os blocos sejam fechados ou as s√©ries cessem</strong>. Em per√≠odos de pico (muitas s√©ries novas aparecendo rapidamente), o Prometheus pode chegar a consumir muita mem√≥ria para acompanhar.</p>
<p>Se faltar RAM, o processo corre risco de OOM (matar por falta de mem√≥ria) ou, no melhor caso, o sistema operacional vai come√ßar a usar swap ‚Äì o que degrada muito a performance. Na imagem acima, vemos que tanto a RAM quanto o armazenamento em disco podem crescer substancialmente √† medida que aumentamos o volume de dados monitorados.</p>
<blockquote>
<p><strong>Quanto mais dias de reten√ß√£o mantidos no Prometheus, mais recursos s√£o usados e maior o esfor√ßo para consultas longas. Manter dados hist√≥ricos demais pode sobrecarregar a mem√≥ria e o disco, al√©m de dificultar encontrar informa√ß√µes recentes relevantes.</strong></p></blockquote>
<p>Embora possamos configurar reten√ß√µes longas (30, 60 dias), isso n√£o significa que o Prometheus foi otimizado para operar eficientemente com esse hist√≥rico todo localmente. Lembre-se: ele n√£o indexa por data de forma distribu√≠da ‚Äì consultas que abrangem muitos dias ter√£o que ler v√°rios blocos do disco e processar um grande volume de amostras.</p>
<p>Na pr√°tica, reter al√©m de algumas semanas come√ßa a tornar as consultas bem lentas e o uso de disco muito alto (sem falar nos backups dessa quantidade de data). Consultas extensas acabam exigindo leitura de m√∫ltiplos blocos e processamento de grandes volumes de dados, o que impacta diretamente a performance do sistema.</p>
<p>A imagem acima ilustra que, √† medida que guardamos mais dias, o custo de recursos cresce e pode inclusive ofuscar tend√™ncias atuais no meio de tanto dado antigo.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/main/post/images/tsdb/prom-mem03.png" alt=""></p>
<p>A filosofia do Prometheus √© ser a ferramenta de <strong>monitoramento em tempo real</strong> e de curto/m√©dio prazo.</p>
<p>Para an√°lises hist√≥ricas longas ou compliance (guardar m√©tricas por 1 ano, por exemplo), a solu√ß√£o comum √© integrar um back-end de longo prazo (Thanos, Cortex, databases remotas) que arquivem esses dados, enquanto o Prometheus local mant√©m s√≥ o necess√°rio para opera√ß√£o/alertas recentes.</p>
<p>Assim voc√™ tem o melhor dos dois mundos: rapidez no real-time e hist√≥rico completo dispon√≠vel quando precisar, sem sobrecarregar o Prometheus diariamente.</p>
<blockquote>
<p>Todas as amostras recentes residem na mem√≥ria principal (Head), com flush peri√≥dico para disco a cada 2 horas. O WAL no disco captura as escritas para garantir durabilidade. Em situa√ß√£o de carga extrema, o OS pode usar swap, mas isso deve ser evitado pois degrada o desempenho.</p></blockquote>
<p>Vamos recapitular o ciclo de vida dos dados no Prometheus e seu impacto em mem√≥ria/disco:</p>
<ul>
<li>
<p><strong>Head Block (mem√≥ria):</strong> Novas s√©ries e amostras entram aqui. As s√©ries ativas ocupam estruturas na heap da aplica√ß√£o Go do Prometheus. A cada amostra recebida, ela tamb√©m √© anexada no <strong><a href="https://prometheus.io/docs/introduction/architecture/#write-ahead-log">WAL</a></strong> (no SSD/disco) para registro permanente. Durante at√© ~2h, os dados ficam dispon√≠veis no Head para consultas instant√¢neas. Por isso, consultas e alertas em dados &ldquo;frescos&rdquo; s√£o muito r√°pidas.</p>
</li>
<li>
<p><strong>Flush para bloco persistente:</strong> Quando o intervalo de 2h se completa, o Prometheus corta o bloco (na verdade ele espera 2h ou 1h30 dependendo de certas condi√ß√µes) e escreve um <strong><a href="https://prometheus.io/docs/introduction/architecture/#head-block">novo bloco</a></strong> no diret√≥rio data (contendo aqueles 2h de amostras agora imut√°veis, j√° comprimidas). Em seguida, libera da mem√≥ria boa parte das estruturas referentes √†quele intervalo. O head ent√£o mant√©m somente as s√©ries ainda ativas que extrapolem o pr√≥ximo bloco.</p>
</li>
<li>
<p><strong>Compaction:</strong> Ap√≥s algumas rota√ß√µes de bloco, o Prometheus agrupa blocos menores em blocos maiores (por exemplo, une 5 blocos de 2h em 1 bloco de 10h, e assim por diante). Isso ocorre em segundo plano e ajuda a reduzir o n√∫mero de arquivos e melhorar compress√£o geral. Compaction consome CPU/disk I/O, mas √© intercalado para n√£o interferir muito.</p>
</li>
<li>
<p><strong>Reten√ß√£o e cleanup:</strong> Quando um bloco excede a reten√ß√£o configurada (ex: ficou mais velho que 15 dias), ele √© marcado para dele√ß√£o. A limpeza ocorre periodicamente e remove blocos expirados. Importante: a remo√ß√£o n√£o √© imediata ao passar do prazo ‚Äì o processo de cleanup roda em intervalos (at√© 2h de delay). Durante a limpeza, o Prometheus deleta os diret√≥rios daqueles blocos antigos, liberando espa√ßo em disco.</p>
</li>
<li>
<p><strong>Rein√≠cio e recupera√ß√£o:</strong> Se o Prometheus reiniciar ou cair, na inicializa√ß√£o ele precisa recarregar o estado. Ele vai abrir todos os blocos persistentes (apenas meta e √≠ndice, sem carregar todos os dados) e principalmente processar o WAL para recriar o Head com as amostras que ainda n√£o estavam em bloco. Esse processo de recupera√ß√£o do WAL pode demorar dependendo do tamanho (por isso h√° checkpoint para otimizar). Ao final, o sistema retorna ao estado como se nunca tivesse parado (exceto pelos minutos offline onde dados podem ter se perdido se os alvos n√£o suportam retroativa).</p>
</li>
</ul>
<p>Tudo isso explica por que o Prometheus consome <strong>bastante mem√≥ria</strong>: ele aposta em manter as s√©ries recentes acess√≠veis e indexadas para respostas r√°pidas.</p>
<p>Num Prometheus com muitos alvos ou alta cardinalidade (muitas combina√ß√µes de labels), o consumo de RAM pode facilmente ser o principal limitador. Conforme mencionado anteriormente, 1 milh√£o de s√©ries ativas pode exigir v√°rios GB de RAM, portanto planeje a capacidade de acordo com o volume de m√©tricas esperado.</p>
<p>Infelizmente, n√£o h√° muito <strong>tunings</strong> manuais a fazer na mem√≥ria al√©m de reduzir a quantidade de dados: <strong>menos s√©ries ou menor frequ√™ncia de coleta</strong> = menos uso de RAM. O Prometheus n√£o tem um mecanismo interno de shard autom√°tico ou flush mais frequente (o flush √© fixo ~2h por design).</p>
<p>Ent√£o, as solu√ß√µes se resumem a <strong>escalar verticalmente</strong> (m√°quinas com mais mem√≥ria, CPU, disco r√°pido) ou <strong>escalar horizontalmente</strong> (dividir a carga entre v√°rios Prometheus, cada um monitorando uma parte das targets). Nas melhores pr√°ticas a seguir, daremos dicas para mitigar esses desafios de desempenho e dimensionamento.</p>
<h3 id="native-histograms-recurso-experimental">Native Histograms (Recurso Experimental)</h3>
<p>O Prometheus introduziu <strong>Native Histograms</strong> como um recurso experimental nas vers√µes mais recentes (2.40+). Essa funcionalidade representa uma evolu√ß√£o significativa na forma como histogramas s√£o armazenados e consultados.</p>
<h4 id="diferen√ßas-dos-histogramas-tradicionais">Diferen√ßas dos Histogramas Tradicionais</h4>
<p><strong>Histogramas tradicionais:</strong></p>
<ul>
<li>Usam buckets predefinidos (ex: 0.1, 0.5, 1.0, 2.5, 5.0, 10.0)</li>
<li>Cada bucket gera uma s√©rie separada (<code>_bucket</code>)</li>
<li>Requerem m√∫ltiplas s√©ries para representar uma distribui√ß√£o</li>
<li>Limitados pela granularidade dos buckets</li>
</ul>
<p><strong>Native Histograms:</strong></p>
<ul>
<li>Usam buckets din√¢micos e adaptativos</li>
<li>Armazenam a distribui√ß√£o completa em uma √∫nica s√©rie</li>
<li>Permitem maior precis√£o nos percentis</li>
<li>Reduzem significativamente o n√∫mero de s√©ries</li>
</ul>
<h4 id="configura√ß√£o-1">Configura√ß√£o</h4>
<p>Para habilitar native histograms, adicione a flag experimental:</p>


  <pre><code class="language-bash">prometheus --enable-feature=native-histograms</code></pre>
 <p>Ou no Docker:</p>


  <pre><code class="language-yaml">command:
  - &#39;--enable-feature=native-histograms&#39;</code></pre>
 <h4 id="exemplo-de-uso">Exemplo de Uso</h4>
<p><strong>Instrumenta√ß√£o com native histograms (Go):</strong></p>


  <pre><code class="language-go">import (
    &#34;github.com/prometheus/client_golang/prometheus&#34;
    &#34;github.com/prometheus/client_golang/prometheus/promauto&#34;
)

var (
    requestDuration = promauto.NewHistogram(prometheus.HistogramOpts{
        Name: &#34;http_request_duration_seconds&#34;,
        Help: &#34;Duration of HTTP requests&#34;,
        NativeHistogramBucketFactor: 1.1,  // Fator de crescimento dos buckets
        NativeHistogramMaxBucketNumber: 100, // M√°ximo de buckets
    })
)</code></pre>
 <p><strong>Consulta de percentis:</strong></p>


  <pre><code class="language-promql"># Percentil 95 usando native histogram
histogram_quantile(0.95, rate(http_request_duration_seconds[5m]))

# Percentil 99
histogram_quantile(0.99, rate(http_request_duration_seconds[5m]))</code></pre>
 <h4 id="vantagens">Vantagens</h4>
<ul>
<li><strong>Menos s√©ries</strong>: Uma m√©trica de lat√™ncia que antes gerava 10+ s√©ries agora gera apenas 1</li>
<li><strong>Maior precis√£o</strong>: Buckets adaptativos capturam melhor a distribui√ß√£o real</li>
<li><strong>Melhor performance</strong>: Menos overhead de armazenamento e consulta</li>
<li><strong>Compatibilidade</strong>: Funciona com todas as fun√ß√µes PromQL existentes</li>
</ul>
<h4 id="considera√ß√µes">Considera√ß√µes</h4>
<ul>
<li><strong>Experimental</strong>: Ainda em desenvolvimento, pode ter mudan√ßas na API</li>
<li><strong>Migra√ß√£o</strong>: Requer atualiza√ß√£o das bibliotecas cliente</li>
<li><strong>Compatibilidade</strong>: Funciona apenas com vers√µes recentes do Prometheus</li>
</ul>
<blockquote>
<p><strong>Nota</strong>: Native histograms s√£o especialmente √∫teis para m√©tricas de lat√™ncia em aplica√ß√µes de alta performance, onde a precis√£o dos percentis √© cr√≠tica.</p></blockquote>
<h2 id="melhores-pr√°ticas">Melhores Pr√°ticas</h2>
<p>Depois de entender a mec√¢nica interna do Prometheus, √© v√°lido reunir algumas recomenda√ß√µes para tirar o melhor proveito da ferramenta de forma escal√°vel e confi√°vel.</p>
<h3 id="planejamento-de-capacidade">Planejamento de Capacidade</h3>
<ul>
<li>
<p><strong>Estime volume de m√©tricas e reten√ß√£o:</strong> Antes de implantar, fa√ßa uma estimativa do n√∫mero de s√©ries que voc√™ vai coletar e defina uma reten√ß√£o condizente. Lembre que por padr√£o s√£o 15 dias. Se n√£o precisar de tudo isso para monitoramento di√°rio, reten√ß√µes menores aliviam recursos. Ao contr√°rio, se precisar de mais tempo hist√≥rico, esteja ciente do aumento de disco e possivelmente avalie armazenamento remoto.</p>
</li>
<li>
<p><strong>Monitore o Prometheus em si:</strong> &ldquo;Quis custodiet ipsos custodes?&rdquo; ‚Äì o Prometheus exp√µe suas pr√≥prias m√©tricas (no endpoint /metrics dele). Use um outro Prometheus ou a mesma inst√¢ncia para monitorar m√©tricas como <code>prometheus_tsdb_head_series</code> (n√∫mero de s√©ries no head), <code>prometheus_tsdb_head_samples_appended_total</code> (samples inseridos por segundo), <code>prometheus_engine_query_duration_seconds</code> (lat√™ncia das consultas), etc. Isso alerta para crescimento de cardinalidade inesperado ou consultas muito pesadas rodando.</p>
</li>
<li>
<p><strong>Dimensione hardware adequadamente:</strong> Regra emp√≠rica: 1 CPU core pode processar aproximadamente at√© 200k amostras por segundo (varia, mas √© uma ideia). Mem√≥ria, calcule ~3kB por s√©rie ativa. Disco: ~1-2 bytes por amostra armazenada comprimida (15 dias, 200 milh√µes de amostras ~ 200-300MB). Use SSDs r√°pidos ‚Äì opera√ß√µes de WAL e blocos beneficiam de I/O r√°pido.</p>
</li>
</ul>
<h3 id="organiza√ß√£o-de-m√©tricas-e-labels">Organiza√ß√£o de M√©tricas e Labels</h3>
<ul>
<li>
<p><strong>Consist√™ncia na nomea√ß√£o:</strong> Siga conven√ß√µes de nomenclatura para facilitar a vida. Use nomes descritivos e padronizados (letras min√∫sculas, separadas por underscores, unidade no sufixo se aplic√°vel: <code>_seconds</code>, <code>_bytes</code>, <code>_total</code> para contadores acumulativos). Por exemplo, prefira <code>app_memory_usage_bytes</code> a algo como <code>MemUsed</code> ou outras varia√ß√µes inconsistentes. Isso ajuda todo mundo a entender do que se trata sem ambiguidade.</p>
</li>
<li>
<p><strong>Labels estrat√©gicos:</strong> Anexe labels que fa√ßam sentido de consulta, mas evite rotular com informa√ß√µes que tenham alta cardinalidade ou unicidade. Um bom label √© algo como <code>region</code>, <code>datacenter</code>, <code>instance</code> (desde que este n√£o seja √∫nico por m√©trica ‚Äì use instance s√≥ onde faz sentido). Maus labels incluem: ID de requisi√ß√£o, nome de usu√°rio, URL completa (em vez de caminho gen√©rico), timestamp, IP din√¢mico de cliente. Esses valores criam um n√∫mero enorme de s√©ries distintas. Lembre-se: cada combina√ß√£o diferente de labels vira <strong>uma s√©rie separada</strong> no TSDB. Se voc√™ tiver 1000 usu√°rios e rotular m√©tricas por usu√°rio, virou 1000 s√©ries onde antes podia ser 1 ou algumas. Leve isso em conta.</p>
</li>
<li>
<p><strong>Explos√£o de cardinalidade:</strong> √â um dos problemas mais comuns. Por exemplo, adicionar um label <code>product_id</code> a uma m√©trica de pedidos, onde product_id pode assumir dezenas de milhares de valores, multiplicar√° as s√©ries. Isso pode levar o Prometheus a consumir toda mem√≥ria e travar. Portanto, s√≥ use labels cujo conjunto de valores poss√≠vel seja <strong>limitado e relativamente pequeno</strong>. (Regra de bolso: algumas dezenas ou poucas centenas de valores diferentes por label no m√°ximo. Mais que isso, pense duas vezes se √© necess√°rio.) Caso precise monitorar algo muito cardinal (ex: m√©tricas por usu√°rio √∫nico), talvez o Prometheus n√£o seja a ferramenta adequada ou voc√™ precisa agreg√°-las antes de expor.</p>
</li>
</ul>
<h4 id="o-inimigo-n¬∫-1-explos√£o-de-cardinalidade">O Inimigo n¬∫ 1: Explos√£o de Cardinalidade</h4>
<p><strong>A cardinalidade √© o maior desafio do Prometheus.</strong> Cada combina√ß√£o √∫nica de labels cria uma s√©rie temporal separada no TSDB. Quando voc√™ adiciona labels com valores altamente vari√°veis (como IDs de usu√°rio, timestamps, URLs completas, ou IPs din√¢micos), voc√™ est√° multiplicando exponencialmente o n√∫mero de s√©ries armazenadas.</p>
<p><strong>Por que √© t√£o perigoso:</strong></p>
<ul>
<li><strong>Consumo de mem√≥ria:</strong> Cada s√©rie ativa consome ~3kB de RAM. Milhares de s√©ries = gigabytes de mem√≥ria</li>
<li><strong>Performance de consultas:</strong> Mais s√©ries = consultas mais lentas e maior uso de CPU</li>
<li><strong>Instabilidade:</strong> Cardinalidade excessiva pode fazer o Prometheus travar ou reiniciar constantemente</li>
<li><strong>Custos de armazenamento:</strong> Mais s√©ries = mais dados para armazenar e processar</li>
</ul>
<p><strong>Exemplos de labels perigosos:</strong></p>
<ul>
<li><code>user_id</code> (pode ter milh√µes de valores √∫nicos)</li>
<li><code>request_id</code> (√∫nico por requisi√ß√£o)</li>
<li><code>timestamp</code> (muda a cada scrape)</li>
<li><code>ip_address</code> (muito vari√°vel)</li>
<li><code>full_url</code> (em vez de usar <code>endpoint</code> ou <code>path</code>)</li>
</ul>
<p><strong>Solu√ß√µes pr√°ticas:</strong></p>
<ul>
<li><strong>Agrega√ß√£o pr√©via:</strong> Agregue m√©tricas antes de exp√¥-las ao Prometheus</li>
<li><strong>Labels limitados:</strong> Use apenas labels com valores limitados e previs√≠veis</li>
<li><strong>M√©tricas de resumo:</strong> Em vez de m√©tricas por item individual, use m√©tricas de contagem/total</li>
<li><strong>Filtros inteligentes:</strong> Use relabeling para remover labels problem√°ticos</li>
<li><strong>Monitoramento ativo:</strong> Monitore <code>prometheus_tsdb_head_series</code> para detectar crescimento anormal</li>
</ul>
<p><strong>Regra de ouro:</strong> Se voc√™ n√£o consegue prever quantos valores diferentes um label pode ter, provavelmente n√£o deveria us√°-lo no Prometheus.</p>
<ul>
<li><strong>M√©tricas altas vs baixas cardinalidades:</strong> Prefira m√©tricas mais agregadas. Por exemplo, em vez de registrar uma m√©trica separada para cada item em fila (que n√£o faz sentido), registre o tamanho da fila como um gauge. Em vez de m√©tricas por sess√£o de usu√°rio, exponha total global ou por categoria de usu√°rio. Enfim, modele os dados de forma a minimizar detalhes desnecess√°rios.</li>
</ul>
<h3 id="consultas-promql-eficientes">Consultas (PromQL) Eficientes</h3>
<ul>
<li>
<p><strong>Cuidado com fun√ß√µes custosas:</strong> Algumas fun√ß√µes PromQL podem ser muito √∫teis, por√©m custosas. <code>topk()</code> e <code>bottomk()</code>, por exemplo, obrigam o engine a ordenar muitas s√©ries para achar o top N ‚Äì pode ser caro se aplicado numa m√©trica com milhares de s√©ries. Use-as com modera√ß√£o (talvez em queries de background para dashboard, mas evite em alertas cr√≠ticos se poss√≠vel). Similar para agrega√ß√µes sem restri√ß√£o: <code>sum by (label)</code> onde label tem muitos valores, o Prometheus ter√° que materializar todas combina√ß√µes.</p>
</li>
<li>
<p><strong>Use intervalos de tempo adequados:</strong> Querys do tipo <em>[5m]</em>, <em>[1h]</em> etc. definem quanto tempo de dados v√£o considerar. Evite pedir mais do que precisa. Por exemplo, se um alerta precisa saber a taxa nos √∫ltimos 5 minutos, n√£o use 1h. Intervalos maiores = mais dados lidos e processados. Num gr√°fico, tamb√©m n√£o exagere no zoom out se n√£o for necess√°rio ‚Äì muitos dados tornam a renderiza√ß√£o e transmiss√£o pesadas.</p>
</li>
<li>
<p><strong>Prefira <code>rate()</code> ou <code>increase()</code> para contadores ao inv√©s de <code>irate()</code> para alertas cont√≠nuos:</strong> A fun√ß√£o <code>irate()</code> calcula instantaneamente a derivada entre os dois √∫ltimos pontos ‚Äì isso √© √∫til √†s vezes, mas tende a ser muito &ldquo;barulhento&rdquo; (varia√ß√£o instante a instante). Em dashboards e alertas gerais, <code>rate()</code> numa janela de pelo menos 1m ou 5m √© mais est√°vel e representativo da taxa m√©dia. Use <code>irate</code> somente quando quer realmente capturar spikes moment√¢neos e tem alta frequ√™ncia de scrape.</p>
</li>
<li>
<p><strong>Agregue no scraping quando poss√≠vel:</strong> Se voc√™ j√° sabe que nunca vai olhar cada inst√¢ncia individual de certa m√©trica, poderia agreg√°-la antes mesmo de enviar. Exemplo: se voc√™ tem 10 threads fazendo trabalho id√™ntico e s√≥ quer saber o total combinado, exponha uma √∫nica m√©trica total e n√£o 10 separadas. Claro que isso depende do caso de uso ‚Äì muitas vezes queremos o detalhe ‚Äì mas √© algo a pensar.</p>
</li>
<li>
<p><strong>Limite consultas no UI:</strong> O Prometheus permite rodar qualquer PromQL ad-hoc no UI ou via API. Em ambientes compartilhados, controle o acesso ou conscientize os usu√°rios para n√£o rodarem consultas insanas (tipo um sum sem nenhum label em milh√µes de s√©ries por 365d) que possam afetar a performance. Voc√™ pode habilitar autentica√ß√£o/TLS e at√© colocar um proxy com quotas se for necess√°rio proteger a API de uso indevido.</p>
</li>
</ul>
<h3 id="arquitetura-e-escalabilidade">Arquitetura e Escalabilidade</h3>
<ul>
<li>
<p><strong>Sharding (divis√£o de carga):</strong> Se chegar ao ponto de um √∫nico Prometheus n√£o dar conta (seja por limite de CPU/RAM ou por quest√µes organizacionais), considere dividir os alvos entre m√∫ltiplas inst√¢ncias. Por exemplo, rodar um Prometheus por cluster Kubernetes, ou por ambiente (dev/prod), ou por regi√£o geogr√°fica. Cada um monitora s√≥ seu √¢mbito. Voc√™ pode replicar as regras de alertas em todos (assim cada local alerta independentemente). Para m√©tricas globais, use federa√ß√£o ou uma camada agregadora (como Thanos) para unificar se necess√°rio.</p>
</li>
<li>
<p><strong>Alta disponibilidade:</strong> O Prometheus em si n√£o √© HA ‚Äì ele √© stand-alone. Se cair, fica um buraco de coleta enquanto estiver fora. Uma pr√°tica comum em produ√ß√£o √© rodar <strong>dois Prometheus em paralelo coletando os mesmos alvos</strong> (nas mesmas configura√ß√µes) ‚Äì assim, se um falhar, o outro continua e nenhuma m√©trica se perde. O Alertmanager pode receber alertas duplicados de ambos, mas ele deduplica automaticamente (precisa configurar ambos Prometheus com o mesmo external_label cluster). Essa abordagem gasta mais recursos (coleta em dobro), mas √© simples e efetiva para HA de alertas.</p>
</li>
<li>
<p><strong>Longo prazo e agrega√ß√£o global:</strong> Conforme citado, se precisar <em>escalar horizontalmente</em> de verdade ou guardar m√©tricas por longos per√≠odos, vale integrar solu√ß√µes como <strong>Thanos, Cortex ou Grafana Mimir</strong>. Essas ferramentas armazenam dados em base de dados distribu√≠da (por exemplo, S3 ou BigTable no caso do Thanos/Cortex) e permitem rodar consultas PromQL que abrangem m√∫ltiplos Prometheus &ldquo;como se fosse um s√≥&rdquo;.</p>
</li>
</ul>
<blockquote>
<p>O Thanos, por exemplo, atua como um <em>sidecar</em> pegando os dados de cada Prometheus e enviando para o objeto storage, depois uma camada de <em>querier</em> unifica as consultas. O Grafana Mimir segue arquitetura semelhante, nascida da experi√™ncia do Cortex, permitindo <strong>escala praticamente ilimitada (bilh√µes de s√©ries) e alta disponibilidade</strong>, com compatibilidade total com PromQL e remote write. Claro, adicionam complexidade ‚Äì mas s√£o solu√ß√µes maduras mantidas pela CNCF/Grafana Labs.</p></blockquote>
<ul>
<li><strong>Federa√ß√£o bem aplicada:</strong> Caso use federa√ß√£o, siga a orienta√ß√£o de federar apenas m√©tricas j√° agregadas e necess√°rias globalmente. Por exemplo, federar s√≥ m√©tricas come√ßando com <code>job:</code> (indicando que s√£o resultados de recording rules j√° agregadas). N√£o federar todas as m√©tricas crus. E realize alertas localmente, deixando o global s√≥ para visualiza√ß√£o.</li>
</ul>
<h3 id="seguran√ßa">Seguran√ßa</h3>
<ul>
<li>
<p><strong>N√£o exponha sem prote√ß√£o em redes inseguras:</strong> O Prometheus, por padr√£o, n√£o tem autentica√ß√£o nem TLS habilitados. Se voc√™ for disponibilizar a interface ou API em rede p√∫blica ou multi-tenant, coloque-o atr√°s de um proxy reverso que implemente TLS e autentica√ß√£o (b√°sica, OAuth, o que for). Alternativamente, rode em rede interna/VPN somente. H√° flags experimentais para TLS direto e auth no Prometheus, mas a abordagem recomendada ainda √© usar um proxy (por exemplo, Nginx, Traefik, etc).</p>
</li>
<li>
<p><strong>Controle acesso √† API:</strong> Considere habilitar autoriza√ß√£o se for um ambiente com v√°rios usu√°rios ou multi-time. Infelizmente, o Prometheus n√£o suporta m√∫ltiplos n√≠veis de usu√°rio nativamente. A solu√ß√£o costuma ser segregar inst√¢ncias ou novamente um proxy que filtre rotas. Por exemplo, impedir acesso direto ao <code>/api/v1/admin</code> (que possui comandos de dele√ß√£o de dados).</p>
</li>
<li>
<p><strong>Atualiza√ß√µes e patches:</strong> Mantenha o Prometheus atualizado ‚Äì a cada vers√£o h√° otimiza√ß√µes e corre√ß√µes, inclusive de seguran√ßa. E.g., compress√£o de WAL veio ativada por padr√£o na 2.20, reduzindo disco pela metade. Vers√µes mais novas introduziram <em>native histograms</em> (experimental) e melhorias de desempenho. Ent√£o acompanhe o changelog oficial e planeje upgrade regularmente (Prometheus √© bem compat√≠vel retroativamente em dados e configs, upgrades diretos costumam ser tranquilos).</p>
</li>
<li>
<p><strong>Isolamento de rede para exporters:</strong> Exporters muitas vezes exp√µem m√©tricas sens√≠veis (por exemplo, o Node Exporter exp√µe informa√ß√µes de hardware, usu√°rios logados etc.). √â boa pr√°tica deixar esses endpoints acess√≠veis s√≥ pelo Prometheus, n√£o abertos ao mundo. Use firewalls/regras de seguran√ßa nos hosts ou config de container network para limitar.</p>
</li>
<li>
<p><strong>Naming anti-collision:</strong> Se voc√™ usa r√≥tulos <em>externos</em> (external_labels) para identificar inst√¢ncias em um contexto federado ou HA, garanta que cada Prometheus tenha um label √∫nico (e.g., <code>cluster=&quot;eu-west-1&quot;</code>). Isso evita confus√£o de m√©tricas vindas de origens diferentes no caso de jun√ß√£o (Thanos, federa√ß√£o) e ajuda a filtrar.</p>
</li>
</ul>
<h3 id="backup-recovery-e-upgrade">Backup, Recovery e Upgrade</h3>
<p>Em ambientes de produ√ß√£o, √© fundamental ter estrat√©gias robustas para backup, recupera√ß√£o de falhas e upgrades do Prometheus. Esses aspectos s√£o frequentemente negligenciados, mas s√£o cr√≠ticos para manter a continuidade do monitoramento.</p>
<h4 id="backup-de-dados">Backup de Dados</h4>
<p>O Prometheus armazena dados no diret√≥rio <code>data/</code> que cont√©m os blocos de s√©ries temporais. Para fazer backup consistente:</p>
<p><strong>Backup a quente (recomendado):</strong></p>


  <pre><code class="language-bash"># Parar o Prometheus para garantir consist√™ncia
sudo systemctl stop prometheus

# Fazer backup do diret√≥rio data
tar -czf prometheus-backup-$(date &#43;%Y%m%d).tar.gz /opt/prometheus/data/

# Reiniciar o Prometheus
sudo systemctl start prometheus</code></pre>
 <p><strong>Backup a frio (alternativa):</strong></p>


  <pre><code class="language-bash"># Usar promtool para verificar integridade antes do backup
promtool tsdb check /opt/prometheus/data/

# Fazer backup apenas dos blocos fechados (mais seguro)
find /opt/prometheus/data/ -name &#34;*.json&#34; -exec tar -czf prometheus-blocks-$(date &#43;%Y%m%d).tar.gz {} \;</code></pre>
 <p><strong>Backup de configura√ß√£o:</strong></p>


  <pre><code class="language-bash"># Backup dos arquivos de configura√ß√£o
cp /etc/prometheus/prometheus.yml /backup/prometheus.yml.$(date &#43;%Y%m%d)
cp /etc/prometheus/alert.rules.yml /backup/alert.rules.yml.$(date &#43;%Y%m%d)</code></pre>
 <h4 id="recupera√ß√£o-de-falhas">Recupera√ß√£o de Falhas</h4>
<p><strong>Restaura√ß√£o de dados:</strong></p>


  <pre><code class="language-bash"># Parar o Prometheus
sudo systemctl stop prometheus

# Restaurar backup
tar -xzf prometheus-backup-20231201.tar.gz -C /

# Verificar integridade dos dados
promtool tsdb check /opt/prometheus/data/

# Reiniciar
sudo systemctl start prometheus</code></pre>
 <p><strong>Recupera√ß√£o de WAL corrompido:</strong></p>


  <pre><code class="language-bash"># Se o WAL estiver corrompido, pode ser necess√°rio recriar
rm -rf /opt/prometheus/data/wal/
rm -rf /opt/prometheus/data/chunks_head/

# Reiniciar - o Prometheus recriar√° o WAL
sudo systemctl start prometheus</code></pre>
 <h4 id="estrat√©gias-de-upgrade">Estrat√©gias de Upgrade</h4>
<p><strong>Upgrade direto (mais comum):</strong></p>


  <pre><code class="language-bash"># Fazer backup antes do upgrade
sudo systemctl stop prometheus
tar -czf prometheus-backup-pre-upgrade.tar.gz /opt/prometheus/data/

# Baixar nova vers√£o
wget https://github.com/prometheus/prometheus/releases/download/v2.45.0/prometheus-2.45.0.linux-amd64.tar.gz
tar -xzf prometheus-2.45.0.linux-amd64.tar.gz

# Substituir bin√°rio
cp prometheus-2.45.0.linux-amd64/prometheus /opt/prometheus/
cp prometheus-2.45.0.linux-amd64/promtool /opt/prometheus/

# Verificar configura√ß√£o
/opt/prometheus/promtool check config /etc/prometheus/prometheus.yml

# Reiniciar
sudo systemctl start prometheus</code></pre>
 <p><strong>Upgrade com rollback:</strong></p>


  <pre><code class="language-bash"># Manter vers√£o anterior
cp /opt/prometheus/prometheus /opt/prometheus/prometheus.backup

# Fazer upgrade
# ... (mesmo processo acima)

# Se houver problemas, rollback
sudo systemctl stop prometheus
cp /opt/prometheus/prometheus.backup /opt/prometheus/prometheus
sudo systemctl start prometheus</code></pre>
 <h4 id="considera√ß√µes-importantes">Considera√ß√µes Importantes</h4>
<p><strong>Compatibilidade de dados:</strong></p>
<ul>
<li>O Prometheus mant√©m compatibilidade retroativa de dados entre vers√µes menores</li>
<li>Upgrades major (ex: 2.x para 3.x) podem requerer migra√ß√£o de dados</li>
<li>Sempre verifique o changelog oficial antes de upgrades</li>
</ul>
<p><strong>Tempo de recupera√ß√£o:</strong></p>
<ul>
<li>O Prometheus pode demorar para processar o WAL ap√≥s reinicializa√ß√£o</li>
<li>Em ambientes com muitas s√©ries, a recupera√ß√£o pode levar minutos</li>
<li>Monitore <code>prometheus_tsdb_wal_replay_duration_seconds</code> durante recupera√ß√£o</li>
</ul>
<p><strong>Backup automatizado:</strong></p>


  <pre><code class="language-bash">#!/bin/bash
# Script de backup automatizado
DATE=$(date &#43;%Y%m%d_%H%M%S)
BACKUP_DIR=&#34;/backup/prometheus&#34;

# Criar backup
sudo systemctl stop prometheus
tar -czf $BACKUP_DIR/prometheus-$DATE.tar.gz /opt/prometheus/data/
sudo systemctl start prometheus

# Manter apenas √∫ltimos 7 backups
find $BACKUP_DIR -name &#34;prometheus-*.tar.gz&#34; -mtime &#43;7 -delete</code></pre>
 <p><strong>Monitoramento de integridade:</strong></p>


  <pre><code class="language-yaml"># Alertas para problemas de backup/recupera√ß√£o
groups:
- name: prometheus_backup
  rules:
    - alert: PrometheusBackupFailed
      expr: time() - prometheus_build_info &gt; 86400  # Mais de 1 dia sem restart
      for: 1h
      labels:
        severity: warning
      annotations:
        summary: &#34;Prometheus n√£o foi reiniciado recentemente (poss√≠vel problema de backup)&#34;</code></pre>
 <blockquote>
<p><strong>Importante</strong>: Sempre teste backups e procedimentos de recupera√ß√£o em ambiente de desenvolvimento antes de aplicar em produ√ß√£o. A integridade dos dados de monitoramento √© t√£o cr√≠tica quanto os dados da aplica√ß√£o.</p></blockquote>
<p>Seguindo essas pr√°ticas, voc√™ dever√° manter seu ambiente Prometheus funcionando de forma mais suave, evitando as armadilhas comuns de desempenho e garantindo que as m√©tricas coletadas realmente agreguem valor (e alertas disparem quando devem, sem falso positivos ou negativos).</p>
<h2 id="opera√ß√£o-e-manuten√ß√£o">Opera√ß√£o e Manuten√ß√£o</h2>
<h3 id="promtool">Promtool</h3>
<p>O <strong>promtool</strong> √© uma ferramenta de linha de comando que acompanha o Prometheus, fornecendo utilit√°rios para verificar configura√ß√µes e depurar dados. Algumas utiliza√ß√µes comuns do promtool:</p>
<ul>
<li><strong>Checar sintaxe de configura√ß√£o:</strong> Antes de subir uma altera√ß√£o no <code>prometheus.yml</code>, rode <code>promtool check config prometheus.yml</code>. Ele apontar√° erros de sintaxe ou campos desconhecidos, ajudando a evitar falhas no start do servidor.</li>
<li><strong>Validar regras de alerta ou grava√ß√£o:</strong> Se voc√™ definiu arquivos externos de regras (YAML de alertas ou recording rules), use <code>promtool check rules minhas_regras.yml</code>. Ele analisar√° as express√µes PromQL e a formata√ß√£o.</li>
<li><strong>Testar express√£o de alerta:</strong> O promtool permite avaliar manualmente express√µes em um dado instant√¢neo ou s√©rie de tempo para ver se disparariam alerta. √ötil em CI ou para garantir que a l√≥gica est√° correta.</li>
<li><strong>Checar integridade do TSDB:</strong> Com o comando <code>promtool tsdb check /path/para/dados</code> √© poss√≠vel inspecionar o banco local de s√©ries temporais em busca de inconsist√™ncias ou corrup√ß√£o.</li>
<li><strong>Converter formatos de dados de m√©trica:</strong> H√° como transformar arquivos de m√©tricas entre formatos (por exemplo, de texto para JSON e vice-versa) usando <code>promtool convert metrics --from=txt --to=json arquivo.txt</code>.</li>
</ul>
<p>Essas s√£o apenas algumas fun√ß√µes. Em suma, o promtool √© seu amigo para garantir que o ambiente Prometheus est√° consistente e saud√°vel ‚Äì use-o sempre que fizer mudan√ßas significativas na configura√ß√£o.</p>
<h2 id="conclus√£o">Conclus√£o</h2>
<p>Neste artigo, exploramos em detalhes o Prometheus ‚Äì desde conceitos fundamentais at√© seu funcionamento interno e implica√ß√µes pr√°ticas de opera√ß√£o. Vimos como ele implementa um banco de dados de s√©ries temporais altamente eficiente, mantendo dados recentes em mem√≥ria para rapidez e usando compress√£o e segmenta√ß√£o em blocos para hist√≥rico em disco.</p>
<p>Tamb√©m analisamos aspectos como modelo de coleta pull, linguagem de consulta poderosa, uso intensivo de recursos proporcionais ao volume de m√©tricas, e formas de contornar limita√ß√µes (sejam arquiteturais ou de escala) com boas pr√°ticas e ferramentas auxiliares.</p>
<p>Esses pontos mostram como o Prometheus alia efici√™ncia t√©cnica a flexibilidade operacional, permitindo que equipes monitorem ambientes complexos e em constante evolu√ß√£o, ao mesmo tempo em que enfrentam desafios de escala e desempenho com solu√ß√µes pr√°ticas e acess√≠veis.</p>
<p>O Prometheus se destaca no ecossistema de monitoramento por sua simplicidade de implanta√ß√£o e por ter sido projetado desde o in√≠cio para ambientes de microsservi√ßos e infraestrutura din√¢mica. Seu modelo multidimensional de m√©tricas com labels e o PromQL possibilitam an√°lises ricas e alertas robustos com relativamente pouco esfor√ßo de configura√ß√£o.</p>
<p>√â not√°vel como em poucos anos ele se tornou um dos pilares da observabilidade moderna, ao lado de ferramentas complementares para logs (ELK stack) e <em>tracing</em> (Jaeger, etc.).</p>
<p>Por outro lado, entendemos que o Prometheus n√£o resolve tudo sozinho: reten√ß√£o de longo prazo, alta disponibilidade nativa e escalabilidade horizontal s√£o pontos fora do escopo do core do Prometheus.</p>
<p>Em vez de tentar ser distribu√≠do, o projeto optou por interfaces (remote write/read) e pela filosofia de componibilidade ‚Äì cabendo a outras pe√ßas (como Thanos ou Mimir) suprir essas demandas quando necess√°rias.</p>
<p>Essa decis√£o de design mant√©m o Prometheus &ldquo;enxuto&rdquo; e confi√°vel, mas significa que para crescer al√©m de certo limite, precisamos arquitetar bem a solu√ß√£o de monitoramento abrangendo outros componentes.</p>
<p>Recapitulando alguns aprendizados chave:</p>
<ul>
<li>Organize bem suas m√©tricas e labels para evitar sobrecarga de cardinalidade.</li>
<li>Monitore o pr√≥prio Prometheus e ajuste a capacidade conforme crescimento.</li>
<li>Use Alertmanager e outras integra√ß√µes para ter um uso completo (coleta, armazenamento, alerta, visualiza√ß√£o).</li>
<li>Em caso de grandes escalas, parta para sharding ou ferramentas de escala distribu√≠da ‚Äì n√£o force um Prometheus √∫nico a fazer trabalho demais.</li>
<li>Leve em conta seguran√ßa e isolamento, pois monitoramento tamb√©m lida com informa√ß√µes sens√≠veis do ambiente.</li>
</ul>
<p>Esperamos que este guia tenha fornecido insights valiosos, tanto para iniciantes entenderem os conceitos do Prometheus quanto para usu√°rios experientes refinarem sua utiliza√ß√£o. Compreender o &ldquo;under the hood&rdquo; do Prometheus ajuda a antecipar comportamentos, otimizar configura√ß√µes e evitar armadilhas comuns na opera√ß√£o di√°ria.</p>
<p>O Prometheus continua em r√°pida evolu√ß√£o (com melhorias na TSDB, novos recursos como Exemplos Exemplares e Native Histograms em teste, etc.), e o ecossistema ao seu redor tamb√©m. Fique atento a atualiza√ß√µes e boas pr√°ticas emergentes ‚Äì a comunidade CNCF e blogs como o <em>Robust Perception</em> regularmente publicam conte√∫dos de alto n√≠vel a respeito.</p>
<p>No mais, boas m√©tricas e bons alertas!</p>
<hr>
<h2 id="refer√™ncias">Refer√™ncias</h2>
<ul>
<li><strong>Documenta√ß√£o Oficial do Prometheus</strong> ‚Äì especialmente a <a href="https://prometheus.io/docs/introduction/overview/">Overview</a> , <a href="https://prometheus.io/docs/concepts/metric_types/">Metric Types</a> , <a href="https://prometheus.io/docs/practices/naming/">Best Practices</a> e se√ß√£o de <a href="https://prometheus.io/docs/prometheus/latest/storage/">Storage</a> .</li>
<li><strong>Blog Robust Perception (Brian Brazil)</strong> ‚Äì v√°rias postagens aprofundadas, por exemplo: <a href="https://www.robustperception.io/federation-what-is-it-good-for/">&ldquo;Federation, what is it good for?&rdquo;</a> , <a href="https://www.robustperception.io/how-much-ram-does-prometheus-2-x-need-for-cardinality-and-ingestion/">&ldquo;How much RAM does Prometheus 2.x need&hellip;&rdquo;</a> , <a href="https://www.robustperception.io/using-json-file-service-discovery-with-prometheus">&ldquo;Using JSON file service discovery&rdquo;</a> .</li>
<li><strong>Ganesh Vernekar ‚Äì S√©rie de artigos &ldquo;Prometheus TSDB&rdquo;</strong> ‚Äì <em>Parts 1-7</em> no blog do Ganesh (engenheiro Grafana Labs) detalhando a fundo a arquitetura do TSDB. Em especial, <a href="https://ganeshvernekar.com/blog/prometheus-tsdb-persistent-block-and-its-index/">Parte 4: Blocos persistentes e √çndice</a> .</li>
<li><strong>Livro &ldquo;Prometheus Up &amp; Running&rdquo; (O&rsquo;Reilly, 2019)</strong> ‚Äì de Brian Brazil, √≥tima introdu√ß√£o abrangendo do b√°sico a casos avan√ßados.</li>
<li><strong>Livro &ldquo;The Prometheus Book&rdquo; de James Turnbull</strong> ‚Äì guia pr√°tico cobrindo instala√ß√£o, instrumenta√ß√£o e alertas (dispon√≠vel online).</li>
<li><strong>Hands-On Infrastructure Monitoring with Prometheus</strong> (Packt) ‚Äì livro focado em exemplos pr√°ticos de uso do Prometheus em cen√°rios reais.</li>
<li><strong>Monitoring Microservices and Containerized Applications</strong> (Apress) ‚Äì aborda Prometheus em contexto de microsservi√ßos/Kubernetes.</li>
<li><strong>Comparativos Prometheus vs. outras ferramentas:</strong> Artigos como <em>&ldquo;Prometheus vs. ELK&rdquo;</em>, <em>&ldquo;Prometheus vs. Grafana Mimir (Cortex)&rdquo;</em>, e posts do blog da BetterStack sobre melhores pr√°ticas.</li>
<li><strong>Grafana Mimir</strong> ‚Äì <a href="https://grafana.com/oss/mimir/">P√°gina oficial</a>  e an√∫ncio do lan√ßamento em 2022, mostrando como escalar Prometheus para 1 bilh√£o de s√©ries.</li>
<li><strong>Datadog e New Relic</strong> ‚Äì documenta√ß√µes e sites oficiais para entender ofertas de monitoramento propriet√°rias integradas (APM, Logs, etc.), √∫til para ver diferen√ßas de escopo.</li>
<li><strong>Nagios/Core e Zabbix</strong> ‚Äì documenta√ß√£o e comunidade, para contexto hist√≥rico de monitoramento (foco em disponibilidade, sem TSDB nativo).</li>
<li><strong>ELK Stack</strong> ‚Äì docs Elastic e blogs de terceiros comparando com Prometheus (focando que ELK √© logs e Prometheus m√©tricas).</li>
<li><strong>CNCF Observability Landscape</strong> ‚Äì projetos e ferramentas relacionadas, para quem quiser explorar al√©m (OpenTelemetry, Fluentd, etc.).</li>
</ul>

    </div>
    
    
    



    
    
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
    
        
            
            
            
            
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            
            
            
        
    
        
            
            
            
            
            
            
        
    
        
            
            
            
            
            
            
        
    
    
    

    
    
    
    
<div class="comments-section">
    <h3 class="comments-title">üí¨ Coment√°rios</h3>
    <div class="comments-container">
        <script src="https://giscus.app/client.js"
                data-repo="scovl/scovl.github.io"
                data-repo-id="MDEwOlJlcG9zaXRvcnkxMzg1OTI2ODA="
                data-category="General"
                data-category-id="DIC_kwDOCELBqM4CthUV"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="pt"
                crossorigin="anonymous"
                async>
        </script>
    </div>
</div>

    
</article>

        </div>
    </main>
    
    
    
    <footer class="footer">
    <div class="container">
        <div class="footer-content">
            <div class="footer-links">
                
                <a href="https://github.com/scovl" target="_blank" rel="noopener noreferrer" class="footer-link">
                    GitHub
                </a>
                
                
                
                <a href="https://linkedin.com/in/vitor-lobo" target="_blank" rel="noopener noreferrer" class="footer-link">
                    LinkedIn
                </a>
                
                
                
                <a href="mailto:lobocode@gmail.com" class="footer-link">
                    Email
                </a>
                

                
                <a href="https://hachyderm.io/@lobocode" target="_blank" rel="noopener noreferrer" class="footer-link">
                    Mastodon
                </a>
                

                
                <a href="https://scovl.github.io/index.xml" target="_blank" rel="noopener noreferrer" class="footer-link">
                    RSS
                </a>
                
            </div>
            
            
            <div class="back-to-top-container">
                <button id="back-to-top" class="back-to-top-btn" aria-label="Voltar ao topo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m18 15-6-6-6 6"/>
                    </svg>
                    <span data-i18n="back_to_top">Voltar ao topo</span>
                </button>
            </div>
            
            <div class="copyright">
                &copy; 2025 scovl
            </div>
        </div>
    </div>
</footer> 
    
    
    
    <script src="/vendor/prism/prism-core.min.js?v=1757088371"></script>
    <script src="/vendor/prism/prism-clike.min.js?v=1757088371"></script>
    <script src="/vendor/prism/prism-c.min.js?v=1757088371"></script>
    <script src="/vendor/prism/prism-cpp.min.js?v=1757088371"></script>
    <script src="/vendor/prism/prism-rust.min.js?v=1757088371"></script>
    <script src="/vendor/prism/prism-clojure.min.js?v=1757088371"></script>
    <script src="/vendor/prism/prism-swift.min.js?v=1757088371"></script>
    <script src="/vendor/prism/prism-bash.min.js?v=1757088371"></script>
    <script src="/vendor/prism/prism-autoloader.min.js?v=1757088371"></script>
    
    
    <script src="/js/main-minimal.js?v=1757088371"></script>
    <script src="/js/lazy-loading.js?v=1757088371"></script>
    <script src="/js/toc.js?v=1757088371"></script>
    
    
    
</body>
</html> 