<!DOCTYPE html>
<html lang="pt">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>Prometheus | scovl</title>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Under the hood">


<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        mermaid.initialize({
            startOnLoad: true,
            theme: 'light',
            align: 'center'
        });
    });
</script>
 
</head>
<body>
    
    
    <header class="header">
    <div class="container">
        <div class="header-content">
            <a href="http://localhost:1313/" class="site-title">scovl</a>
            
            <nav>
                <ul class="nav-menu">
                    
                    
                    <li>
                        <a href="/page/about/" class="nav-link ">
                            About
                        </a>
                    </li>
                    
                    <li>
                        <a href="/page/contact/" class="nav-link ">
                            Contact
                        </a>
                    </li>
                    
                </ul>
            </nav>
        </div>
    </div>
</header> 
    
    
    
    <main>
        <div class="container">
            
<article class="post">
    <header class="post-header">
        <h1 class="post-title">Prometheus</h1>
        <div class="post-meta">
            
            <time datetime="2023-03-21T23:18:18-03:00">
                Tue, Mar 21, 2023
            </time>
            
            
            
            
            
            <div class="post-tags">
                
                <a href="/tags/prometheus/" class="tag">Prometheus</a>
                
                <a href="/tags/grafana/" class="tag">Grafana</a>
                
                <a href="/tags/monitoring/" class="tag">Monitoring</a>
                
                <a href="/tags/tsdb/" class="tag">TSDB</a>
                
                <a href="/tags/devops/" class="tag">DevOps</a>
                
                <a href="/tags/observability/" class="tag">Observability</a>
                
            </div>
            
            
            
            <div class="reading-time">
                Estimated reading time: 29 min
            </div>
            
            
            
            <div class="post-description">
                Under the hood
            </div>
            
        </div>
    </header>
    
    <div class="post-content">
        <h2 id="índice">Índice</h2>
<ul>
<li><strong><a href="/2023/03/21/prometheus/#introdu%c3%a7%c3%a3o">Introdução</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#instala%c3%a7%c3%a3o">Instalação</a></strong>
<ul>
<li><strong><a href="/2023/03/21/prometheus/#modo-agent-v233">Modo Agent (v2.33+)</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#instala%c3%a7%c3%a3o-padr%c3%a3o">Instalação Padrão</a></strong></li>
</ul>
</li>
<li><strong><a href="/2023/03/21/prometheus/#promtool">Promtool</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#instrumenta%c3%a7%c3%a3o">Instrumentação</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#alertmanager">Alertmanager</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#pushgateway">PushGateway</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#federa%c3%a7%c3%a3o">Federação</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#under-the-hood">Under the Hood</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#promql">PromQL</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#recursos-modernos-do-prometheus">Recursos Modernos do Prometheus</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#melhores-pr%c3%a1ticas">Melhores Práticas</a></strong></li>
<li><strong><a href="/2023/03/21/prometheus/#conclus%c3%a3o">Conclusão</a></strong></li>
</ul>
<h2 id="introdução">Introdução</h2>
<h3 id="prometheus">Prometheus</h3>
<p>O <a href="https://prometheus.io/">Prometheus</a> é uma ferramenta de monitoramento de sistemas e aplicativos open source que revolucionou a forma como pensamos sobre observabilidade em ambientes distribuídos. Desenvolvido para fornecer uma abordagem eficiente de coletar, armazenar e analisar métricas de desempenho, o Prometheus se destaca por sua arquitetura simples mas poderosa, alta escalabilidade e modelo de dados dimensional.</p>
<p>O Prometheus foi projetado desde o início para trabalhar perfeitamente em ambientes containerizados como <a href="https://kubernetes.io/">Kubernetes</a> e <a href="https://www.docker.com/">Docker</a>, tornando-o uma escolha natural para monitoramento nativo da nuvem. Frequentemente é utilizado em conjunto com <a href="https://grafana.com/">Grafana</a> para visualizações avançadas, criando um poderoso ecossistema de observabilidade.</p>
<p>A ferramenta foi criada em 2012 por uma equipe liderada por Julius Volz na SoundCloud, quando a empresa precisava de uma solução de monitoramento mais robusta. Em 2016, o projeto foi transferido para a <strong><a href="https://www.cncf.io/">Cloud Native Computing Foundation (CNCF)</a></strong>, iniciando seu período de incubação. Em 9 de agosto de 2018, o Prometheus se tornou o segundo projeto a atingir o status de &ldquo;graduado&rdquo; na CNCF, demonstrando sua maturidade, adoção pela comunidade e estabilidade como projeto open source.</p>
<blockquote>
<p><strong>NOTA</strong>: Para um mergulho profundo na linguagem de consulta PromQL, veja nossa seção dedicada <strong><a href="/2023/03/21/prometheus/#promql">abaixo</a></strong>.</p></blockquote>
<h3 id="tipos-de-métricas">Tipos de métricas</h3>
<p>O Prometheus suporta quatro tipos principais de métricas: <strong>Counter</strong>, <strong>Gauge</strong>, <strong>Histogram</strong> e <strong>Summary</strong>. Para detalhes completos sobre cada tipo, consulte a <a href="https://prometheus.io/docs/concepts/metric_types/">documentação oficial de métricas</a>.</p>
<h3 id="monitoramento-pull-vs-push">Monitoramento pull vs push</h3>
<p>O Prometheus utiliza um modelo <strong>pull-based</strong>, onde ele periodicamente solicita dados dos targets configurados. Para detalhes sobre o modelo de coleta, consulte a <a href="https://prometheus.io/docs/introduction/overview/#architecture">documentação oficial</a>.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/main/post/images/tsdb/prom-pullvspush.png" alt="img"></p>
<h3 id="arquitetura-do-prometheus">Arquitetura do Prometheus</h3>
<p>O Prometheus é composto por um servidor principal que coleta e armazena métricas, bibliotecas cliente para instrumentação, PushGateway para jobs de curta duração, exportadores para sistemas externos e Alertmanager para gerenciamento de alertas.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/refs/heads/main/blog/content/post/images/tsdb/arch.png" alt="img"></p>
<p>Para detalhes completos sobre a arquitetura, consulte a <a href="https://prometheus.io/docs/introduction/overview/#architecture">documentação oficial</a>.</p>
<h3 id="labels-e-samples">Labels e Samples</h3>
<p>Labels são pares chave-valor que identificam e categorizam métricas. Para convenções de nomenclatura e detalhes sobre labels internas, consulte a <a href="https://prometheus.io/docs/concepts/data_model/">documentação oficial</a>.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/master/post/images/tsdb/samples01.png" alt="img"></p>
<h2 id="instalação">Instalação</h2>
<p>Existem inúmeras maneiras de instalar o <a href="https://prometheus.io/">Prometheus</a>, mas aqui vamos mostrar como instalar o Prometheus usando o <a href="https://www.docker.com/">Docker</a> e o <a href="https://docs.docker.com/compose/">Docker Compose</a>, <a href="https://grafana.com/">Grafana</a> e o <a href="https://github.com/dmitsh/promsim">PromSim</a> um simulador de métricas para testar o Prometheus e Grafana.</p>
<h3 id="modo-agent-v233">Modo Agent (v2.33+)</h3>
<p>O Prometheus oferece um modo especial chamado &ldquo;Agent&rdquo; que é otimizado para deployments write-only, reduzindo drasticamente o uso de disco e CPU. O modo Agent é ideal quando você usa remote write para enviar dados para sistemas externos como Thanos, Cortex ou VictoriaMetrics.</p>
<h4 id="características-do-modo-agent">Características do modo Agent:</h4>
<ul>
<li><strong>Sem armazenamento local</strong>: Não armazena dados no TSDB local</li>
<li><strong>Baixo uso de recursos</strong>: Consome significativamente menos CPU e disco</li>
<li><strong>Remote write otimizado</strong>: Focado em coletar e enviar dados</li>
<li><strong>Sem consultas locais</strong>: Não suporta consultas PromQL locais</li>
<li><strong>Sem alertas locais</strong>: Alertas devem ser configurados no sistema de destino</li>
</ul>
<h4 id="configuração-do-modo-agent">Configuração do modo Agent:</h4>


  <pre><code class="language-yaml"># prometheus-agent.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;node-exporter&#39;
    static_configs:
      - targets: [&#39;node-exporter:9100&#39;]

remote_write:
  - url: &#34;http://thanos-receive:10908/api/v1/receive&#34;
    remote_timeout: 30s</code></pre>
 <p>Executando em modo Agent via Docker Compose:</p>


  <pre><code class="language-bash"># Docker
docker run -p 9090:9090 \
  -v ./prometheus-agent.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus:latest \
  --enable-feature=agent

# Docker Compose
version: &#34;3&#34;
services:
  prometheus-agent:
    image: prom/prometheus:latest
    command:
      - &#39;--enable-feature=agent&#39;
      - &#39;--config.file=/etc/prometheus/prometheus.yml&#39;
    ports:
      - &#34;9090:9090&#34;
    volumes:
      - &#34;./prometheus-agent.yml:/etc/prometheus/prometheus.yml&#34;</code></pre>
 <h3 id="instalação-padrão">Instalação Padrão</h3>
<p>Crie um arquivo de configuração do Docker Compose chamado <code>docker-compose.yml</code> no mesmo diretório que o arquivo prometheus.yml. Inclua as seguintes configurações:</p>


  <pre><code class="language-yaml">version: &#34;3&#34;

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - &#34;9090:9090&#34;
    volumes:
      - &#34;./prometheus.yml:/etc/prometheus/prometheus.yml&#34;
    depends_on:
      - promsim

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - &#34;3000:3000&#34;

  promsim:
    image: sysdigtraining/promsim:latest
    container_name: promsim
    ports:
      - &#34;8080:8080&#34;</code></pre>
 <p>Em seguida, crie um arquivo de configuração do <a href="https://prometheus.io/">Prometheus</a> chamado <code>prometheus.yml</code> no mesmo diretório que o arquivo <code>docker-compose.yml</code>. Inclua as seguintes configurações:</p>


  <pre><code class="language-yaml">global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: &#34;promsim&#34;
    static_configs:
      - targets: [&#34;promsim:8080&#34;]</code></pre>
 <p>No terminal, navegue até o diretório onde você salvou o docker-compose.yml e execute o seguinte comando para iniciar os serviços:</p>


  <pre><code class="language-bash">docker-compose up -d</code></pre>
 <p>No Grafana, você precisará adicionar o Prometheus como uma fonte de dados (datasource). Faça login no Grafana (usuário padrão: admin, senha: admin), vá para &ldquo;Configuration&rdquo; (ícone de engrenagem) e clique em &ldquo;Data Sources&rdquo;. Adicione uma nova fonte de dados com o tipo Prometheus e use a URL <strong>http://prometheus:9090</strong>. Agora você pode criar painéis no Grafana usando métricas do Prometheus e do PromSim. O PromSim irá gerar métricas simuladas que você pode usar para testar o comportamento do threshold. O PromSim é um simulador de métricas que gera métricas aleatórias para testar o Prometheus. Para mais informações sobre o PromSim, consulte a documentação oficial em <strong><a href="https://github.com/dmitsh/promsim">https://github.com/dmitsh/promsim</a></strong>.</p>
<p>Se você quiser instalar somente o Prometheus, basta rodar <code>docker run -p 9090:9090 prom/prometheus</code>. Você pode acessar a interface web do Prometheus em <strong>http://localhost:9090</strong>. Para mais informações sobre como instalar o Prometheus, consulte a <a href="https://prometheus.io/docs/prometheus/latest/getting_started/">documentação oficial</a>.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/master/post/images/tsdb/ui01.png" alt="img"></p>
<p>A interface do Prometheus é composta pelos seguintes menus:</p>
<ul>
<li><strong>Alerts</strong>: este menu exibe todos os alertas ativos e permite visualizar o histórico de alertas. Os alertas são disparados quando uma determinada métrica ultrapassa um limite configurado.</li>
<li><strong>Graph</strong>: este menu permite criar e visualizar gráficos de métricas coletadas pelo Prometheus. O usuário pode definir a escala do eixo X e Y, bem como personalizar a aparência do gráfico.</li>
<li><strong>Status</strong>: este menu exibe o status atual do Prometheus, incluindo informações sobre as métricas coletadas, alertas ativos e configurações do sistema.</li>
<li><strong>Help</strong>: este menu fornece informações úteis sobre o Prometheus, incluindo documentação, exemplos de consulta e informações de contato da equipe de suporte.</li>
<li><strong>Classic UI</strong>: este menu oferece uma interface alternativa para visualização de métricas, com recursos adicionais em comparação com a interface padrão.</li>
</ul>
<p>Além disso, a interface do Prometheus contém as seguintes opções:</p>
<ul>
<li><strong>Use local time</strong>: essa opção permite que o usuário visualize as métricas em seu fuso horário local em vez do horário do servidor.</li>
<li><strong>Enable query history</strong>: essa opção permite que o usuário acesse o histórico de consultas que foram executadas anteriormente.</li>
<li><strong>Enable autocomplete</strong>: essa opção permite que o usuário obtenha sugestões de consulta enquanto digita no campo de consulta.</li>
<li><strong>Campo de consulta</strong>: este é o campo onde o usuário pode inserir consultas PromQL para recuperar métricas específicas.</li>
<li><strong>Campo Table e Graph</strong>: este campo permite que o usuário selecione entre exibir o resultado da consulta como uma tabela ou um gráfico.</li>
<li><strong>Evaluation time</strong>: este campo permite que o usuário especifique o período de tempo para o qual as métricas devem ser recuperadas pela consulta.</li>
</ul>
<h3 id="configuração">Configuração</h3>
<p>O Prometheus é configurado através de um arquivo YAML que define todos os aspectos do comportamento do sistema. A configuração é dividida em seções lógicas que controlam diferentes aspectos do funcionamento.</p>
<h4 id="estrutura-de-diretórios">Estrutura de Diretórios</h4>
<p>No geral a estrutura de diretórios do Prometheus é a seguinte:</p>


  <pre><code class="language-bash">/opt/prometheus/
├── console_libraries/
│   ├── prom.lib.js
│   ├── react-16.8.3.production.min.js
│   └── ...
├── consoles/
│   ├── index.html
│   ├── queries_range.html
│   └── ...
├── prometheus
├── prometheus.yml
├── promtool
└── ...</code></pre>
 <p>Pode variar a depender da versão, mas a estrutura acima é a mais comum. Os arquivos <code>prometheus</code> e <code>promtool</code> são os binários do Prometheus e do promtool, respectivamente. O diretório <code>console_libraries</code> contém bibliotecas JavaScript que são usadas para renderizar a interface do Prometheus. O diretório <code>consoles</code> contém arquivos HTML que são usados para renderizar a interface do Prometheus. O arquivo <code>prometheus.yml</code> é o arquivo onde são definidas as configurações de scrape (coleta) de métricas dos alvos a serem monitorados, regras de alerta, entre outras configurações. Um exemplo de arquivo prometheus.yml default pode ser algo parecido com isso:</p>


  <pre><code class="language-yaml">global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;prometheus&#39;
    static_configs:
      - targets: [&#39;localhost:9090&#39;]</code></pre>
 <p>Nesse exemplo, temos duas seções no arquivo de configuração:</p>
<ul>
<li><strong>global</strong>: define as configurações globais do Prometheus, como a frequência de coleta de métricas (scrape_interval), que neste caso é de 15 segundos.</li>
<li><strong>scrape_configs</strong>: define as configurações de coleta de métricas para os alvos a serem monitorados. Neste caso, temos apenas um job (trabalho) definido, chamado prometheus, que monitora o próprio servidor do Prometheus na porta 9090. Para adicionar um sistema genérico ao prometheus.yml, é necessário criar uma nova configuração de scrape. Por exemplo, suponha que temos um sistema com a aplicação web em execução na porta 8080. Podemos adicionar essa configuração de scrape da seguinte forma:</li>
</ul>


  <pre><code class="language-yaml">global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;prometheus&#39;
    static_configs:
      - targets: [&#39;localhost:9090&#39;]

  - job_name: &#39;my-app&#39;
    static_configs:
      - targets: [&#39;my-app:8080&#39;]</code></pre>
 <p>Neste exemplo, foi criado um novo job chamado <code>my-app</code> que monitora o sistema genérico na porta <code>8080</code>. O <code>static_configs</code> define os alvos a serem monitorados, que neste caso é o sistema <code>my-app</code> na porta <code>8080</code>. Caso você deseje adicionar uma ou mais máquinas, recomendo que faça isso apontando para arquivos externos <code>.json</code> ao Prometheus. Para tal, podemos utilizar o mecanismo de discovery de arquivos estáticos. O discovery de arquivos estáticos permite ao Prometheus carregar dinamicamente configurações de scrape a partir de arquivos <code>.json</code> que contêm informações sobre os alvos a serem monitorados. Por exemplo:</p>


  <pre><code class="language-yaml">global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;prometheus&#39;
    static_configs:
      - targets: [&#39;localhost:9090&#39;]

  - job_name: &#39;my-app&#39;
    file_sd_configs:
      - files:
        - /path/to/targets.json</code></pre>
 <p>No exemplo acima, foi criado um novo job chamado <code>my-app</code>, que usará o discovery de arquivos estáticos para buscar os alvos a serem monitorados a partir do arquivo <code>/path/to/targets.json</code>. A seção <code>file_sd_configs</code> define as configurações para o discovery de arquivos estáticos, que neste caso é apenas o arquivo targets.json. O arquivo targets.json deve estar no seguinte formato:</p>


  <pre><code class="language-yaml">[
  {
    &#34;labels&#34;: {
      &#34;job&#34;: &#34;my-app&#34;,
      &#34;env&#34;: &#34;production&#34;
    },
    &#34;targets&#34;: [
      &#34;my-app1:8080&#34;,
      &#34;my-app2:8080&#34;
    ]
  }
]</code></pre>
 <p>Cada objeto tem uma chave labels que contém um objeto com rótulos adicionais para os alvos (neste exemplo, os rótulos são job e env), e uma chave targets que contém uma lista de alvos a serem monitorados. O job my-app terá dois alvos a serem monitorados: my-app1:8080 e my-app2:8080. Esses alvos terão os rótulos job e env definidos como my-app e production, respectivamente. Além da configuração de scrape (coleta) de dados, para produção é importante configurar a retenção de dados. Para isso, adicione o parâmetro <code>--storage.tsdb.retention.time</code> no systemd:</p>


  <pre><code class="language-bash">ExecStart=/opt/prometheus/prometheus --config.file=/opt/prometheus/prometheus.yml --storage.tsdb.retention.time=30d</code></pre>
 <blockquote>
<p><strong>NOTA</strong>: Para obter uma lista completa de parâmetros, consulte a <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">documentação oficial do Prometheus</a>.</p></blockquote>
<blockquote>
<p><strong>Observação</strong>: o discovery de arquivos estáticos é apenas um dos vários mecanismos de descoberta disponíveis no Prometheus.</p></blockquote>
<h4 id="configurações-avançadas">Configurações Avançadas</h4>
<h5 id="alerting">Alerting</h5>


  <pre><code class="language-yaml">alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
      scheme: http
      timeout: 10s
      api_version: v1</code></pre>
 <h5 id="remote-writeread">Remote Write/Read</h5>


  <pre><code class="language-yaml">remote_write:
  - url: &#34;http://remote-storage:9201/write&#34;
    remote_timeout: 30s
    write_relabel_configs:
      - source_labels: [__name__]
        regex: &#39;expensive_metric.*&#39;
        action: drop

remote_read:
  - url: &#34;http://remote-storage:9201/read&#34;
    read_timeout: 30s</code></pre>
 <h5 id="storage">Storage</h5>


  <pre><code class="language-yaml">storage:
  tsdb:
    retention.time: 15d
    retention.size: 50GB
    path: /prometheus/data
    wal:
      retention.period: 12h</code></pre>
 <h5 id="tracing-v241">Tracing (v2.41+)</h5>


  <pre><code class="language-yaml">tracing:
  endpoint: &#34;http://jaeger:14268/api/traces&#34;
  service_name: &#34;prometheus&#34;</code></pre>
 <h5 id="httptls-configuration">HTTP/TLS Configuration</h5>


  <pre><code class="language-yaml">global:
  scrape_interval: 15s
  external_url: &#39;http://prometheus.example.com&#39;

# Configuração TLS
tls_config:
  cert_file: /path/to/cert.pem
  key_file: /path/to/key.pem
  ca_file: /path/to/ca.pem

# Configuração OAuth2
oauth2:
  client_id: &#34;your-client-id&#34;
  client_secret: &#34;your-client-secret&#34;
  token_url: &#34;https://oauth.example.com/token&#34;</code></pre>
 <h2 id="promtool">Promtool</h2>
<p>O <a href="https://prometheus.io/docs/prometheus/latest/management_tools/promtool/">promtool</a> é uma ferramenta de linha de comando que fornece várias funcionalidades para ajudar a verificar a sintaxe de arquivos de configuração do Prometheus, como o arquivo prometheus.yml. Para verificar a sintaxe de um arquivo de configuração, basta executar o seguinte comando:</p>


  <pre><code class="language-bash">promtool check config /path/to/prometheus.yml</code></pre>
 <p>O promtool também permite validar a sintaxe das regras de alerta definidas no arquivo de configuração do Prometheus. Para isso, basta usar o seguinte comando:</p>


  <pre><code class="language-bash">promtool check rules /path/to/prometheus.yml</code></pre>
 <p>É possível também validar a sintaxe dos arquivos de registro de métricas antes de serem importados pelo Prometheus. Para isso, basta usar o seguinte comando:</p>


  <pre><code class="language-bash">promtool check metrics /path/to/metrics.json</code></pre>
 <p>Além disso, podemos converter métricas entre diferentes formatos, como JSON e texto simples. Por exemplo, para converter um arquivo de registro de métricas de formato texto para formato JSON, use o seguinte comando:</p>


  <pre><code class="language-bash">$ promtool convert metrics --from=txt --to=json &lt;arquivo_de_registro_de_metricas&gt;</code></pre>
 <p>O promtool pode ser usado para validar a integridade do armazenamento de métricas, ajudando a detectar problemas comuns, como blocos de registro corrompidos. Para isso, use o seguinte comando:</p>


  <pre><code class="language-bash">promtool tsdb check /path/to/data/dir</code></pre>
 <h4 id="comandos-avançados-do-promtool">Comandos Avançados do Promtool</h4>
<h5 id="consultas">Consultas</h5>


  <pre><code class="language-bash"># Consulta instantânea
promtool query instant http://localhost:9090 &#39;up&#39;

# Consulta de intervalo
promtool query range http://localhost:9090 &#39;rate(http_requests_total[5m])&#39; --start=2023-01-01T00:00:00Z --end=2023-01-01T01:00:00Z --step=1m</code></pre>
 <h5 id="debug">Debug</h5>


  <pre><code class="language-bash"># Debug de configuração
promtool check config --lint-fatal /path/to/prometheus.yml

# Debug de regras
promtool check rules --lint-fatal /path/to/rules.yml</code></pre>
 <h5 id="tsdb-operations">TSDB Operations</h5>


  <pre><code class="language-bash"># Análise do TSDB
promtool tsdb analyze /path/to/data

# Dump de blocos
promtool tsdb dump /path/to/data

# Criar blocos a partir de dados externos
promtool tsdb create-blocks-from openmetrics /path/to/metrics.txt /path/to/output</code></pre>
 <h5 id="teste-de-regras">Teste de Regras</h5>


  <pre><code class="language-bash"># Testar regras de alerta
promtool test rules /path/to/test.yml</code></pre>
 <h4 id="cenários-práticos">Cenários Práticos</h4>
<p><strong>1. Validação de Configuração em CI/CD:</strong></p>


  <pre><code class="language-bash">#!/bin/bash
if ! promtool check config prometheus.yml; then
    echo &#34;Configuração inválida!&#34;
    exit 1
fi</code></pre>
 <p><strong>2. Debug de Problemas de Scraping:</strong></p>


  <pre><code class="language-bash"># Verificar se um target está acessível
promtool query instant http://localhost:9090 &#39;up{job=&#34;node-exporter&#34;}&#39;</code></pre>
 <p><strong>3. Análise de Performance:</strong></p>


  <pre><code class="language-bash"># Analisar uso de memória do TSDB
promtool tsdb analyze /prometheus/data | grep &#34;memory&#34;</code></pre>
 <p>Essas são apenas algumas das funcionalidades do promtool. Ele pode ser uma ferramenta muito útil para garantir a qualidade do seu ambiente de monitoramento com Prometheus.</p>
<h2 id="-instrumentação">🔍 Instrumentação</h2>
<p>A instrumentação envolve coletar métricas de aplicações (instrumentação direta) ou sistemas externos (instrumentação indireta via exporters). Para detalhes completos sobre instrumentação, consulte a <a href="https://prometheus.io/docs/instrumenting/overview/">documentação oficial</a>.</p>
<h3 id="instrumentação-indireta">Instrumentação indireta</h3>
<h3 id="exporters">Exporters</h3>
<p>Exporters são programas que coletam métricas de sistemas externos e as convertem para o formato Prometheus. Eles permitem monitorar sistemas que não expõem métricas nativamente no formato Prometheus. Para mais informações sobre exporters, consulte a <a href="https://prometheus.io/docs/instrumenting/exporters/">documentação oficial do Prometheus</a>.</p>
<h3 id="linux">Linux</h3>
<p>O <a href="https://prometheus.io/docs/guides/node-exporter/">node_exporter</a> coleta métricas do sistema operacional Linux (CPU, memória, disco, rede). É especialmente útil para monitorar hosts Linux e clusters Kubernetes.</p>
<h3 id="windows">Windows</h3>
<p>O <a href="https://github.com/prometheus-community/windows_exporter">Windows_exporter</a> é a versão Windows do node_exporter, coletando métricas do sistema operacional Windows.</p>
<h3 id="blackbox">Blackbox</h3>
<p>O <a href="https://github.com/prometheus/blackbox_exporter">Blackbox Exporter</a> monitora serviços externos realizando requisições HTTP, TCP e ICMP em endpoints específicos.</p>
<h3 id="instrumentação-direta">Instrumentação direta</h3>
<h3 id="java">Java</h3>
<p>Use <strong><a href="https://micrometer.io/">Micrometer</a></strong> para instrumentação Java. Para exemplos completos e configuração, consulte a <a href="https://prometheus.io/docs/guides/java/">documentação oficial</a>.</p>
<h3 id="javascriptnode">JavaScript/Node</h3>
<p>Use <strong><a href="https://github.com/siimon/prom-client">prom-client</a></strong> para instrumentação Node.js. Para exemplos completos e configuração, consulte a <a href="https://prometheus.io/docs/guides/nodejs/">documentação oficial</a>.</p>
<h3 id="quando-usar-modo-agent-vs-modo-padrão">Quando usar modo Agent vs modo padrão</h3>
<h4 id="use-modo-agent-quando">Use modo Agent quando:</h4>
<ul>
<li>Você usa remote write para sistemas externos (Thanos, Cortex, VictoriaMetrics)</li>
<li>Precisa reduzir uso de recursos (CPU/disco)</li>
<li>Não precisa de consultas PromQL locais</li>
<li>Tem um sistema centralizado para alertas e consultas</li>
</ul>
<h4 id="use-modo-padrão-quando">Use modo padrão quando:</h4>
<ul>
<li>Precisa de consultas PromQL locais</li>
<li>Quer configurar alertas locais</li>
<li>Precisa de armazenamento local para análise</li>
<li>Está fazendo testes ou desenvolvimento</li>
<li>Tem um deployment standalone</li>
</ul>
<h4 id="comparação-de-recursos">Comparação de recursos:</h4>
<table>
  <thead>
      <tr>
          <th>Aspecto</th>
          <th>Modo Padrão</th>
          <th>Modo Agent</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Armazenamento local</td>
          <td>Sim (TSDB)</td>
          <td>Não</td>
      </tr>
      <tr>
          <td>Consultas PromQL</td>
          <td>Sim</td>
          <td>Não</td>
      </tr>
      <tr>
          <td>Alertas locais</td>
          <td>Sim</td>
          <td>Não</td>
      </tr>
      <tr>
          <td>Uso de CPU</td>
          <td>Alto</td>
          <td>Baixo</td>
      </tr>
      <tr>
          <td>Uso de disco</td>
          <td>Alto</td>
          <td>Muito baixo</td>
      </tr>
      <tr>
          <td>Remote write</td>
          <td>Opcional</td>
          <td>Obrigatório</td>
      </tr>
  </tbody>
</table>
<h3 id="python">Python</h3>
<p>Use <strong><a href="https://github.com/prometheus/client_python">prometheus_client</a></strong> para instrumentação Python. Para exemplos completos e configuração, consulte a <a href="https://prometheus.io/docs/guides/python/">documentação oficial</a>.</p>
<h3 id="ferramentas-legadas-e-privadas">Ferramentas legadas e privadas</h3>
<p>Para sistemas que não expõem métricas no formato Prometheus:</p>
<ul>
<li><strong>Bridge</strong>: programas intermediários que convertem métricas de formatos não compatíveis</li>
<li><strong>Plugins</strong>: extensões que coletam métricas de ferramentas específicas</li>
</ul>
<h2 id="alertmanager">Alertmanager</h2>
<p>O Alertmanager recebe alertas do Prometheus e os processa de acordo com regras configuradas, enviando notificações por email, Slack, PagerDuty, entre outros canais.</p>
<p>Para exemplos de configuração do Alertmanager, consulte a <a href="https://prometheus.io/docs/alerting/latest/configuration/">documentação oficial</a>.
group_by: [&lsquo;alertname&rsquo;]
group_wait: 30s
group_interval: 5m
repeat_interval: 1h
receiver: &lsquo;slack-notifications&rsquo;</p>
<p>receivers:</p>
<ul>
<li>name: &lsquo;slack-notifications&rsquo;
slack_configs:
<ul>
<li>api_url: &lsquo;<a href="https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX%27">https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX'</a>
channel: &lsquo;#alerts&rsquo;
send_resolved: true
title: &ldquo;{{ range .Alerts }}{{ .Annotations.summary }}\n{{ end }}&rdquo;
text: &ldquo;{{ range .Alerts }}{{ .Annotations.description }}\n{{ end }}&rdquo;</li>
</ul>
</li>
</ul>


  <pre><code class="language-">
Para configurar o Alertmanager com o Prometheus, é necessário criar um arquivo de configuração `alertmanager.yml` e especificar o endpoint do Alertmanager no arquivo de configuração `prometheus.yml`. O arquivo `alertmanager.yml` contém as regras de roteamento de alertas e configurações de notificação, como os destinatários e as plataformas de notificação. Para mais informações sobre como configurar o Alertmanager, consulte a documentação oficial em https://prometheus.io/docs/alerting/latest/configuration/.

&gt; **Observação**: o Alertmanager não é um componente obrigatório do Prometheus. Ele é uma ferramenta opcional que pode ser usada para gerenciar alertas. Se você não precisar de alertas, não precisa configurar o Alertmanager. Pretendo escrever um outro artigo dedicado ao Alertmanager, então fique ligado!

## PushGateway

PushGateway é um componente adicional do Prometheus projetado especificamente para **jobs de curta duração** que não podem ser monitorados diretamente pelo modelo pull do Prometheus. Ele funciona como uma &#34;ponte&#34; que recebe dados enviados pelos aplicativos e os repassa para o Prometheus Server.

### Casos de uso apropriados

O PushGateway é útil para:

- **Scripts e tarefas cron**: Jobs que executam por alguns minutos e terminam
- **Jobs de batch**: Processos que rodam periodicamente e terminam
- **Tarefas de manutenção**: Scripts de backup, limpeza, etc.
- **Jobs de CI/CD**: Builds, testes, deployments que têm duração limitada

### ⚠️ IMPORTANTE: Não use para serviços long-running

**O PushGateway NÃO deve ser usado para:**

- Serviços web que rodam continuamente
- Aplicações de longa duração
- Microserviços
- Qualquer serviço que possa ser monitorado diretamente pelo Prometheus

### Por que não usar para serviços long-running?

1. **Perda de dados**: O PushGateway não armazena dados persistentemente
2. **Sem alertas**: Não suporta funcionalidade de alertas do Prometheus
3. **Complexidade desnecessária**: Adiciona uma camada extra sem benefícios
4. **Problemas de escalabilidade**: Pode se tornar um gargalo
5. **Dificuldade de troubleshooting**: Mais difícil de debugar problemas

### Exemplo de uso correto

```bash
# Script que executa e termina
#!/bin/bash
# ... lógica do script ...

# Enviar métricas para PushGateway
echo &#34;my_job_duration_seconds 45.2&#34; | curl --data-binary @- http://pushgateway:9091/metrics/job/my_batch_job

# Script termina</code></pre>
 <h3 id="configuração-no-prometheus">Configuração no Prometheus</h3>


  <pre><code class="language-yaml">scrape_configs:
  - job_name: &#39;pushgateway&#39;
    honor_labels: true
    static_configs:
      - targets: [&#39;pushgateway:9091&#39;]</code></pre>
 <p>O PushGateway é uma ferramenta especializada para casos específicos. Para a maioria dos casos de uso, use instrumentação direta ou exporters.</p>
<h2 id="federação">Federação</h2>
<p>A Federação no Prometheus é um recurso que permite que várias instâncias do Prometheus sejam agrupadas e gerenciadas como uma única instância. Isso é útil quando você tem vários sistemas ou aplicativos que precisam ser monitorados, mas quer gerenciar esses dados de métricas de forma centralizada. A Federação funciona criando uma hierarquia de instâncias do Prometheus, onde cada instância é chamada de &ldquo;federada&rdquo; ou &ldquo;filha&rdquo; e uma instância é chamada de &ldquo;federadora&rdquo; ou &ldquo;pai&rdquo;. A instância &ldquo;federadora&rdquo; é responsável por coletar dados de métricas de todas as instâncias &ldquo;federadas&rdquo; e agrupá-los em um único local. No entanto, em alguns casos, o uso da Federação pode causar problemas. Abaixo uma melhor explicação sobre estes pontos:</p>
<ul>
<li><strong>Grande volume de dados</strong>: Se você estiver lidando com um grande volume de dados, a Federação pode sobrecarregar a instância central do Prometheus, já que todas as métricas são coletadas de várias instâncias e armazenadas na instância central. Isso pode levar a problemas de desempenho e latência.</li>
<li><strong>Aumento da complexidade</strong>: A configuração e manutenção de uma estrutura federada pode ser complexa, especialmente se você tiver várias instâncias do Prometheus e hierarquias diferentes. Isso pode tornar a solução difícil de gerenciar e manter, aumentando a chance de erros e problemas de configuração.</li>
<li><strong>Dependência de rede</strong>: A Federação exige uma conexão de rede estável e confiável entre as instâncias do Prometheus. Se a rede entre as instâncias for instável ou lenta, a coleta e consolidação das métricas pode ser afetada, causando atrasos ou perda de dados.</li>
<li><strong>Escalabilidade limitada</strong>: A Federação pode não ser a melhor opção para ambientes de grande escala, com muitos serviços e instâncias do Prometheus. Nesse cenário, a instância central pode se tornar um gargalo e limitar a escalabilidade geral do sistema de monitoramento.</li>
<li><strong>Segurança</strong>: A Federação requer que as instâncias do Prometheus se comuniquem entre si e compartilhem dados. Isso pode aumentar a superfície de ataque e potencialmente expor informações sensíveis, caso as medidas adequadas de segurança não sejam implementadas.</li>
</ul>
<blockquote>
<p><strong>NOTA</strong>: Em um outro artigo pretendo escrever sobre como resolver o problema de federação potencializando o Prometheus com outras técnologias, fique ligado!</p></blockquote>
<h2 id="under-the-hood">Under the Hood</h2>
<p>A pasta raiz do Prometheus contém vários arquivos de configuração e dados. Os arquivos mais comuns incluem:</p>
<ul>
<li><strong>prometheus.yml:</strong> Este é o arquivo de configuração principal do Prometheus. Ele contém configurações como endereços de coleta de dados, regras de alerta e configurações de armazenamento.</li>
<li><strong>alert.rules:</strong> Este arquivo contém regras de alerta que o Prometheus usa para gerar alertas quando as métricas atenderem a certas condições.</li>
<li><strong>scrape_configs:</strong> Este arquivo contém configurações de coleta de dados que o Prometheus usa para coletar métricas de diferentes fontes.</li>
<li><strong>rules.yml:</strong> Este arquivo contém as regras de processamento de métricas do Prometheus. Ele especifica como o Prometheus deve processar as métricas coletadas.</li>
<li><strong>data:</strong> Esta pasta contém os dados de métricas coletadas pelo Prometheus. Isso inclui arquivos como o banco de dados de métricas e arquivos de registro.</li>
</ul>
<p>Além desses arquivos, a pasta raiz do Prometheus também pode conter outros arquivos de configuração e dados, dependendo da configuração do Prometheus.  A pasta <strong>/data</strong> no Prometheus é usada para armazenar todos os dados coletados pelo Prometheus. Ela contém várias pastas, como <strong>WAL, chunks_head,</strong> que são usadas para armazenar diferentes tipos de dados. Exemplo:</p>


  <pre><code class="language-bash">./data
├── 01BKGV7JBM69T2G1BGBGM6KB12
│   └── meta.json
├── 01BKGTZQ1SYQJTR4PB43C8PD98
│   ├── chunks
│   │   └── 000001
│   ├── tombstones
│   ├── index
│   └── meta.json
├── 01BKGTZQ1HHWHV8FBJXW1Y3W0K
│   └── meta.json
├── 01BKGV7JC0RY8A6MACW02A2PJD
│   ├── chunks
│   │   └── 000001
│   ├── tombstones
│   ├── index
│   └── meta.json
├── chunks_head
│   └── 000001
└── wal
    ├── 000000002
    └── checkpoint.00000001
        └── 00000000</code></pre>
 <p>O arquivo meta.json é usado para armazenar metadados dos séries de dados que o Prometheus está rastreando. Ele contém informações como o nome do arquivo e o intervalo de tempo dos dados armazenados, bem como outras informações relevantes para o funcionamento interno do Prometheus. Os itens específicos dentro do arquivo meta.json podem variar dependendo da configuração específica do Prometheus e do tipo de série de dados que está sendo rastreada. Vamos aos detalhes:</p>


  <pre><code class="language-bash">{
    &#34;ulid&#34;: &#34;01BKGTZQ1SYQJTR4PB43C8PD98&#34;,
    &#34;minTime&#34;: 1602237600000,
    &#34;maxTime&#34;: 1602244800000,
    &#34;stats&#34;: {
        &#34;numSamples&#34;: 553673232,
        &#34;numSeries&#34;: 1346066,
        &#34;numChunks&#34;: 4440437
    },
    &#34;compaction&#34;: {
        &#34;level&#34;: 1,
        &#34;sources&#34;: [
            &#34;01EM65SHSX4VARXBBHBF0M0FDS&#34;,
            &#34;01EM6GAJSYWSQQRDY782EA5ZPN&#34;
        ]
    },
    &#34;version&#34;: 1
}</code></pre>
 <ul>
<li><strong>ulid:</strong> é um identificador único gerado para cada arquivo meta.json. É usado para identificar de forma única cada série de dados armazenada pelo Prometheus.</li>
<li><strong>minTime e maxTime:</strong> são os intervalos de tempo de início e fim dos dados armazenados no arquivo meta.json. Eles são usados para determinar o período de tempo para o qual os dados armazenados no arquivo são válidos.</li>
<li><strong>stats:</strong> é um objeto que contém estatísticas sobre o uso de memória do arquivo meta.json, incluindo o tamanho do arquivo, o número de séries de dados armazenadas e o número de amostras de dados.</li>
<li><strong>numSamples:</strong> é o número de amostras de dados armazenadas no arquivo meta.json.</li>
<li><strong>numSeries:</strong> é o número de séries de dados armazenadas no arquivo meta.json.</li>
<li><strong>numChunks:</strong> é o número de chunks de dados (grupos de amostras de dados) armazenados no arquivo meta.json.</li>
<li><strong>compaction:</strong> é um objeto que contém informações sobre a compactação dos dados armazenados no arquivo meta.json.</li>
<li><strong>level:</strong> é o nível de compactação dos dados armazenados no arquivo meta.json.</li>
<li><strong>sources:</strong> é um array que contém informações sobre as fontes dos dados armazenados no arquivo meta.json.</li>
<li><strong>version:</strong> é a versão do arquivo meta.json. É usado para garantir compatibilidade com versões futuras do Prometheus.</li>
</ul>
<p>A pasta &ldquo;chunks&rdquo; dentro da pasta 01BKGTZQ1SYQJTR4PB43C8PD98 dentro do diretório /data do Prometheus é usada para armazenar os chunks de dados (grupos de amostras de dados) para cada série de dados que o Prometheus está rastreando. Cada arquivo dentro dessa pasta representa um chunk de dados único, e o nome do arquivo contém informações sobre o intervalo de tempo e a série de dados a qual ele pertence. Os arquivos de chunks são gerados pelo processo de compactação do Prometheus. Eles são criados quando o Prometheus precisa remover dados antigos para liberar espaço e continuar coletando novos dados.</p>
<p>Esses chunks são usados para a recuperação dos dados e para realizar consultas no futuro. Os arquivos contidos dentro dessa pasta são codificados e compactados de forma a ocupar menos espaço e são lidos pelo Prometheus para responder consultas e exibir gráficos. Já o arquivo index, contém o índice dos chunks de dados armazenados na pasta &ldquo;chunks&rdquo; da mesma pasta. O índice é usado para permitir que o Prometheus rápida e eficientemente localize os chunks de dados relevantes para uma consulta específica. Esse arquivo contém informações sobre as séries de dados, o intervalo de tempo dos dados, o nome do arquivo de chunk correspondente, e outras informações relevantes. O Prometheus usa essas informações para saber onde procurar os dados quando uma consulta é realizada, permitindo que ele responda rapidamente.</p>
<h3 id="gerenciamento-de-memória-pelo-prometheus">Gerenciamento de memória pelo Prometheus</h3>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/main/post/images/tsdb/prom-mem01.png" alt="img">
<small style="text-align:center;"><b>Imagem 1.1</b></small></p>
<p>A imagem 1.1 acima representa o Prometheus quando usa memória RAM e espaço em disco devido à natureza dos dados que ele coleta e armazena.</p>
<h4 id="head-block">Head Block</h4>
<p>O head block é a parte mais recente dos dados do Prometheus que fica em memória. Por padrão, ele contém dados das últimas duas horas e consome aproximadamente 3 kB por série temporal. O head block é otimizado para:</p>
<ul>
<li><strong>Consultas rápidas</strong>: Dados em memória permitem acesso imediato</li>
<li><strong>Escrita eficiente</strong>: Novos dados são escritos diretamente no head block</li>
<li><strong>Compactação</strong>: Quando o head block atinge o limite de tempo, ele é compactado e movido para o disco</li>
</ul>
<p>O tamanho do head block pode ser configurado através do parâmetro <code>--storage.tsdb.min-block-duration</code> e <code>--storage.tsdb.max-block-duration</code>.</p>
<h4 id="write-ahead-log-wal">Write-Ahead Log (WAL)</h4>
<p>O WAL é um mecanismo de persistência que garante que nenhum dado seja perdido, mesmo em caso de falha do sistema. Funciona da seguinte forma:</p>
<ul>
<li><strong>Gravação imediata</strong>: Todas as mudanças são gravadas no WAL antes de serem aplicadas em memória</li>
<li><strong>Recuperação</strong>: Em caso de falha, o Prometheus pode recuperar dados do WAL</li>
<li><strong>Compactação automática</strong>: O WAL é periodicamente compactado e os dados são movidos para blocos permanentes</li>
<li><strong>Sem dependência do swap</strong>: O Prometheus não usa swap do sistema operacional; o WAL é gravado diretamente em disco</li>
</ul>
<p>O WAL é armazenado no diretório <code>wal/</code> dentro do diretório de dados do Prometheus e é gerenciado automaticamente pelo sistema.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/main/post/images/tsdb/prom-mem02.png" alt="img">
<small style="text-align:center;"><b>Imagem 1.2</b></small></p>
<p>Como bem mostra a Imagem 1.2 acima, quanto mais dias de dados são armazenados, mais espaço em disco será necessário para armazená-los.</p>
<p><img src="https://raw.githubusercontent.com/scovl/scovl.github.io/main/post/images/tsdb/prom-mem03.png" alt="img">
<small style="text-align:center;"><b>Imagem 1.3</b></small></p>
<p>Como mostra na Imagem 1.3 acima, o Prometheus utiliza a memória principal do host Linux para armazenar apenas o &ldquo;head block&rdquo; (dados das últimas duas horas por padrão) e metadados das métricas coletadas. O Prometheus mantém aproximadamente 3 kB por série temporal em memória para o head block, que contém os dados mais recentes para consultas rápidas.</p>
<h2 id="promql">PromQL</h2>
<p>PromQL é uma linguagem de consulta poderosa usada para realizar consultas e configurar alertas sobre dados coletados pelo Prometheus. Seu principal objetivo é possibilitar a análise e monitoramento de métricas, como requisições HTTP por segundo ou a média de utilização de CPU por servidor, por meio de expressões que definem cálculos específicos. Importante para os usuários do Prometheus, a PromQL suporta funções matemáticas, operações booleanas e de comparação, além de agrupamento de dados e agregações. Além disso, conta com recursos avançados como subconsultas e funções de séries temporais. As consultas PromQL podem ser executadas através da interface web do Prometheus, APIs ou bibliotecas de clientes.</p>
<p>A linguagem também possibilita a criação de gráficos e painéis de visualização para métricas, utilizando ferramentas de visualização de dados como o Grafana. Dessa forma, a PromQL se mostra essencial para monitorar e analisar o desempenho de sistemas com eficiência e precisão.</p>
<h3 id="time-series-database">Time series database</h3>
<p>O Prometheus armazena dados em um formato binário chamado TSDB (Time Series Database). O TSDB é um banco de dados de séries temporais otimizado para armazenar dados de métricas. Para simplificar o entendimento acerca de um banco de dados de série temporal, imagine que você tem um diário onde você registra a temperatura do ar todos os dias, às mesmas horas, assim como a velocidade do vento, pressão atmosférica, entre outras informações. Essas informações são armazenadas em ordem cronológica, ou seja, por ordem de tempo, e é possível consultá-las para ver como esses dados variam ao longo do tempo.</p>
<p>Monitorar métricas a partir de um banco de dados em série temporal tem várias vantagens:</p>
<ul>
<li><strong>Análise histórica:</strong> Um banco de dados em série temporal armazena dados em ordem cronológica, o que permite a análise de tendências e padrões ao longo do tempo.</li>
<li><strong>Identificação de problemas:</strong> Armazenando dados em ordem cronológica, é possível investigar problemas usando dados históricos.</li>
<li><strong>Alertas baseados no tempo:</strong> Com dados armazenados em ordem cronológica, é possível criar alertas baseados no tempo.</li>
<li><strong>Armazenamento escalável:</strong> Banco de dados em série temporal são projetados para lidar com grandes volumes de dados e escalar horizontalmente.</li>
<li><strong>Integração com outras ferramentas:</strong> A maioria das ferramentas de monitoramento e análise de dados suportam a coleta de dados de banco de dados em série temporal.</li>
</ul>
<h3 id="seletores">Seletores</h3>
<p>Os seletores em PromQL são como filtros que permitem escolher uma ou mais métricas específicas para consultas. Existem dois tipos de seletores: o primeiro é o seletor de nome de métrica, que seleciona métricas pelo seu nome, como por exemplo <code>http_requests_total</code>. O segundo é o seletor de label, que seleciona métricas pelo label associado a elas.</p>
<p>Exemplo:</p>


  <pre><code class="language-bash">http_requests_total{method=&#34;GET&#34;, handler=&#34;/api/v1/users&#34;}</code></pre>
 <ul>
<li>Selecionando todas as métricas que possuem &ldquo;http&rdquo; no nome:</li>
</ul>


  <pre><code class="language-bash">{__name__=~&#34;http.*&#34;}</code></pre>
 <ul>
<li>Selecionando métricas que possuem o label &ldquo;status&rdquo; com o valor &ldquo;error&rdquo;:</li>
</ul>


  <pre><code class="language-bash">{status=&#34;error&#34;}</code></pre>
 <h3 id="tipos-de-expressões">Tipos de expressões</h3>
<p>Em PromQL, existem vários tipos de expressões que podem ser usadas para manipular as métricas coletadas pelo Prometheus:</p>
<ul>
<li><strong>Expressões aritméticas:</strong> são usadas para realizar cálculos matemáticos em séries de métricas. Por exemplo:</li>
</ul>


  <pre><code class="language-bash">node_cpu_seconds_total{mode=&#34;system&#34;} / node_cpu_seconds_total{mode=&#34;idle&#34;} * 100</code></pre>
 <ul>
<li><strong>Funções de agregação:</strong> são usadas para agrupar e resumir séries de métricas. Exemplo:</li>
</ul>


  <pre><code class="language-bash">sum(rate(http_requests_total[5m])) by (job)</code></pre>
 <ul>
<li><strong>Funções de filtro:</strong> são usadas para filtrar séries de métricas com base em seus labels. Exemplo:</li>
</ul>


  <pre><code class="language-bash">topk(5, http_requests_total)</code></pre>
 <ul>
<li><strong>Funções de transformação:</strong> são usadas para transformar séries de métricas de uma maneira específica. Exemplo:</li>
</ul>


  <pre><code class="language-bash">histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))</code></pre>
 <h3 id="vector-vs-range-vector">Vector vs Range Vector</h3>
<p>Em PromQL, há dois tipos principais de vetores que podemos usar em nossas consultas:</p>
<ul>
<li>
<p><strong>Vetor:</strong> É um conjunto de pontos de dados com os mesmos labels, representando a série temporal de uma única métrica. Por exemplo, o vetor <code>up{job=&quot;prometheus&quot;}</code> representa o tempo em que o serviço Prometheus estava em execução ou não.</p>
</li>
<li>
<p><strong>Range Vector:</strong> É um conjunto de pontos de dados com os mesmos labels, mas que representa um intervalo de tempo em vez de um único ponto no tempo. Exemplo: <code>up{job=&quot;prometheus&quot;}[5m]</code> representa o tempo em que o serviço Prometheus estava em execução ou não nos últimos 5 minutos.</p>
</li>
</ul>
<h3 id="funções-principais">Funções principais</h3>
<h4 id="funções-de-agregação">Funções de agregação</h4>
<ul>
<li><strong>sum():</strong> Soma os valores de uma série temporal</li>
<li><strong>avg():</strong> Calcula a média dos valores</li>
<li><strong>min():</strong> Retorna o valor mínimo</li>
<li><strong>max():</strong> Retorna o valor máximo</li>
<li><strong>count():</strong> Conta o número de séries temporais</li>
</ul>
<h4 id="funções-de-taxa">Funções de taxa</h4>
<ul>
<li><strong>rate():</strong> Calcula a taxa de variação por segundo ao longo de um intervalo de tempo</li>
<li><strong>irate():</strong> Calcula a taxa instantânea de variação</li>
<li><strong>increase():</strong> Calcula o incremento total do contador em um intervalo de tempo (soma todas as mudanças)</li>
</ul>
<blockquote>
<p><strong>Diferença importante</strong>: <code>rate()</code> retorna a taxa por segundo (ex: 10 req/s), enquanto <code>increase()</code> retorna o total absoluto (ex: 600 requisições nos últimos 60s). <code>increase()</code> é essencialmente <code>rate() * intervalo_de_tempo</code>.</p></blockquote>
<h4 id="funções-de-tempo">Funções de tempo</h4>
<ul>
<li><strong>time():</strong> Retorna o timestamp atual</li>
<li><strong>timestamp():</strong> Retorna o timestamp de uma série temporal</li>
</ul>
<h3 id="exemplos-práticos">Exemplos práticos</h3>
<h4 id="cpu-usage">CPU Usage</h4>
<ul>
<li>Uso médio da CPU nos últimos 5 minutos:</li>
</ul>


  <pre><code class="language-bash">avg(rate(node_cpu_seconds_total{mode=&#34;idle&#34;}[5m])) * 100</code></pre>
 <ul>
<li>Uso da CPU por processo:</li>
</ul>


  <pre><code class="language-bash">100 - avg by (process) (irate(process_cpu_seconds_total{process!=&#34;prometheus&#34;}[5m])) * 100</code></pre>
 <h4 id="memória">Memória</h4>
<ul>
<li>Porcentagem de memória usada:</li>
</ul>


  <pre><code class="language-bash">100 - ((node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100)</code></pre>
 <h4 id="http-requests">HTTP Requests</h4>
<ul>
<li>Taxa de requisições HTTP por segundo:</li>
</ul>


  <pre><code class="language-bash">rate(http_requests_total[5m])</code></pre>
 <ul>
<li>Total de requisições HTTP nos últimos 5 minutos:</li>
</ul>


  <pre><code class="language-bash">increase(http_requests_total[5m])</code></pre>
 <ul>
<li>Taxa de erros HTTP (códigos 5xx):</li>
</ul>


  <pre><code class="language-bash">rate(http_requests_total{status=~&#34;5..&#34;}[5m])</code></pre>
 <ul>
<li>Total de erros HTTP nos últimos 5 minutos:</li>
</ul>


  <pre><code class="language-bash">increase(http_requests_total{status=~&#34;5..&#34;}[5m])</code></pre>
 <h3 id="erros-comuns">Erros comuns</h3>
<ul>
<li><strong>Cardinalidade alta:</strong> Usar labels com valores não-limitados pode sobrecarregar o Prometheus. Exemplo problemático:</li>
</ul>


  <pre><code class="language-bash">rate(http_requests_total{user_id!=&#34;&#34;}[5m])</code></pre>
 <p><strong>Solução:</strong> Use labels com valores categorizados e limitados:</p>


  <pre><code class="language-bash">rate(http_requests_total{status=~&#34;2..|3..|4..|5..&#34;}[5m])</code></pre>
 <ul>
<li><strong>Granularidade desnecessária:</strong> Selecionar uma granularidade muito alta pode gerar muitos dados. Exemplo problemático:</li>
</ul>


  <pre><code class="language-bash">rate(http_requests_total[1s])</code></pre>
 <ul>
<li><strong>Ignorar funções de agregação:</strong> Esquecer de usar funções de agregação pode resultar em gráficos confusos.</li>
</ul>
<blockquote>
<p><strong>Observação</strong>: A dica de ouro é que se você está tendo problema de desempenho em trazer métricas, provavelmente há algo errado com a sua query.</p></blockquote>
<h2 id="melhores-práticas">Melhores Práticas</h2>
<p>Após entendermos a arquitetura interna do Prometheus e como ele gerencia dados, é importante discutir algumas melhores práticas que podem otimizar seu uso e evitar problemas comuns:</p>
<h3 id="planejamento-de-capacidade">Planejamento de Capacidade</h3>
<ul>
<li><strong>Dimensionamento adequado</strong>: Planeje o dimensionamento do servidor Prometheus com base no número de métricas a serem coletadas, frequência de coleta e período de retenção.</li>
<li><strong>Monitoramento do próprio Prometheus</strong>: Utilize métricas como <code>prometheus_tsdb_head_series</code> e <code>prometheus_engine_queries</code> para monitorar a saúde da própria instância.</li>
<li><strong>Política de retenção</strong>: Defina uma política de retenção realista (via <code>--storage.tsdb.retention.time</code> ou <code>--storage.tsdb.retention.size</code>) baseada nas necessidades reais de análise histórica.</li>
</ul>
<h3 id="organização-de-métricas">Organização de Métricas</h3>
<ul>
<li><strong>Nomeação consistente</strong>: Adote um padrão de nomenclatura para suas métricas usando snake_case e prefixos de aplicação (<code>app_http_requests_total</code>).</li>
<li><strong>Labels significativos</strong>: Use labels para adicionar dimensões às métricas, mas evite valores não-limitados.</li>
<li><strong>Evite explosão de cardinalidade</strong>: Nunca use valores de alta cardinalidade como IDs de usuário, URLs completos ou timestamps como labels. Prefira valores categorizados e limitados.</li>
</ul>
<h3 id="cardinalidade">Cardinalidade</h3>
<p>A cardinalidade refere-se ao número de séries temporais únicas criadas por suas métricas. Alta cardinalidade pode causar problemas de performance e consumo de memória.</p>
<h4 id="-valores-problemáticos-alta-cardinalidade">❌ Valores problemáticos (alta cardinalidade):</h4>
<ul>
<li>IDs de usuário: <code>user_id=&quot;12345&quot;</code></li>
<li>URLs completos: <code>url=&quot;/api/users/12345/posts/67890/comments&quot;</code></li>
<li>Timestamps: <code>timestamp=&quot;2023-03-21T15:30:45Z&quot;</code></li>
<li>IPs dinâmicos: <code>ip=&quot;192.168.1.100&quot;</code></li>
</ul>
<h4 id="-valores-recomendados-cardinalidade-controlada">✅ Valores recomendados (cardinalidade controlada):</h4>
<ul>
<li>Status codes: <code>status=&quot;200&quot;</code>, <code>status=&quot;404&quot;</code>, <code>status=&quot;500&quot;</code></li>
<li>Métodos HTTP: <code>method=&quot;GET&quot;</code>, <code>method=&quot;POST&quot;</code></li>
<li>Endpoints categorizados: <code>endpoint=&quot;/api/users&quot;</code>, <code>endpoint=&quot;/api/posts&quot;</code></li>
<li>Regiões: <code>region=&quot;us-east-1&quot;</code>, <code>region=&quot;eu-west-1&quot;</code></li>
<li>Ambientes: <code>env=&quot;production&quot;</code>, <code>env=&quot;staging&quot;</code></li>
</ul>
<h4 id="princípio-use-valores-que-você-pode-listar">Princípio: Use valores que você pode listar</h4>
<p>Se você não consegue listar todos os valores possíveis de uma label, ela provavelmente tem cardinalidade muito alta.</p>
<h3 id="consultas-eficientes">Consultas Eficientes</h3>
<ul>
<li><strong>Limite o uso de funções pesadas</strong>: Funções como <code>topk()</code>, <code>bottomk()</code> e agregações com <code>by</code> em muitas dimensões podem ser caras.</li>
<li><strong>Prefira <code>rate()</code> sobre <code>irate()</code></strong>: Para a maioria dos dashboards, <code>rate()</code> oferece uma visão mais estável da taxa de mudança de uma métrica.</li>
<li><strong>Use intervalos de tempo razoáveis</strong>: Consultas sobre períodos muito longos consomem mais recursos; limite-as quando possível.</li>
</ul>
<h3 id="arquitetura-para-escala">Arquitetura para Escala</h3>
<ul>
<li><strong>Adote Prometheus hierárquico</strong>: Para ambientes grandes, considere uma arquitetura hierárquica com federação para dividir a carga.</li>
<li><strong>Considere soluções de longo prazo</strong>: Para retenção de longo prazo e alta disponibilidade, explore soluções como Thanos, Cortex ou VictoriaMetrics.</li>
<li><strong>Sharding</strong>: Em ambientes muito grandes, divida o trabalho de scraping entre múltiplas instâncias do Prometheus.</li>
</ul>
<h3 id="segurança">Segurança</h3>
<ul>
<li><strong>Controle de acesso</strong>: Implemente autenticação e autorização para acesso à API do Prometheus.</li>
<li><strong>TLS para endpoints</strong>: Habilite TLS para comunicações entre Prometheus e seus alvos quando possível.</li>
<li><strong>Isolamento de rede</strong>: Restrinja o acesso ao Prometheus apenas a redes confiáveis ou use um proxy reverso com autenticação.</li>
</ul>
<p>A implementação dessas práticas não apenas melhorará o desempenho do seu ambiente Prometheus, mas também facilitará sua manutenção e crescimento ao longo do tempo.</p>
<h2 id="recursos-modernos-do-prometheus">Recursos Modernos do Prometheus</h2>
<h3 id="native-histogram-beta--v240">Native Histogram (Beta ≥ v2.40)</h3>
<p>O Prometheus introduziu native histograms como uma alternativa mais eficiente aos histogramas tradicionais. Native histograms reduzem significativamente a cardinalidade para métricas de latência, oferecendo melhor performance e menor uso de memória.</p>
<h4 id="vantagens-dos-native-histograms">Vantagens dos Native Histograms:</h4>
<ul>
<li><strong>Menor cardinalidade</strong>: Não criam múltiplas séries por bucket</li>
<li><strong>Melhor performance</strong>: Consultas mais rápidas</li>
<li><strong>Flexibilidade</strong>: Buckets dinâmicos baseados na distribuição real dos dados</li>
<li><strong>Compatibilidade</strong>: Funciona com ferramentas existentes</li>
</ul>
<h4 id="exemplo-de-configuração">Exemplo de configuração:</h4>


  <pre><code class="language-yaml"># Em prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;my-app&#39;
    static_configs:
      - targets: [&#39;my-app:8080&#39;]
    metric_relabel_configs:
      - source_labels: [__name__]
        regex: &#39;http_request_duration_seconds&#39;
        action: replace
        target_label: __name__
        replacement: &#39;http_request_duration_seconds_native&#39;</code></pre>
 <h3 id="vertical-sharding-experimental-v251">Vertical Sharding Experimental (v2.51+)</h3>
<p>O Prometheus 2.51 introduziu vertical sharding experimental, permitindo distribuir a carga de scraping entre múltiplas instâncias do Prometheus.</p>
<h3 id="ecossistema-atualizado">Ecossistema Atualizado</h3>
<h4 id="grafana-mimir">Grafana Mimir</h4>
<p>Grafana Mimir, um fork do Cortex, amadureceu significativamente e hoje concorre diretamente com Thanos e VictoriaMetrics. Oferece:</p>
<ul>
<li><strong>Alta disponibilidade</strong>: Múltiplas réplicas</li>
<li><strong>Retenção de longo prazo</strong>: Armazenamento escalável</li>
<li><strong>Compatibilidade PromQL</strong>: Consultas nativas</li>
<li><strong>Integração Grafana</strong>: Dashboard nativo</li>
</ul>
<h4 id="opentelemetry">OpenTelemetry</h4>
<p>OpenTelemetry se tornou o padrão de fato para instrumentação. O Prometheus suporta o protocolo OTLP através de receivers:</p>


  <pre><code class="language-yaml"># Configuração OTLP receiver
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318</code></pre>
 <h4 id="chronosphere">Chronosphere</h4>
<p>Chronosphere emergiu como uma solução comercial robusta, oferecendo:</p>
<ul>
<li><strong>Observabilidade completa</strong>: Métricas, logs e traces</li>
<li><strong>Escalabilidade global</strong>: Distribuição geográfica</li>
<li><strong>Análise avançada</strong>: Machine learning para detecção de anomalias</li>
</ul>
<h2 id="conclusão">Conclusão</h2>
<p>Neste artigo, exploramos em detalhes o Prometheus, desde seus conceitos fundamentais até sua arquitetura interna e funcionamento técnico. Vimos como ele implementa um banco de dados de séries temporais eficiente e como gerencia dados tanto em memória quanto em disco.</p>
<p>O Prometheus se destaca no ecossistema de monitoramento por sua simplicidade, eficiência e abordagem pull-based, tornando-o uma ferramenta poderosa para monitorar ambientes modernos, especialmente os nativos da nuvem. Sua capacidade de coletar, armazenar e consultar métricas com baixa latência permite detectar problemas rapidamente e tomar decisões baseadas em dados.</p>
<p>Entretanto, como qualquer ferramenta, o Prometheus tem seus limites, especialmente em termos de escalabilidade e retenção de longo prazo. É por isso que o ecossistema tem evoluído para incluir soluções complementares como Thanos, VictoriaMetrics e Cortex, que abordaremos em artigos futuros. A compreensão profunda do funcionamento interno do Prometheus apresentada aqui deve ajudar engenheiros e operadores a aproveitar melhor seus recursos, otimizar seu desempenho e evitar armadilhas comuns.</p>
<p>Esperamos que este guia tenha fornecido insights valiosos tanto para iniciantes quanto para usuários experientes do Prometheus, e que sirva como referência para implementações bem-sucedidas em seus ambientes de produção.</p>
<hr>
<h2 id="referências">Referências</h2>
<ul>
<li><strong><a href="https://prometheus.io/docs/introduction/overview/">Documentação Oficial</a></strong></li>
<li><strong><a href="https://www.robustperception.io/blog/">Site da RobustPerception</a></strong></li>
<li><strong><a href="https://www.oreilly.com/library/view/prometheus-up/9781492034131/">Prometheus Up and Running</a></strong></li>
<li><strong><a href="https://www.prometheusbook.com/">Prometheusbook de James Turnbull</a></strong></li>
<li><strong><a href="https://www.oreilly.com/library/view/hands-on-infrastructure-monitoring/9781789612349/">Hands-On Infrastructure Monitoring with Prometheus</a></strong></li>
<li><strong><a href="https://www.oreilly.com/library/view/monitoring-microservices-and/9781484262160/">Monitoring Microservices and Containerized Applications</a></strong></li>
</ul>
<h3 id="prometheus-vs-outras-ferramentas-de-monitoramento">Prometheus vs. Outras Ferramentas de Monitoramento</h3>
<p>Entender como o Prometheus se compara a outras ferramentas populares de monitoramento pode ajudar a escolher a solução certa para seu ambiente:</p>
<table>
  <thead>
      <tr>
          <th>Ferramenta</th>
          <th>Modelo</th>
          <th>Armazenamento</th>
          <th>Foco</th>
          <th>Pontos Fortes</th>
          <th>Limitações</th>
          <th>Licença</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Prometheus</strong></td>
          <td>Pull-based</td>
          <td>TSDB próprio</td>
          <td>Métricas</td>
          <td>Simplicidade, PromQL, ecossistema Cloud Native</td>
          <td>Retenção de longo prazo, alta disponibilidade</td>
          <td>Apache 2.0</td>
      </tr>
      <tr>
          <td><strong>Grafana Mimir</strong></td>
          <td>Pull/Push</td>
          <td>Distribuído</td>
          <td>Métricas</td>
          <td>Escalabilidade horizontal, compatibilidade com PromQL</td>
          <td>Complexidade de configuração</td>
          <td>AGPL-3.0</td>
      </tr>
      <tr>
          <td><strong>VictoriaMetrics</strong></td>
          <td>Pull/Push</td>
          <td>Proprietário</td>
          <td>Métricas</td>
          <td>Performance, compressão eficiente</td>
          <td>Custo para versão enterprise</td>
          <td>Apache 2.0</td>
      </tr>
      <tr>
          <td><strong>Datadog</strong></td>
          <td>Push-based</td>
          <td>Proprietário</td>
          <td>Métricas, logs, traces</td>
          <td>Interface unificada, monitoramento completo</td>
          <td>Custo, código fechado</td>
          <td>Proprietário</td>
      </tr>
      <tr>
          <td><strong>New Relic</strong></td>
          <td>Push-based</td>
          <td>Proprietário</td>
          <td>APM, métricas</td>
          <td>Profiling de aplicações, dashboards prontos</td>
          <td>Custo, menos flexível</td>
          <td>Proprietário</td>
      </tr>
      <tr>
          <td><strong>Nagios</strong></td>
          <td>Pull-based</td>
          <td>Relacional</td>
          <td>Verificações de disponibilidade</td>
          <td>Maturidade, extensibilidade</td>
          <td>Configuração complexa, visualização limitada</td>
          <td>GPL-2.0</td>
      </tr>
      <tr>
          <td><strong>ELK Stack</strong></td>
          <td>Push-based</td>
          <td>Elasticsearch</td>
          <td>Logs, métricas</td>
          <td>Pesquisa poderosa, análise de logs</td>
          <td>Consumo de recursos, complexidade</td>
          <td>Apache 2.0</td>
      </tr>
  </tbody>
</table>
<p>O Prometheus se destaca pela sua abordagem não-intrusiva de monitoramento, focando primariamente em métricas numéricas e oferecendo uma linguagem de consulta poderosa. É especialmente adequado para ambientes dinâmicos como Kubernetes, onde serviços vêm e vão constantemente.</p>
<p>Enquanto soluções como <a href="https://www.datadoghq.com/">Datadog</a> e <a href="https://newrelic.com/">New Relic</a> oferecem experiências mais integradas com APM (Application Performance Monitoring) e análise de logs, elas tendem a ser mais caras e menos flexíveis. O Prometheus, sendo open source, permite maior personalização e integração com outras ferramentas de código aberto.</p>

    </div>
    
    
    <div class="post-comments">
        <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "scovl" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
    
</article>

        </div>
    </main>
    
    
    
    <footer class="footer">
    <div class="container">
        <div class="footer-content">
            <div class="footer-links">
                
                <a href="https://github.com/scovl" target="_blank" rel="noopener noreferrer" class="footer-link">
                    GitHub
                </a>
                
                
                
                <a href="https://linkedin.com/in/vitor-lobo" target="_blank" rel="noopener noreferrer" class="footer-link">
                    LinkedIn
                </a>
                
                
                
                <a href="mailto:lobocode@gmail.com" class="footer-link">
                    Email
                </a>
                

                
                <a href="https://hachyderm.io/@lobocode" target="_blank" rel="noopener noreferrer" class="footer-link">
                    Mastodon
                </a>
                

                
                <a href="https://scovl.github.io/index.xml" target="_blank" rel="noopener noreferrer" class="footer-link">
                    RSS
                </a>
                
            </div>
            
            <div class="copyright">
                &copy; 2025 Vitor Lobo
            </div>
        </div>
    </div>
</footer> 
    
    
    
    <script src="/js/main-minimal.js"></script>
    
    
    
</body>
</html> 